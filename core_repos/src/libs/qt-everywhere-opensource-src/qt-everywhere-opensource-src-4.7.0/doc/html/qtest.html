<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qtestcase.cpp -->
  <title>Qt 4.7: QTest Namespace</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="namespaces.html">Namespaces</a></li>              <li>QTest Namespace</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#classes">Classes</a></li>
<li class="level1"><a href="#types">Types</a></li>
<li class="level1"><a href="#functions">Functions</a></li>
<li class="level1"><a href="#macros">Macros</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QTest Namespace</h1>
<!-- $$$QTest-brief -->
<p>The QTest namespace contains all the functions and declarations that are related to the <a href="qtestlib-manual.html#qtestlib">QTestLib</a> tool. <a href="#details">More...</a></p>
<!-- @@@QTest -->
<pre class="highlightedCode brush: cpp"> #include &lt;QTest&gt;</pre><ul>
</ul>
<a name="classes"></a>
<h2>Classes</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a></b></td></tr>
</table>
<a name="types"></a>
<h2>Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#AttributeIndex-enum">AttributeIndex</a></b> { AI_Undefined, AI_Name, AI_Result, AI_Tests, ..., AI_Iterations }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#KeyAction-enum">KeyAction</a></b> { Press, Release, Click }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#LogElementType-enum">LogElementType</a></b> { LET_Undefined, LET_Property, LET_Properties, LET_Failure, ..., LET_SystemError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#MouseAction-enum">MouseAction</a></b> { MousePress, MouseRelease, MouseClick, MouseDClick, MouseMove }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QBenchmarkMetric-enum">QBenchmarkMetric</a></b> { FramesPerSecond, BitsPerSecond, BytesPerSecond, WalltimeMilliseconds, ..., Events }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#SkipMode-enum">SkipMode</a></b> { SkipSingle, SkipAll }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#TestFailMode-enum">TestFailMode</a></b> { Abort, Continue }</td></tr>
</table>
<a name="functions"></a>
<h2>Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#addColumn">addColumn</a></b> ( const char * <i>name</i>, T * <i>dummy</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#benchmarkMetricName">benchmarkMetricName</a></b> ( QBenchmarkMetric <i>metric</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#benchmarkMetricUnit">benchmarkMetricUnit</a></b> ( QBenchmarkMetric <i>metric</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentDataTag">currentDataTag</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentTestFailed">currentTestFailed</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#currentTestFunction">currentTestFunction</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#ignoreMessage">ignoreMessage</a></b> ( QtMsgType <i>type</i>, const char * <i>message</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClick">keyClick</a></b> ( QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClick-2">keyClick</a></b> ( QWidget * <i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyClicks">keyClicks</a></b> ( QWidget * <i>widget</i>, const QString &amp; <i>sequence</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyEvent">keyEvent</a></b> ( KeyAction <i>action</i>, QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyEvent-2">keyEvent</a></b> ( KeyAction <i>action</i>, QWidget * <i>widget</i>, char <i>ascii</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyPress">keyPress</a></b> ( QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyPress-2">keyPress</a></b> ( QWidget * <i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyRelease">keyRelease</a></b> ( QWidget * <i>widget</i>, Qt::Key <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#keyRelease-2">keyRelease</a></b> ( QWidget * <i>widget</i>, char <i>key</i>, Qt::KeyboardModifiers <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseClick">mouseClick</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseDClick">mouseDClick</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseMove">mouseMove</a></b> ( QWidget * <i>widget</i>, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mousePress">mousePress</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#mouseRelease">mouseRelease</a></b> ( QWidget * <i>widget</i>, Qt::MouseButton <i>button</i>, Qt::KeyboardModifiers <i>modifier</i> = 0, QPoint <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTestData &amp; </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#newRow">newRow</a></b> ( const char * <i>dataTag</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qExec">qExec</a></b> ( QObject * <i>testObject</i>, int <i>argc</i> = 0, char ** <i>argv</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qExec-2">qExec</a></b> ( QObject * <i>testObject</i>, const QStringList &amp; <i>arguments</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qSleep">qSleep</a></b> ( int <i>ms</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWait">qWait</a></b> ( int <i>ms</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#qWaitForWindowShown">qWaitForWindowShown</a></b> ( QWidget * <i>window</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#setBenchmarkResult">setBenchmarkResult</a></b> ( qreal <i>result</i>, QBenchmarkMetric <i>metric</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toHexRepresentation">toHexRepresentation</a></b> ( const char * <i>ba</i>, int <i>length</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString">toString</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-4">toString</a></b> ( const QLatin1String &amp; <i>string</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-5">toString</a></b> ( const QString &amp; <i>string</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-6">toString</a></b> ( const QByteArray &amp; <i>ba</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-7">toString</a></b> ( const QTime &amp; <i>time</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-8">toString</a></b> ( const QDate &amp; <i>date</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-9">toString</a></b> ( const QDateTime &amp; <i>dateTime</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-10">toString</a></b> ( const QChar &amp; <i>character</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-11">toString</a></b> ( const QPoint &amp; <i>point</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-12">toString</a></b> ( const QSize &amp; <i>size</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-13">toString</a></b> ( const QRect &amp; <i>rectangle</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-14">toString</a></b> ( const QUrl &amp; <i>url</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-15">toString</a></b> ( const QPointF &amp; <i>point</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-16">toString</a></b> ( const QSizeF &amp; <i>size</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-17">toString</a></b> ( const QRectF &amp; <i>rectangle</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char * </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#toString-18">toString</a></b> ( const QVariant &amp; <i>variant</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QTouchEventSequence </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#touchEvent">touchEvent</a></b> ( QWidget * <i>widget</i> = 0, QTouchEvent::DeviceType <i>deviceType</i> = QTouchEvent::TouchScreen )</td></tr>
</table>
<a name="macros"></a>
<h2>Macros</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QBENCHMARK">QBENCHMARK</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QBENCHMARK_ONCE">QBENCHMARK_ONCE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QCOMPARE">QCOMPARE</a></b> (  <i>actual</i>,  <i>expected</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a></b> (  <i>dataIndex</i>,  <i>comment</i>,  <i>mode</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QFAIL">QFAIL</a></b> (  <i>message</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QFETCH">QFETCH</a></b> (  <i>type</i>,  <i>name</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QSKIP">QSKIP</a></b> (  <i>description</i>,  <i>mode</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST">QTEST</a></b> (  <i>actual</i>,  <i>testElement</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a></b> (  <i>TestClass</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a></b> (  <i>TestClass</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QTEST_NOOP_MAIN">QTEST_NOOP_MAIN</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QVERIFY2">QVERIFY2</a></b> (  <i>condition</i>,  <i>message</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QVERIFY">QVERIFY</a></b> (  <i>condition</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qtest.html#QWARN">QWARN</a></b> (  <i>message</i> )</td></tr>
</table>
<a name="details"></a>
<!-- $$$QTest-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QTest namespace contains all the functions and declarations that are related to the <a href="qtestlib-manual.html#qtestlib">QTestLib</a> tool.</p>
<p>Please refer to the <a href="qtestlib-manual.html">QTestLib Manual</a> documentation for information on how to write unit tests.</p>
</div>
<!-- @@@QTest -->
<div class="classes">
<h2>Classes</h2>
<h3> class <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a></h3><!-- $$$QTouchEventSequence-brief -->
<p>The QTouchEventSequence class is used to simulate a sequence of touch events. <a href="qtest-qtoucheventsequence.html#details">More...</a></p>
<!-- @@@QTouchEventSequence -->
</div>
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$AttributeIndex$$$AI_Undefined$$$AI_Name$$$AI_Result$$$AI_Tests$$$AI_Failures$$$AI_Errors$$$AI_Type$$$AI_Description$$$AI_PropertyValue$$$AI_QTestVersion$$$AI_QtVersion$$$AI_File$$$AI_Line$$$AI_Metric$$$AI_Tag$$$AI_Value$$$AI_Iterations -->
<h3 class="fn"><a name="AttributeIndex-enum"></a>enum QTest::AttributeIndex</h3>
<p>This enum numbers the different tests.</p>
<table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Undefined</tt></td><td class=" topAlign"><tt>-1</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Name</tt></td><td class=" topAlign"><tt>0</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Result</tt></td><td class=" topAlign"><tt>1</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Tests</tt></td><td class=" topAlign"><tt>2</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Failures</tt></td><td class=" topAlign"><tt>3</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Errors</tt></td><td class=" topAlign"><tt>4</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Type</tt></td><td class=" topAlign"><tt>5</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Description</tt></td><td class=" topAlign"><tt>6</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_PropertyValue</tt></td><td class=" topAlign"><tt>7</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_QTestVersion</tt></td><td class=" topAlign"><tt>8</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_QtVersion</tt></td><td class=" topAlign"><tt>9</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_File</tt></td><td class=" topAlign"><tt>10</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Line</tt></td><td class=" topAlign"><tt>11</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Metric</tt></td><td class=" topAlign"><tt>12</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Tag</tt></td><td class=" topAlign"><tt>13</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Value</tt></td><td class=" topAlign"><tt>14</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::AI_Iterations</tt></td><td class=" topAlign"><tt>15</tt></td></tr>
</table>
<!-- @@@AttributeIndex -->
<!-- $$$KeyAction$$$Press$$$Release$$$Click -->
<h3 class="fn"><a name="KeyAction-enum"></a>enum QTest::KeyAction</h3>
<p>This enum describes possible actions for key handling.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QTest::Press</tt></td><td class=" topAlign"><tt>0</tt></td><td  class="topAlign">The key is pressed.</td></tr>
<tr><td  class="topAlign"><tt>QTest::Release</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">The key is released.</td></tr>
<tr><td  class="topAlign"><tt>QTest::Click</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">The key is clicked (pressed and released).</td></tr>
</table>
<!-- @@@KeyAction -->
<!-- $$$LogElementType$$$LET_Undefined$$$LET_Property$$$LET_Properties$$$LET_Failure$$$LET_Error$$$LET_TestCase$$$LET_TestSuite$$$LET_Benchmark$$$LET_SystemError -->
<h3 class="fn"><a name="LogElementType-enum"></a>enum QTest::LogElementType</h3>
<p>The enum specifies the kinds of test log messages.</p>
<table class="valuelist"><tr><th class="tblConst">Constant</th><th class="tblVal">Value</th></tr>
<tr><td  class="topAlign"><tt>QTest::LET_Undefined</tt></td><td class=" topAlign"><tt>-1</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_Property</tt></td><td class=" topAlign"><tt>0</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_Properties</tt></td><td class=" topAlign"><tt>1</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_Failure</tt></td><td class=" topAlign"><tt>2</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_Error</tt></td><td class=" topAlign"><tt>3</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_TestCase</tt></td><td class=" topAlign"><tt>4</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_TestSuite</tt></td><td class=" topAlign"><tt>5</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_Benchmark</tt></td><td class=" topAlign"><tt>6</tt></td></tr>
<tr><td  class="topAlign"><tt>QTest::LET_SystemError</tt></td><td class=" topAlign"><tt>7</tt></td></tr>
</table>
<!-- @@@LogElementType -->
<!-- $$$MouseAction$$$MousePress$$$MouseRelease$$$MouseClick$$$MouseDClick$$$MouseMove -->
<h3 class="fn"><a name="MouseAction-enum"></a>enum QTest::MouseAction</h3>
<p>This enum describes possible actions for mouse handling.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QTest::MousePress</tt></td><td class=" topAlign"><tt>0</tt></td><td  class="topAlign">A mouse button is pressed.</td></tr>
<tr><td  class="topAlign"><tt>QTest::MouseRelease</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">A mouse button is released.</td></tr>
<tr><td  class="topAlign"><tt>QTest::MouseClick</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">A mouse button is clicked (pressed and released).</td></tr>
<tr><td  class="topAlign"><tt>QTest::MouseDClick</tt></td><td class=" topAlign"><tt>3</tt></td><td  class="topAlign">A mouse button is double clicked (pressed and released twice).</td></tr>
<tr><td  class="topAlign"><tt>QTest::MouseMove</tt></td><td class=" topAlign"><tt>4</tt></td><td  class="topAlign">The mouse pointer has moved.</td></tr>
</table>
<!-- @@@MouseAction -->
<!-- $$$QBenchmarkMetric$$$FramesPerSecond$$$BitsPerSecond$$$BytesPerSecond$$$WalltimeMilliseconds$$$CPUTicks$$$InstructionReads$$$Events -->
<h3 class="fn"><a name="QBenchmarkMetric-enum"></a>enum QTest::QBenchmarkMetric</h3>
<p>This enum lists all the things that can be benchmarked.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QTest::FramesPerSecond</tt></td><td class=" topAlign"><tt>0</tt></td><td  class="topAlign">Frames per second</td></tr>
<tr><td  class="topAlign"><tt>QTest::BitsPerSecond</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">Bits per second</td></tr>
<tr><td  class="topAlign"><tt>QTest::BytesPerSecond</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">Bytes per second</td></tr>
<tr><td  class="topAlign"><tt>QTest::WalltimeMilliseconds</tt></td><td class=" topAlign"><tt>3</tt></td><td  class="topAlign">Clock time in milliseconds</td></tr>
<tr><td  class="topAlign"><tt>QTest::CPUTicks</tt></td><td class=" topAlign"><tt>4</tt></td><td  class="topAlign">CPU time</td></tr>
<tr><td  class="topAlign"><tt>QTest::InstructionReads</tt></td><td class=" topAlign"><tt>5</tt></td><td  class="topAlign">Instruction reads</td></tr>
<tr><td  class="topAlign"><tt>QTest::Events</tt></td><td class=" topAlign"><tt>6</tt></td><td  class="topAlign">Event count</td></tr>
</table>
<p>This enum was introduced in Qt 4.7.</p>
<p>See also <a href="qtest.html#benchmarkMetricName">QTest::benchmarkMetricName</a>() and <a href="qtest.html#benchmarkMetricUnit">QTest::benchmarkMetricUnit</a>().</p>
<!-- @@@QBenchmarkMetric -->
<!-- $$$SkipMode$$$SkipSingle$$$SkipAll -->
<h3 class="fn"><a name="SkipMode-enum"></a>enum QTest::SkipMode</h3>
<p>This enum describes the modes for skipping tests during execution of the test data.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QTest::SkipSingle</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">Skips the current entry in the test table; continues execution of all the other entries in the table.</td></tr>
<tr><td  class="topAlign"><tt>QTest::SkipAll</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">Skips all the entries in the test table; the test won't be executed further.</td></tr>
</table>
<p>See also <a href="qtest.html#QSKIP">QSKIP</a>().</p>
<!-- @@@SkipMode -->
<!-- $$$TestFailMode$$$Abort$$$Continue -->
<h3 class="fn"><a name="TestFailMode-enum"></a>enum QTest::TestFailMode</h3>
<p>This enum describes the modes for handling an expected failure of the <a href="qtest.html#QVERIFY">QVERIFY</a>() or <a href="qtest.html#QCOMPARE">QCOMPARE</a>() macros.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QTest::Abort</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">Aborts the execution of the test. Use this mode when it doesn't make sense to execute the test any further after the expected failure.</td></tr>
<tr><td  class="topAlign"><tt>QTest::Continue</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">Continues execution of the test after the expected failure.</td></tr>
</table>
<p>See also <a href="qtest.html#QEXPECT_FAIL">QEXPECT_FAIL</a>().</p>
<!-- @@@TestFailMode -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$addColumn[overload1]$$$addColumnconstchar*T* -->
<h3 class="fn"><a name="addColumn"></a>void QTest::addColumn ( const char * <i>name</i>, T * <i>dummy</i> = 0 )</h3>
<p>Adds a column with type <tt>T</tt> to the current test data. <i>name</i> is the name of the column. <i>dummy</i> is a workaround for buggy compilers and can be ignored.</p>
<p>To populate the column with values, <a href="qtest.html#newRow">newRow</a>() can be used. Use <a href="qtest.html#QFETCH">QFETCH</a>() to fetch the data in the actual test.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> void myTestFunction_data() {
     QTest::addColumn&lt;int&gt;(&quot;intval&quot;);
     QTest::addColumn&lt;QString&gt;(&quot;str&quot;);
     QTest::addColumn&lt;double&gt;(&quot;dbl&quot;);

     QTest::newRow(&quot;row1&quot;) &lt;&lt; 1 &lt;&lt; &quot;hello&quot; &lt;&lt; 1.5;
 }</pre>
<p>To add custom types to the testdata, the type must be registered with <a href="qmetatype.html">QMetaType</a> via <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p>
<p><b>Note:</b> This macro can only be used in a test's data function that is invoked by the test framework.</p>
<p>See <a href="qtestlib-tutorial2.html">Data Driven Testing</a> for a more extensive example.</p>
<p>See also <a href="qtest.html#newRow">QTest::newRow</a>(), <a href="qtest.html#QFETCH">QFETCH</a>(), and <a href="qmetatype.html">QMetaType</a>.</p>
<!-- @@@addColumn -->
<!-- $$$benchmarkMetricName[overload1]$$$benchmarkMetricNameQBenchmarkMetric -->
<h3 class="fn"><a name="benchmarkMetricName"></a>const char * QTest::benchmarkMetricName ( <a href="qtest.html#QBenchmarkMetric-enum">QBenchmarkMetric</a> <i>metric</i> )</h3>
<p>Returns the enum value <i>metric</i> as a character string.</p>
<p>This function was introduced in Qt 4.7.</p>
<!-- @@@benchmarkMetricName -->
<!-- $$$benchmarkMetricUnit[overload1]$$$benchmarkMetricUnitQBenchmarkMetric -->
<h3 class="fn"><a name="benchmarkMetricUnit"></a>const char * QTest::benchmarkMetricUnit ( <a href="qtest.html#QBenchmarkMetric-enum">QBenchmarkMetric</a> <i>metric</i> )</h3>
<p>Retuns the units of measure for the specified <i>metric</i>.</p>
<p>This function was introduced in Qt 4.7.</p>
<!-- @@@benchmarkMetricUnit -->
<!-- $$$currentDataTag[overload1]$$$currentDataTag -->
<h3 class="fn"><a name="currentDataTag"></a>const char * QTest::currentDataTag ()</h3>
<p>Returns the name of the current test data. If the test doesn't have any assigned testdata, the function returns 0.</p>
<!-- @@@currentDataTag -->
<!-- $$$currentTestFailed[overload1]$$$currentTestFailed -->
<h3 class="fn"><a name="currentTestFailed"></a>bool QTest::currentTestFailed ()</h3>
<p>Returns true if the current test function failed, otherwise false.</p>
<!-- @@@currentTestFailed -->
<!-- $$$currentTestFunction[overload1]$$$currentTestFunction -->
<h3 class="fn"><a name="currentTestFunction"></a>const char * QTest::currentTestFunction ()</h3>
<p>Returns the name of the test function that is currently executed.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> void MyTestClass::cleanup()
 {
     if (qstrcmp(currentTestFunction(), &quot;myDatabaseTest&quot;) == 0) {
         <span class="comment">// clean up all database connections</span>
         closeAllDatabases();
     }
 }</pre>
<!-- @@@currentTestFunction -->
<!-- $$$ignoreMessage[overload1]$$$ignoreMessageQtMsgTypeconstchar* -->
<h3 class="fn"><a name="ignoreMessage"></a>void QTest::ignoreMessage ( <a href="qtglobal.html#QtMsgType-enum">QtMsgType</a> <i>type</i>, const char * <i>message</i> )</h3>
<p>Ignores messages created by <a href="qtglobal.html#qDebug">qDebug</a>() or <a href="qtglobal.html#qWarning">qWarning</a>(). If the <i>message</i> with the corresponding <i>type</i> is outputted, it will be removed from the test log. If the test finished and the <i>message</i> was not outputted, a test failure is appended to the test log.</p>
<p><b>Note:</b> Invoking this function will only ignore one message. If the message you want to ignore is outputted twice, you have to call ignoreMessage() twice, too.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QDir dir;

 QTest::ignoreMessage(QtWarningMsg, &quot;QDir::mkdir: Empty or null file name(s)&quot;);
 dir.mkdir(&quot;&quot;);</pre>
<p>The example above tests that <a href="qdir.html#mkdir">QDir::mkdir</a>() outputs the right warning when invoked with an invalid file name.</p>
<!-- @@@ignoreMessage -->
<!-- $$$keyClick[overload1]$$$keyClickQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyClick"></a>void QTest::keyClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>Examples:</p>
<pre class="highlightedCode brush: cpp"> QTest::keyClick(myWidget, Qt::Key_Escape);

 QTest::keyClick(myWidget, Qt::Key_Escape, Qt::ShiftModifier, 200);</pre>
<p>The first example above simulates clicking the <tt>escape</tt> key on <tt>myWidget</tt> without any keyboard modifiers and without delay. The second example simulates clicking <tt>shift-escape</tt> on <tt>myWidget</tt> with a following 200 ms delay of the test.</p>
<p>See also <a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>
<!-- @@@keyClick -->
<!-- $$$keyClick$$$keyClickQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyClick-2"></a>void QTest::keyClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Simulates clicking of <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QTest::keyClick(myWidget, 'a');</pre>
<p>The example above simulates clicking <tt>a</tt> on <tt>myWidget</tt> without any keyboard modifiers and without delay of the test.</p>
<p>See also <a href="qtest.html#keyClicks">QTest::keyClicks</a>().</p>
<!-- @@@keyClick -->
<!-- $$$keyClicks[overload1]$$$keyClicksQWidget*constQString&Qt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyClicks"></a>void QTest::keyClicks ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, const <a href="qstring.html">QString</a> &amp; <i>sequence</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>Simulates clicking a <i>sequence</i> of keys on a <i>widget</i>. Optionally, a keyboard <i>modifier</i> can be specified as well as a <i>delay</i> (in milliseconds) of the test before each key click.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QTest::keyClicks(myWidget, &quot;hello world&quot;);</pre>
<p>The example above simulates clicking the sequence of keys representing &quot;hello world&quot; on <tt>myWidget</tt> without any keyboard modifiers and without delay of the test.</p>
<p>See also <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<!-- @@@keyClicks -->
<!-- $$$keyEvent[overload1]$$$keyEventKeyActionQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyEvent"></a>void QTest::keyEvent ( <a href="qtest.html#KeyAction-enum">KeyAction</a> <i>action</i>, <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>Sends a Qt key event to <i>widget</i> with the given <i>key</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p>
<!-- @@@keyEvent -->
<!-- $$$keyEvent$$$keyEventKeyActionQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyEvent-2"></a>void QTest::keyEvent ( <a href="qtest.html#KeyAction-enum">KeyAction</a> <i>action</i>, <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>ascii</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Sends a Qt key event to <i>widget</i> with the given key <i>ascii</i> and an associated <i>action</i>. Optionally, a keyboard <i>modifier</i> can be specified, as well as a <i>delay</i> (in milliseconds) of the test before sending the event.</p>
<!-- @@@keyEvent -->
<!-- $$$keyPress[overload1]$$$keyPressQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyPress"></a>void QTest::keyPress ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p><b>Note:</b> At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p>
<p>See also <a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<!-- @@@keyPress -->
<!-- $$$keyPress$$$keyPressQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyPress-2"></a>void QTest::keyPress ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Simulates pressing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p><b>Note:</b> At some point you should release the key using <a href="qtest.html#keyRelease">keyRelease</a>().</p>
<p>See also <a href="qtest.html#keyRelease">QTest::keyRelease</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<!-- @@@keyPress -->
<!-- $$$keyRelease[overload1]$$$keyReleaseQWidget*Qt::KeyQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyRelease"></a>void QTest::keyRelease ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#Key-enum">Qt::Key</a> <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>See also <a href="qtest.html#keyPress">QTest::keyPress</a>() and <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<!-- @@@keyRelease -->
<!-- $$$keyRelease$$$keyReleaseQWidget*charQt::KeyboardModifiersint -->
<h3 class="fn"><a name="keyRelease-2"></a>void QTest::keyRelease ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, char <i>key</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = Qt::NoModifier, int <i>delay</i> = -1 )<tt> [static]</tt></h3>
<p>This is an overloaded function.</p>
<p>Simulates releasing a <i>key</i> with an optional <i>modifier</i> on a <i>widget</i>. If <i>delay</i> is larger than 0, the test will wait for <i>delay</i> milliseconds.</p>
<p>See also <a href="qtest.html#keyClick">QTest::keyClick</a>().</p>
<!-- @@@keyRelease -->
<!-- $$$mouseClick[overload1]$$$mouseClickQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn"><a name="mouseClick"></a>void QTest::mouseClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates clicking a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before pressing and before releasing the button.</p>
<p>See also <a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseRelease">QTest::mouseRelease</a>().</p>
<!-- @@@mouseClick -->
<!-- $$$mouseDClick[overload1]$$$mouseDClickQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn"><a name="mouseDClick"></a>void QTest::mouseDClick ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates double clicking a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the click is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before each press and release.</p>
<p>See also <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>
<!-- @@@mouseDClick -->
<!-- $$$mouseMove[overload1]$$$mouseMoveQWidget*QPointint -->
<h3 class="fn"><a name="mouseMove"></a>void QTest::mouseMove ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Moves the mouse pointer to a <i>widget</i>. If <i>pos</i> is not specified, the mouse pointer moves to the center of the widget. If a <i>delay</i> (in milliseconds) is given, the test will wait before moving the mouse pointer.</p>
<!-- @@@mouseMove -->
<!-- $$$mousePress[overload1]$$$mousePressQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn"><a name="mousePress"></a>void QTest::mousePress ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates pressing a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before the press.</p>
<p>See also <a href="qtest.html#mouseRelease">QTest::mouseRelease</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>
<!-- @@@mousePress -->
<!-- $$$mouseRelease[overload1]$$$mouseReleaseQWidget*Qt::MouseButtonQt::KeyboardModifiersQPointint -->
<h3 class="fn"><a name="mouseRelease"></a>void QTest::mouseRelease ( <a href="qwidget.html">QWidget</a> * <i>widget</i>, <a href="qt.html#MouseButton-enum">Qt::MouseButton</a> <i>button</i>, <a href="qt.html#KeyboardModifier-enum">Qt::KeyboardModifiers</a> <i>modifier</i> = 0, <a href="qpoint.html">QPoint</a> <i>pos</i> = QPoint(), int <i>delay</i> = -1 )</h3>
<p>Simulates releasing a mouse <i>button</i> with an optional <i>modifier</i> on a <i>widget</i>. The position of the release is defined by <i>pos</i>; the default position is the center of the widget. If <i>delay</i> is specified, the test will wait for the specified amount of milliseconds before releasing the button.</p>
<p>See also <a href="qtest.html#mousePress">QTest::mousePress</a>() and <a href="qtest.html#mouseClick">QTest::mouseClick</a>().</p>
<!-- @@@mouseRelease -->
<!-- $$$newRow[overload1]$$$newRowconstchar* -->
<h3 class="fn"><a name="newRow"></a>QTestData &amp; QTest::newRow ( const char * <i>dataTag</i> )</h3>
<p>Appends a new row to the current test data. <i>dataTag</i> is the name of the testdata that will appear in the test output. Returns a QTestData reference that can be used to stream in data.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> void myTestFunction_data()
 {
     QTest::addColumn&lt;QString&gt;(&quot;aString&quot;);
     QTest::newRow(&quot;just hello&quot;) &lt;&lt; QString(&quot;hello&quot;);
     QTest::newRow(&quot;a null string&quot;) &lt;&lt; QString();
 }</pre>
<p><b>Note:</b> This macro can only be used in a test's data function that is invoked by the test framework.</p>
<p>See <a href="qtestlib-tutorial2.html">Data Driven Testing</a> for a more extensive example.</p>
<p>See also <a href="qtest.html#addColumn">addColumn</a>() and <a href="qtest.html#QFETCH">QFETCH</a>().</p>
<!-- @@@newRow -->
<!-- $$$qExec[overload1]$$$qExecQObject*intchar** -->
<h3 class="fn"><a name="qExec"></a>int QTest::qExec ( <a href="qobject.html">QObject</a> * <i>testObject</i>, int <i>argc</i> = 0, char ** <i>argv</i> = 0 )</h3>
<p>Executes tests declared in <i>testObject</i>. In addition, the private slots <tt>initTestCase()</tt>, <tt>cleanupTestCase()</tt>, <tt>init()</tt> and <tt>cleanup()</tt> are executed if they exist. See <a href="qtestlib-manual.html#creating-a-test">Creating a Test</a> for more details.</p>
<p>Optionally, the command line arguments <i>argc</i> and <i>argv</i> can be provided. For a list of recognized arguments, read <a href="qtestlib-manual.html#qtestlib-command-line-arguments">QTestLib Command Line Arguments</a>.</p>
<p>For stand-alone tests, the convenience macro <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>() can be used to declare a main method that parses the command line arguments and executes the tests.</p>
<p>Returns 0 if all tests passed. Returns a value other than 0 if tests failed or in case of unhandled exceptions. The return value from this function is also the exit code of the test application when the <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>() macro is used.</p>
<p>The following example will run all tests in <tt>MyFirstTestObject</tt> and <tt>MySecondTestObject</tt>:</p>
<pre class="highlightedCode brush: cpp"> MyFirstTestObject test1;
 QTest::qExec(&amp;test1);

 MySecondTestObject test2;
 QTest::qExec(&amp;test2);</pre>
<p>Note: This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</p>
<p>If you have programatically created the arguments, as opposed to getting them from the arguments in <tt>main()</tt>, it is likely of interest to use QTest::qExec(<a href="qobject.html">QObject</a> *, const <a href="qstringlist.html">QStringList</a> &amp;) since it is Unicode safe.</p>
<p>See also <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>
<!-- @@@qExec -->
<!-- $$$qExec$$$qExecQObject*constQStringList& -->
<h3 class="fn"><a name="qExec-2"></a>int QTest::qExec ( <a href="qobject.html">QObject</a> * <i>testObject</i>, const <a href="qstringlist.html">QStringList</a> &amp; <i>arguments</i> )</h3>
<p>This is an overloaded function.</p>
<p>Behaves identically to qExec(<a href="qobject.html">QObject</a> *, int, char**) but takes a <a href="qstringlist.html">QStringList</a> of <i>arguments</i> instead of a <tt>char**</tt> list.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@qExec -->
<!-- $$$qSleep[overload1]$$$qSleepint -->
<h3 class="fn"><a name="qSleep"></a>void QTest::qSleep ( int <i>ms</i> )</h3>
<p>Sleeps for <i>ms</i> milliseconds, blocking execution of the test. qSleep() will not do any event processing and leave your test unresponsive. Network communication might time out while sleeping. Use <a href="qtest.html#qWait">qWait</a>() to do non-blocking sleeping.</p>
<p><i>ms</i> must be greater than 0.</p>
<p><b>Note:</b> The qSleep() function calls either <tt>nanosleep()</tt> on unix or <tt>Sleep()</tt> on windows, so the accuracy of time spent in qSleep() depends on the operating system.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QTest::qSleep(250);</pre>
<p>See also <a href="qtest.html#qWait">qWait</a>().</p>
<!-- @@@qSleep -->
<!-- $$$qWait[overload1]$$$qWaitint -->
<h3 class="fn"><a name="qWait"></a>void QTest::qWait ( int <i>ms</i> )<tt> [static]</tt></h3>
<p>Waits for <i>ms</i> milliseconds. While waiting, events will be processed and your test will stay responsive to user interface events or network communication.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> int i = 0;
 while (myNetworkServerNotResponding() &amp;&amp; i++ &lt; 50)
     QTest::qWait(250);</pre>
<p>The code above will wait until the network server is responding for a maximum of about 12.5 seconds.</p>
<p>See also <a href="qtest.html#qSleep">QTest::qSleep</a>().</p>
<!-- @@@qWait -->
<!-- $$$qWaitForWindowShown[overload1]$$$qWaitForWindowShownQWidget* -->
<h3 class="fn"><a name="qWaitForWindowShown"></a>bool QTest::qWaitForWindowShown ( <a href="qwidget.html">QWidget</a> * <i>window</i> )<tt> [static]</tt></h3>
<p>Waits until the <i>window</i> is shown in the screen. This is mainly useful for asynchronous systems like X11, where a window will be mapped to screen some time after being asked to show itself on the screen. Returns true.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QWidget widget;
 widget.show();
 QTest::qWaitForWindowShown(&amp;widget);</pre>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@qWaitForWindowShown -->
<!-- $$$setBenchmarkResult[overload1]$$$setBenchmarkResultqrealQBenchmarkMetric -->
<h3 class="fn"><a name="setBenchmarkResult"></a>void QTest::setBenchmarkResult ( <a href="qtglobal.html#qreal-typedef">qreal</a> <i>result</i>, <a href="qtest.html#QBenchmarkMetric-enum">QBenchmarkMetric</a> <i>metric</i> )</h3>
<p>Sets the benchmark result for this test function to <i>result</i>.</p>
<p>Use this function if you want to report benchmark results without using the QBENCHMARK macro. Use <i>metric</i> to specify how <a href="qtestlib-manual.html#qtestlib">QTestLib</a> should interpret the results.</p>
<p>The context for the result will be the test function name and any data tag from the _data function. This function can only be called once in each test function, subsequent calls will replace the earlier reported results.</p>
<p>Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.</p>
<p>This function was introduced in Qt 4.7.</p>
<!-- @@@setBenchmarkResult -->
<!-- $$$toHexRepresentation[overload1]$$$toHexRepresentationconstchar*int -->
<h3 class="fn"><a name="toHexRepresentation"></a>char * QTest::toHexRepresentation ( const char * <i>ba</i>, int <i>length</i> )</h3>
<p>Returns a pointer to a string that is the string <i>ba</i> represented as a space-separated sequence of hex characters. If the input is considered too long, it is truncated. A trucation is indicated in the returned string as an ellipsis at the end.</p>
<p><i>length</i> is the length of the string <i>ba</i>.</p>
<!-- @@@toHexRepresentation -->
<!-- $$$toString[overload1]$$$toStringconstT& -->
<h3 class="fn"><a name="toString"></a>char * QTest::toString ( const T &amp; <i>value</i> )</h3>
<p>Returns a textual representation of <i>value</i>. This function is used by <a href="qtest.html#QCOMPARE">QCOMPARE</a>() to output verbose information in case of a test failure.</p>
<p>You can add specializations of this function to your test to enable verbose output.</p>
<p><b>Note:</b> The caller of toString() must delete the returned data using <tt>delete[]</tt>. Your implementation should return a string created with <tt>new[]</tt> or <a href="qbytearray.html#qstrdup">qstrdup</a>().</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> namespace QTest {
     template&lt;&gt;
     char *toString(const MyPoint &amp;point)
     {
         QByteArray ba = &quot;MyPoint(&quot;;
         ba += QByteArray::number(point.x()) + &quot;, &quot; + QByteArray::number(point.y());
         ba += &quot;)&quot;;
         return qstrdup(ba.data());
     }
 }</pre>
<p>The example above defines a toString() specialization for a class called <tt>MyPoint</tt>. Whenever a comparison of two instances of <tt>MyPoint</tt> fails, <a href="qtest.html#QCOMPARE">QCOMPARE</a>() will call this function to output the contents of <tt>MyPoint</tt> to the test log.</p>
<p>See also <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQLatin1String& -->
<h3 class="fn"><a name="toString-4"></a>char * QTest::toString ( const <a href="qlatin1string.html">QLatin1String</a> &amp; <i>string</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>string</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQString& -->
<h3 class="fn"><a name="toString-5"></a>char * QTest::toString ( const <a href="qstring.html">QString</a> &amp; <i>string</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>string</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQByteArray& -->
<h3 class="fn"><a name="toString-6"></a>char * QTest::toString ( const <a href="qbytearray.html">QByteArray</a> &amp; <i>ba</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the byte array <i>ba</i>.</p>
<p>See also <a href="qtest.html#toHexRepresentation">QTest::toHexRepresentation</a>().</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQTime& -->
<h3 class="fn"><a name="toString-7"></a>char * QTest::toString ( const <a href="qtime.html">QTime</a> &amp; <i>time</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>time</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQDate& -->
<h3 class="fn"><a name="toString-8"></a>char * QTest::toString ( const <a href="qdate.html">QDate</a> &amp; <i>date</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>date</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQDateTime& -->
<h3 class="fn"><a name="toString-9"></a>char * QTest::toString ( const <a href="qdatetime.html">QDateTime</a> &amp; <i>dateTime</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the date and time specified by <i>dateTime</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQChar& -->
<h3 class="fn"><a name="toString-10"></a>char * QTest::toString ( const <a href="qchar.html">QChar</a> &amp; <i>character</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>character</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQPoint& -->
<h3 class="fn"><a name="toString-11"></a>char * QTest::toString ( const <a href="qpoint.html">QPoint</a> &amp; <i>point</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>point</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQSize& -->
<h3 class="fn"><a name="toString-12"></a>char * QTest::toString ( const <a href="qsize.html">QSize</a> &amp; <i>size</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>size</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQRect& -->
<h3 class="fn"><a name="toString-13"></a>char * QTest::toString ( const <a href="qrect.html">QRect</a> &amp; <i>rectangle</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>rectangle</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQUrl& -->
<h3 class="fn"><a name="toString-14"></a>char * QTest::toString ( const <a href="qurl.html">QUrl</a> &amp; <i>url</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>url</i>.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQPointF& -->
<h3 class="fn"><a name="toString-15"></a>char * QTest::toString ( const <a href="qpointf.html">QPointF</a> &amp; <i>point</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>point</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQSizeF& -->
<h3 class="fn"><a name="toString-16"></a>char * QTest::toString ( const <a href="qsizef.html">QSizeF</a> &amp; <i>size</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>size</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQRectF& -->
<h3 class="fn"><a name="toString-17"></a>char * QTest::toString ( const <a href="qrectf.html">QRectF</a> &amp; <i>rectangle</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>rectangle</i>.</p>
<!-- @@@toString -->
<!-- $$$toString$$$toStringconstQVariant& -->
<h3 class="fn"><a name="toString-18"></a>char * QTest::toString ( const <a href="qvariant.html">QVariant</a> &amp; <i>variant</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a textual representation of the given <i>variant</i>.</p>
<!-- @@@toString -->
<!-- $$$touchEvent[overload1]$$$touchEventQWidget*QTouchEvent::DeviceType -->
<h3 class="fn"><a name="touchEvent"></a><a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> QTest::touchEvent ( <a href="qwidget.html">QWidget</a> * <i>widget</i> = 0, <a href="qtouchevent.html#DeviceType-enum">QTouchEvent::DeviceType</a> <i>deviceType</i> = QTouchEvent::TouchScreen )</h3>
<p>Creates and returns a <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> for the device <i>deviceType</i> to simulate events for <i>widget</i>.</p>
<p>When adding touch events to the sequence, <i>widget</i> will also be used to translate the position provided to screen coordinates, unless another widget is provided in the respective calls to press(), move() etc.</p>
<p>The touch events are committed to the event system when the destructor of the <a href="qtest-qtoucheventsequence.html">QTouchEventSequence</a> is called (ie when the object returned runs out of scope).</p>
<!-- @@@touchEvent -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QBENCHMARK[overload1]$$$QBENCHMARK -->
<h3 class="fn"><a name="QBENCHMARK"></a>QBENCHMARK</h3>
<p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p>
<p>For example:</p>
<pre class="highlightedCode brush: cpp"> void TestBenchmark::simple()
 {
     QString str1 = QLatin1String(&quot;This is a test string&quot;);
     QString str2 = QLatin1String(&quot;This is a test string&quot;);

     QCOMPARE(str1.localeAwareCompare(str2), 0);

     QBENCHMARK {
         str1.localeAwareCompare(str2);
     }
 }</pre>
<p>See also <a href="qtestlib-manual.html#creating-a-benchmark">Creating a Benchmark</a> and <a href="qtestlib-tutorial5.html">Writing a Benchmark</a>.</p>
<!-- @@@QBENCHMARK -->
<!-- $$$QBENCHMARK_ONCE[overload1]$$$QBENCHMARK_ONCE -->
<h3 class="fn"><a name="QBENCHMARK_ONCE"></a>QBENCHMARK_ONCE</h3>
<p>The QBENCHMARK_ONCE macro is for measuring performance of a code block by running it once.</p>
<p>This macro is used to measure the performance of code within a test. The code to be benchmarked is contained within a code block following this macro.</p>
<p>Unlike QBENCHMARK, the contents of the contained code block is only run once. The elapsed time will be reported as &quot;0&quot; if it's to short to be measured by the selected backend. (Use)</p>
<p>This function was introduced in Qt 4.6.</p>
<p>See also <a href="qtestlib-manual.html#creating-a-benchmark">Creating a Benchmark</a> and <a href="qtestlib-tutorial5.html">Writing a Benchmark</a>.</p>
<!-- @@@QBENCHMARK_ONCE -->
<!-- $$$QCOMPARE[overload1]$$$QCOMPARE -->
<h3 class="fn"><a name="QCOMPARE"></a>QCOMPARE (  <i>actual</i>,  <i>expected</i> )</h3>
<p>The QCOMPARE macro compares an <i>actual</i> value to an <i>expected</i> value using the equals operator. If <i>actual</i> and <i>expected</i> are identical, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</p>
<p>In the case of comparing floats and doubles, <a href="qtglobal.html#qFuzzyCompare">qFuzzyCompare</a>() is used for comparing. This means that comparing to 0 will likely fail. One solution to this is to compare to 1, and add 1 to the produced output.</p>
<p>QCOMPARE tries to output the contents of the values if the comparison fails, so it is visible from the test log why the comparison failed.</p>
<p>QCOMPARE is very strict on the data types. Both <i>actual</i> and <i>expected</i> have to be of the same type, otherwise the test won't compile. This prohibits unspecified behavior from being introduced; that is behavior that usually occurs when the compiler implicitly casts the argument.</p>
<p>If you use QCOMPARE() to compare two <a href="qstringlist.html">QStringList</a> objects, it will start comparing the objects from the end of the lists.</p>
<p>For your own classes, you can use <a href="qtest.html#toString">QTest::toString</a>() to format values for outputting into the test log.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QCOMPARE(QString(&quot;hello&quot;).toUpper(), QString(&quot;HELLO&quot;));</pre>
<p>See also <a href="qtest.html#QVERIFY">QVERIFY</a>() and <a href="qtest.html#toString">QTest::toString</a>().</p>
<!-- @@@QCOMPARE -->
<!-- $$$QEXPECT_FAIL[overload1]$$$QEXPECT_FAIL -->
<h3 class="fn"><a name="QEXPECT_FAIL"></a>QEXPECT_FAIL (  <i>dataIndex</i>,  <i>comment</i>,  <i>mode</i> )</h3>
<p>The QEXPECT_FAIL() macro marks the next <a href="qtest.html#QCOMPARE">QCOMPARE</a>() or <a href="qtest.html#QVERIFY">QVERIFY</a>() as an expected failure. Instead of adding a failure to the test log, an expected failure will be reported.</p>
<p>If a <a href="qtest.html#QVERIFY">QVERIFY</a>() or <a href="qtest.html#QCOMPARE">QCOMPARE</a>() is marked as an expected failure, but passes instead, an unexpected pass (XPASS) is written to the test log.</p>
<p>The parameter <i>dataIndex</i> describes for which entry in the test data the failure is expected. Pass an empty string (<tt>&quot;&quot;</tt>) if the failure is expected for all entries or if no test data exists.</p>
<p><i>comment</i> will be appended to the test log for the expected failure.</p>
<p><i>mode</i> is a <a href="qtest.html#TestFailMode-enum">QTest::TestFailMode</a> and sets whether the test should continue to execute or not.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example 1:</p>
<pre class="highlightedCode brush: cpp"> QEXPECT_FAIL(&quot;&quot;, &quot;Will fix in the next release&quot;, Continue);
 QCOMPARE(i, 42);
 QCOMPARE(j, 43);</pre>
<p>In the example above, an expected fail will be written into the test output if the variable <tt>i</tt> is not 42. If the variable <tt>i</tt> is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second <a href="qtest.html#QCOMPARE">QCOMPARE</a>() statement in the example.</p>
<p>Example 2:</p>
<pre class="highlightedCode brush: cpp"> QEXPECT_FAIL(&quot;data27&quot;, &quot;Oh my, this is soooo broken&quot;, Abort);
 QCOMPARE(i, 42);</pre>
<p>The above testfunction will not continue executing for the test data entry <tt>data27</tt>.</p>
<p>See also <a href="qtest.html#TestFailMode-enum">QTest::TestFailMode</a>, <a href="qtest.html#QVERIFY">QVERIFY</a>(), and <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<!-- @@@QEXPECT_FAIL -->
<!-- $$$QFAIL[overload1]$$$QFAIL -->
<h3 class="fn"><a name="QFAIL"></a>QFAIL (  <i>message</i> )</h3>
<p>This macro can be used to force a test failure. The test stops executing and the failure <i>message</i> is appended to the test log.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> if (sizeof(int) != 4)
     QFAIL(&quot;This test has not been ported to this platform yet.&quot;);</pre>
<!-- @@@QFAIL -->
<!-- $$$QFETCH[overload1]$$$QFETCH -->
<h3 class="fn"><a name="QFETCH"></a>QFETCH (  <i>type</i>,  <i>name</i> )</h3>
<p>The fetch macro creates a local variable named <i>name</i> with the type <i>type</i> on the stack. <i>name</i> has to match the element name from the test's data. If no such element exists, the test will assert.</p>
<p>Assuming a test has the following data:</p>
<pre class="highlightedCode brush: cpp"> void TestQString::toInt_data()
 {
     QTest::addColumn&lt;QString&gt;(&quot;aString&quot;);
     QTest::addColumn&lt;int&gt;(&quot;expected&quot;);

     QTest::newRow(&quot;positive value&quot;) &lt;&lt; &quot;42&quot; &lt;&lt; 42;
     QTest::newRow(&quot;negative value&quot;) &lt;&lt; &quot;-42&quot; &lt;&lt; -42;
     QTest::newRow(&quot;zero&quot;) &lt;&lt; &quot;0&quot; &lt;&lt; 0;
 }</pre>
<p>The test data has two elements, a <a href="qstring.html">QString</a> called <tt>aString</tt> and an integer called <tt>expected</tt>. To fetch these values in the actual test:</p>
<pre class="highlightedCode brush: cpp"> void TestQString::toInt()
 {
      QFETCH(QString, aString);
      QFETCH(int, expected);

      QCOMPARE(aString.toInt(), expected);
 }</pre>
<p><tt>aString</tt> and <tt>expected</tt> are variables on the stack that are initialized with the current test data.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework. The test function must have a _data function.</p>
<!-- @@@QFETCH -->
<!-- $$$QSKIP[overload1]$$$QSKIP -->
<h3 class="fn"><a name="QSKIP"></a>QSKIP (  <i>description</i>,  <i>mode</i> )</h3>
<p>The QSKIP() macro stops execution of the test without adding a failure to the test log. You can use it to skip tests that wouldn't make sense in the current configuration. The text <i>description</i> is appended to the test log and should contain an explanation why the test couldn't be executed. <i>mode</i> is a <a href="qtest.html#SkipMode-enum">QTest::SkipMode</a> and describes whether to proceed with the rest of the test data or not.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> if (!QSqlDatabase::drivers().contains(&quot;SQLITE&quot;))
     QSKIP(&quot;This test requires the SQLITE database driver&quot;, SkipAll);</pre>
<p>See also <a href="qtest.html#SkipMode-enum">QTest::SkipMode</a>.</p>
<!-- @@@QSKIP -->
<!-- $$$QTEST[overload1]$$$QTEST -->
<h3 class="fn"><a name="QTEST"></a>QTEST (  <i>actual</i>,  <i>testElement</i> )</h3>
<p>QTEST() is a convenience macro for <a href="qtest.html#QCOMPARE">QCOMPARE</a>() that compares the value <i>actual</i> with the element <i>testElement</i> from the test's data. If there is no such element, the test asserts.</p>
<p>Apart from that, QTEST() behaves exactly as <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<p>Instead of writing:</p>
<pre class="highlightedCode brush: cpp"> QFETCH(QString, myString);
 QCOMPARE(QString(&quot;hello&quot;).toUpper(), myString);</pre>
<p>you can write:</p>
<pre class="highlightedCode brush: cpp"> QTEST(QString(&quot;hello&quot;).toUpper(), &quot;myString&quot;);</pre>
<p>See also <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<!-- @@@QTEST -->
<!-- $$$QTEST_APPLESS_MAIN[overload1]$$$QTEST_APPLESS_MAIN -->
<h3 class="fn"><a name="QTEST_APPLESS_MAIN"></a>QTEST_APPLESS_MAIN (  <i>TestClass</i> )</h3>
<p>Implements a main() function that executes all tests in <i>TestClass</i>.</p>
<p>Behaves like <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>(), but doesn't instantiate a <a href="qapplication.html">QApplication</a> object. Use this macro for really simple stand-alone non-GUI tests.</p>
<p>See also <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>
<!-- @@@QTEST_APPLESS_MAIN -->
<!-- $$$QTEST_MAIN[overload1]$$$QTEST_MAIN -->
<h3 class="fn"><a name="QTEST_MAIN"></a>QTEST_MAIN (  <i>TestClass</i> )</h3>
<p>Implements a main() function that instantiates a <a href="qapplication.html">QApplication</a> object and the <i>TestClass</i>, and executes all tests in the order they were defined. Use this macro to build stand-alone executables.</p>
<p><b>Note:</b> On platforms that have keypad navigation enabled by default (eg: Symbian), this macro will forcfully disable it to simplify the usage of key events when writing autotests. If you wish to write a test case that uses keypad navigation, you should enable it either in the <tt>initTestCase()</tt> or <tt>init()</tt> functions of your test case.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> class TestQString: public QObject { ... };
 QTEST_MAIN(TestQString)</pre>
<p>See also <a href="qtest.html#QTEST_APPLESS_MAIN">QTEST_APPLESS_MAIN</a>(), <a href="qtest.html#qExec">QTest::qExec</a>(), and <a href="qapplication.html#setNavigationMode">QApplication::setNavigationMode</a>().</p>
<!-- @@@QTEST_MAIN -->
<!-- $$$QTEST_NOOP_MAIN[overload1]$$$QTEST_NOOP_MAIN -->
<h3 class="fn"><a name="QTEST_NOOP_MAIN"></a>QTEST_NOOP_MAIN ()</h3>
<p>Implements a main() function with a test class that does absolutely nothing. Use this macro to create a test that produces valid test output but just doesn't execute any test, for example in conditional compilations:</p>
<pre class="highlightedCode brush: cpp"> #ifdef Q_WS_X11
     QTEST_MAIN(MyX11Test)
 #else
     <span class="comment">// do nothing on non-X11 platforms</span>
     QTEST_NOOP_MAIN
 #endif</pre>
<p>See also <a href="qtest.html#QTEST_MAIN">QTEST_MAIN</a>().</p>
<!-- @@@QTEST_NOOP_MAIN -->
<!-- $$$QVERIFY2[overload1]$$$QVERIFY2 -->
<h3 class="fn"><a name="QVERIFY2"></a>QVERIFY2 (  <i>condition</i>,  <i>message</i> )</h3>
<p>The QVERIFY2() macro behaves exactly like <a href="qtest.html#QVERIFY">QVERIFY</a>(), except that it outputs a verbose <i>message</i> when <i>condition</i> is false. The <i>message</i> is a plain C string.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QVERIFY2(1 + 1 == 2, &quot;A breach in basic arithmetic occured.&quot;);</pre>
<p>See also <a href="qtest.html#QVERIFY">QVERIFY</a>() and <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<!-- @@@QVERIFY2 -->
<!-- $$$QVERIFY[overload1]$$$QVERIFY -->
<h3 class="fn"><a name="QVERIFY"></a>QVERIFY (  <i>condition</i> )</h3>
<p>The QVERIFY() macro checks whether the <i>condition</i> is true or not. If it is true, execution continues. If not, a failure is recorded in the test log and the test won't be executed further.</p>
<p><b>Note:</b> This macro can only be used in a test function that is invoked by the test framework.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QVERIFY(1 + 1 == 2);</pre>
<p>See also <a href="qtest.html#QCOMPARE">QCOMPARE</a>().</p>
<!-- @@@QVERIFY -->
<!-- $$$QWARN[overload1]$$$QWARN -->
<h3 class="fn"><a name="QWARN"></a>QWARN (  <i>message</i> )</h3>
<p>Appends <i>message</i> as a warning to the test log. This macro can be used anywhere in your tests.</p>
<p><b>Note:</b> This function is <a href="threads-reentrancy.html#thread-safe">thread-safe</a>.</p>
<!-- @@@QWARN -->
</div>
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
