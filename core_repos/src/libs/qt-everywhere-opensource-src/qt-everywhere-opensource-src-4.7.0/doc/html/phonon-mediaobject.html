<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- phonon-api.qdoc -->
  <title>Qt 4.7: MediaObject Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="phonon.html">Phonon</a></li>
              <li>MediaObject</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">MediaObject Class Reference</h1>
<span class="small-subtitle">(Phonon::MediaObject)<br/></span>
<!-- $$$MediaObject-brief -->
<p>The MediaObject class provides an interface for media playback. <a href="#details">More...</a></p>
<!-- @@@MediaObject -->
<pre class="highlightedCode brush: cpp"> #include &lt;Phonon/MediaObject&gt;</pre><p>Inherits <a href="qobject.html">QObject</a> and <a href="phonon-medianode.html">MediaNode</a>.</p>
<p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="phonon-mediaobject-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="properties"></a>
<h2>Properties</h2>
<ul>
<li class="fn"><b><a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a></b> : qint32</li>
<li class="fn"><b><a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a></b> : qint32</li>
<li class="fn"><b><a href="phonon-mediaobject.html#transitionTime-prop">transitionTime</a></b> : qint32</li>
</ul>
<ul>
<li class="fn">1 property inherited from <a href="qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#dtor.MediaObject">~MediaObject</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#clearQueue">clearQueue</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> MediaSource </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#currentSource">currentSource</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#currentTime">currentTime</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#enqueue">enqueue</a></b> ( const MediaSource &amp; <i>source</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#enqueue-2">enqueue</a></b> ( const QList&lt;MediaSource&gt; &amp; <i>sources</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#enqueue-3">enqueue</a></b> ( const QList&lt;QUrl&gt; &amp; <i>urls</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#errorString">errorString</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ErrorType </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#errorType">errorType</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#hasVideo">hasVideo</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#isSeekable">isSeekable</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaData">metaData</a></b> ( const QString &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaData-2">metaData</a></b> ( Phonon::MetaData <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMultiMap&lt;QString, QString&gt; </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaData-3">metaData</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;MediaSource&gt; </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#queue">queue</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#remainingTime">remainingTime</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a></b> ( const MediaSource &amp; <i>source</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#prefinishMark-prop">setPrefinishMark</a></b> ( qint32 <i>msecToEnd</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#setQueue">setQueue</a></b> ( const QList&lt;MediaSource&gt; &amp; <i>sources</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#setQueue-2">setQueue</a></b> ( const QList&lt;QUrl&gt; &amp; <i>urls</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#transitionTime-prop">setTransitionTime</a></b> ( qint32 <i>msec</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> State </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#state">state</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#totalTime">totalTime</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint32 </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#transitionTime-prop">transitionTime</a></b> () const</td></tr>
</table>
<ul>
<li class="fn">29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
<li class="fn">3 public functions inherited from <a href="phonon-medianode.html#public-functions">Phonon::MediaNode</a></li>
</ul>
<a name="public-slots"></a>
<h2>Public Slots</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#clear">clear</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#pause">pause</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#play">play</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#seek">seek</a></b> ( qint64 <i>time</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#tickInterval-prop">setTickInterval</a></b> ( qint32 <i>newTickInterval</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#stop">stop</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#bufferStatus">bufferStatus</a></b> ( int <i>percentFilled</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged</a></b> ( const Phonon::MediaSource &amp; <i>newSource</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#finished">finished</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a></b> ( bool <i>hasVideo</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a></b> ( qint32 <i>msecToEnd</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#seekableChanged">seekableChanged</a></b> ( bool <i>isSeekable</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#stateChanged">stateChanged</a></b> ( Phonon::State <i>newstate</i>, Phonon::State <i>oldstate</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#tick">tick</a></b> ( qint64 <i>time</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="phonon-mediaobject.html#totalTimeChanged">totalTimeChanged</a></b> ( qint64 <i>newTotalTime</i> )</td></tr>
</table>
<ul>
<li class="fn">1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">5 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li class="fn">7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$MediaObject-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The MediaObject class provides an interface for media playback.</p>
<p>The media object manages a <a href="phonon-mediasource.html">MediaSource</a>, which supplies the media object with multimedia content, e.g&#x2e;, from a file. A playback in Phonon is always started by calling the <a href="phonon-mediaobject.html#play">play()</a> function.</p>
<p>The state of play (play, pause, stop, seek) is controlled by the media object, and you can also query the current <a href="phonon-mediaobject.html#state">state()</a>. It keeps track of the playback position in the media stream, and emits the <a href="phonon-mediaobject.html#tick">tick()</a> signal when the current position in the stream changes.</p>
<p>Notice that most functions of this class are asynchronous, so you cannot rely on that a state is entered after a function call before you receive the <a href="phonon-mediaobject.html#stateChanged">stateChanged()</a> signal. The description of the <a href="phonon.html#State-enum">State</a> enum gives a description of the different states.</p>
<p>Before <a href="phonon-mediaobject.html#play">play</a>() is called, the media object should be connected to <a href="phonon-overview.html#sinks">output nodes</a>, which outputs the media to the underlying hardware. The output nodes required are dependent on the contents of the multimedia file that is played back. Phonon has currently two output nodes: the <a href="phonon-audiooutput.html">AudioOutput</a> for audio content and <a href="phonon-videowidget.html">VideoWidget</a> for video content. If a <a href="phonon-mediasource.html">MediaSource</a> contains both audio and video, both nodes need to be connected to the media object.</p>
<pre class="highlightedCode brush: cpp">     Phonon::MediaObject *mediaObject = new Phonon::MediaObject(this);

     Phonon::VideoWidget *videoWidget = new Phonon::VideoWidget(this);
     Phonon::createPath(mediaObject, videoWidget);

     Phonon::AudioOutput *audioOutput =
         new Phonon::AudioOutput(Phonon::VideoCategory, this);
     Phonon::createPath(mediaObject, audioOutput);
     mediaObject-&gt;play();</pre>
<p>The media object can queue sources for playback. When it has finished to play one source, it will start playing the next in the queue; the new source is then removed from the queue. The queue can be altered at any time.</p>
<pre class="highlightedCode brush: cpp"> media-&gt;setCurrentSource(&quot;:/sounds/startsound.ogg&quot;);
 media-&gt;enqueue(&quot;/home/username/music/song.mp3&quot;);
 media-&gt;enqueue(&quot;:/sounds/endsound.ogg&quot;);</pre>
<p>You can also make use of the <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish()</a> signal, which is guaranteed to be emitted in time for altering the queue.</p>
<pre class="highlightedCode brush: cpp">   media-&gt;setCurrentSource(&quot;:/sounds/startsound.ogg&quot;);
   connect(media, SIGNAL(aboutToFinish()), SLOT(enqueueNextSource()));
 }

 void enqueueNextSource()
 {
   media-&gt;enqueue(&quot;/home/username/music/song.mp3&quot;);
 }</pre>
<p>When playback is finishing, i.e&#x2e;, when a media source has been played to the end and the queue is empty, several signals are emitted. First, the media object will emit <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>() - shortly before the playback has finished - and then <a href="phonon-mediaobject.html#finished">finished</a>(). The <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal will also be emitted with <a href="phonon.html#State-enum">PausedState</a>, which is the state the media object takes when the playback is finished. If you wish to enter another state, you can connect a slot to <a href="phonon-mediaobject.html#finished">finished</a>() and set a new state there.</p>
<p>The media object resolves the meta information, such as title, artist, and album. The meta data is not resolved immediately after a new source is provided, but will be resolved before the object leaves the <a href="phonon.html#State-enum">LoadingState</a>. The data is queried by string keys - which should follow the Ogg Vorbis specification <a href="http://xiph.org/vorbis/doc/v-comment.html">http://xiph.org/vorbis/doc/v-comment.html</a> - or by using the <a href="phonon.html#MetaData-enum">MetaData</a> enum. The data available will depend on the type and content of the individual media files. <a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a>() will be emitted when the media object has resolved new meta data.</p>
<p>Errors encountered during playback and loading of media sources are reported by emitting a state changed signal with <a href="phonon.html#State-enum">ErrorState</a>. The severity of the error can be queried by the <a href="phonon.html#ErrorType-enum">ErrorType</a>. With a <a href="phonon.html#ErrorType-enum">NormalError</a>, it might be possible to continue the playback, for instance, if only audio playback fails for a media source which also has video. A <a href="phonon.html#ErrorType-enum">FatalError</a> indicates that Phonon cannot continue playback of the current source, but it is possible to try with a different one. A user readable error message is given by <a href="phonon-mediaobject.html#errorString">errorString</a>().</p>
</div>
<p>See also <a href="symbian-platform-security-requirements.html">Symbian Platform Security Requirements</a>, <a href="phonon-mediasource.html">Phonon::MediaSource</a>, <a href="phonon-audiooutput.html">Phonon::AudioOutput</a>, <a href="phonon-videowidget.html">VideoWidget</a>, <a href="phonon-qmusicplayer.html">Music Player Example</a>, Phonon Overview, <a href="phonon-videoplayer.html">Phonon::VideoPlayer</a>, <a href="phonon.html#createPlayer">Phonon::createPlayer</a>(), and <a href="phonon-module.html">Phonon Module</a>.</p>
<!-- @@@MediaObject -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$prefinishMark-prop$$$prefinishMark$$$setPrefinishMarkqint32 -->
<h3 class="fn"><a name="prefinishMark-prop"></a>prefinishMark : <a href="qtglobal.html#qint32-typedef">qint32</a></h3>
<p>This property holds the time when the prefinishMarkReached signal is emitted before playback ends.</p>
<p>This property specifies the time in milliseconds the <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>() signal is emitted before the playback finishes. A value of <tt>0</tt> disables the signal. The signal is only emitted for the last source in the <a href="phonon-mediaobject.html#queue">media queue</a>.</p>
<p>Defaults to <tt>0</tt> (disabled).</p>
<p><b>Warning:</b> For some media data the total time cannot be determined accurately, therefore the accuracy of the prefinishMarkReached signal can be bad sometimes. Still, it is better to use this method than to look at <a href="phonon-mediaobject.html#totalTime">totalTime</a>() and <a href="phonon-mediaobject.html#currentTime">currentTime</a>() to emulate the behavior because the backend might have more information available than your application does through <a href="phonon-mediaobject.html#totalTime">totalTime</a>() and <a href="phonon-mediaobject.html#currentTime">currentTime</a>().</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qint32 </td><td class="memItemRight bottomAlign"><b>prefinishMark</b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b>setPrefinishMark</b> ( qint32 <i>msecToEnd</i> )</td></tr>
</table>
<p>See also <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>().</p>
<!-- @@@prefinishMark -->
<!-- $$$tickInterval-prop$$$tickInterval$$$setTickIntervalqint32 -->
<h3 class="fn"><a name="tickInterval-prop"></a>tickInterval : <a href="qtglobal.html#qint32-typedef">qint32</a></h3>
<p>This property holds the time interval in milliseconds between two ticks.</p>
<p>The <a href="phonon-mediaobject.html#tick">tick</a>() signal is emitted continuously during playback. The tick interval is the time that elapses between the emission of two tick signals. If you set the interval to <tt>0</tt> the tick signal gets disabled.</p>
<p>The <a href="phonon-mediaobject.html#tick">tick</a>() signal can, for instance, be used to update widgets that show the current position in the playback of a media source.</p>
<p>Defaults to <tt>0</tt> (disabled).</p>
<p><b>Warning:</b> The back-end is free to choose a different tick interval close to what you asked for. This means that the following code <tt>may</tt> fail:</p>
<pre class="highlightedCode brush: cpp"> int x = 200;
 media-&gt;setTickInterval(x);
 Q_ASSERT(x == producer-&gt;tickInterval());</pre>
<p>On the other hand the following is guaranteed:</p>
<pre class="highlightedCode brush: cpp"> int x = 200;
 media-&gt;setTickInterval(x);
 Q_ASSERT(x &gt;= producer-&gt;tickInterval() &amp;&amp;
          x &lt;= 2producer-&gt;tickInterval());</pre>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qint32 </td><td class="memItemRight bottomAlign"><b>tickInterval</b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b>setTickInterval</b> ( qint32 <i>newTickInterval</i> )</td></tr>
</table>
<p>See also <a href="phonon-mediaobject.html#tick">tick</a>().</p>
<!-- @@@tickInterval -->
<!-- $$$transitionTime-prop$$$transitionTime$$$setTransitionTimeqint32 -->
<h3 class="fn"><a name="transitionTime-prop"></a>transitionTime : <a href="qtglobal.html#qint32-typedef">qint32</a></h3>
<p>This property defines the time between playback of two media sources in the media queue.</p>
<p>A positive transition time defines a gap of silence between queued media sources.</p>
<p>A transition time of 0 ms requests gapless playback (i.e&#x2e;, the next source in the media queue starts immediately after the playback of the current source finishes).</p>
<p>A negative transition time defines a crossfade between the queued media sources.</p>
<p>Defaults to 0 (gapless playback).</p>
<p><b>Warning:</b> This feature might not work reliably with every backend.</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qint32 </td><td class="memItemRight bottomAlign"><b>transitionTime</b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b>setTransitionTime</b> ( qint32 <i>msec</i> )</td></tr>
</table>
<!-- @@@transitionTime -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$~MediaObject[overload1]$$$~MediaObject -->
<h3 class="fn"><a name="dtor.MediaObject"></a>MediaObject::~MediaObject ()</h3>
<p>Destroys the <a href="phonon-mediaobject.html">MediaObject</a>.</p>
<!-- @@@~MediaObject -->
<!-- $$$aboutToFinish[overload1]$$$aboutToFinish -->
<h3 class="fn"><a name="aboutToFinish"></a>void MediaObject::aboutToFinish ()<tt> [signal]</tt></h3>
<p>Emitted before the playback of the whole queue ends. When this signal is emitted you still have time to <a href="phonon-mediaobject.html#enqueue">enqueue</a>() a new <a href="phonon-mediasource.html">MediaSource</a>, so that playback continues.</p>
<p>If you need a signal to be emitted at a specific time before playback is finished, you should use the <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>() signal instead.</p>
<p>See also <a href="phonon-mediaobject.html#enqueue">enqueue</a>(), <a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a>, and <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>().</p>
<!-- @@@aboutToFinish -->
<!-- $$$bufferStatus[overload1]$$$bufferStatusint -->
<h3 class="fn"><a name="bufferStatus"></a>void MediaObject::bufferStatus ( int <i>percentFilled</i> )<tt> [signal]</tt></h3>
<p>Provides information about the status of the buffer.</p>
<p>When a <a href="phonon-mediaobject.html">MediaObject</a> is in the <a href="phonon.html#State-enum">BufferingState</a>, it will send this signal regularly. <i>percentFilled</i> is a number between 0 and 100 telling you how much the buffer is filled.</p>
<p>You can use this signal to show a progress bar to the user when in <a href="phonon.html#State-enum">BufferingState</a>:</p>
<pre class="highlightedCode brush: cpp"> progressBar-&gt;setRange(0, 100); // this is the default
 connect(media, SIGNAL(bufferStatus(int)), progressBar, SLOT(setValue(int)));</pre>
<p>Note that the <a href="phonon.html#State-enum">BufferingState</a> is commonly used when waiting for data over a network connection, but this might not be true for all backends.</p>
<!-- @@@bufferStatus -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn"><a name="clear"></a>void MediaObject::clear ()<tt> [slot]</tt></h3>
<p>Stops and removes all playing and enqueued media sources.</p>
<p>See also <a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a>().</p>
<!-- @@@clear -->
<!-- $$$clearQueue[overload1]$$$clearQueue -->
<h3 class="fn"><a name="clearQueue"></a>void MediaObject::clearQueue ()</h3>
<p>Clears the queue of media sources.</p>
<p>See also <a href="phonon-mediaobject.html#queue">queue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@clearQueue -->
<!-- $$$currentSource[overload1]$$$currentSource -->
<h3 class="fn"><a name="currentSource"></a><a href="phonon-mediasource.html">MediaSource</a> MediaObject::currentSource () const</h3>
<p>Returns the current media source, i.e&#x2e;, the media source that is being played back. The current source is either set with <a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a>() or taken from the media <a href="phonon-mediaobject.html#queue">queue</a>() when a media source has finished playing.</p>
<p>See also <a href="phonon-mediaobject.html#setCurrentSource">setCurrentSource</a>().</p>
<!-- @@@currentSource -->
<!-- $$$currentSourceChanged[overload1]$$$currentSourceChangedconstPhonon::MediaSource& -->
<h3 class="fn"><a name="currentSourceChanged"></a>void MediaObject::currentSourceChanged ( const <a href="phonon-mediasource.html">Phonon::MediaSource</a> &amp; <i>newSource</i> )<tt> [signal]</tt></h3>
<p>Emitted when the <a href="phonon-mediaobject.html">MediaObject</a> fetches a new <a href="phonon-mediasource.html">MediaSource</a> from the <a href="phonon-mediaobject.html#queue">queue</a>() and before it enters the <a href="phonon.html#State-enum">LoadingState</a> for the new source. The media object will take a new source from the <a href="phonon-mediaobject.html#queue">queue</a>() when it has finished the playback of the <a href="phonon-mediaobject.html#currentSource">current source</a>.</p>
<p><i>newSource</i> is the source that starts to play at the time the signal is emitted.</p>
<!-- @@@currentSourceChanged -->
<!-- $$$currentTime[overload1]$$$currentTime -->
<h3 class="fn"><a name="currentTime"></a><a href="qtglobal.html#qint64-typedef">qint64</a> MediaObject::currentTime () const</h3>
<p>Returns the current time (in milliseconds), i.e&#x2e;, position in the media stream, of the file currently being played.</p>
<p>See also <a href="phonon-mediaobject.html#tick">tick</a>(), <a href="phonon-mediaobject.html#totalTime">totalTime</a>(), and <a href="phonon-mediaobject.html#remainingTime">remainingTime</a>().</p>
<!-- @@@currentTime -->
<!-- $$$enqueue[overload1]$$$enqueueconstMediaSource& -->
<h3 class="fn"><a name="enqueue"></a>void MediaObject::enqueue ( const <a href="phonon-mediasource.html">MediaSource</a> &amp; <i>source</i> )</h3>
<p>Appends <i>source</i> to the queue.</p>
<p>You can use this function to provide the next source after the <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>() signal has been emitted.</p>
<p>See also <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>(), <a href="phonon-mediaobject.html#setQueue">setQueue</a>(), and <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>().</p>
<!-- @@@enqueue -->
<!-- $$$enqueue$$$enqueueconstQList<MediaSource>& -->
<h3 class="fn"><a name="enqueue-2"></a>void MediaObject::enqueue ( const <a href="qlist.html">QList</a>&lt;<a href="phonon-mediasource.html">MediaSource</a>&gt; &amp; <i>sources</i> )</h3>
<p>Appends multiple <i>sources</i> to the queue.</p>
<p>See also <a href="phonon-mediaobject.html#setQueue">setQueue</a>() and <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>().</p>
<!-- @@@enqueue -->
<!-- $$$enqueue$$$enqueueconstQList<QUrl>& -->
<h3 class="fn"><a name="enqueue-3"></a>void MediaObject::enqueue ( const <a href="qlist.html">QList</a>&lt;<a href="qurl.html">QUrl</a>&gt; &amp; <i>urls</i> )</h3>
<p>Appends the URLs in <i>urls</i> to the media source queue.</p>
<p>The function will create <a href="phonon-mediasource.html">MediaSource</a>s from the <a href="qurl.html">QUrl</a>s, and append these to the queue.</p>
<p>See also <a href="phonon-mediaobject.html#setQueue">setQueue</a>() and <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>().</p>
<!-- @@@enqueue -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn"><a name="errorString"></a><a href="qstring.html">QString</a> MediaObject::errorString () const</h3>
<p>Returns a human-readable description of the last error that occurred. The strings given may vary between backends.</p>
<p>The error description can be used to give a message to the user - and the developer - when the <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal is emitted with <a href="phonon.html#State-enum">ErrorState</a>.</p>
<a name="qt-backends"></a>
<h4>Qt Backends</h4>
<p>On Windows, Qt fetches its error messages from the DirectShow backend. This usually includes an error number, which can be looked up in the DirectShow documentation: <a href="http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dx81_c/directx_cpp/htm/errorandsuccesscodes.asp">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dx81_c/directx_cpp/htm/errorandsuccesscodes.asp</a>.</p>
<p>On Linux and Mac, the error strings are not fetched directly from the backend, but are created in the backend.</p>
<p>See also <a href="phonon.html#State-enum">Phonon::ErrorState</a> and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@errorString -->
<!-- $$$errorType[overload1]$$$errorType -->
<h3 class="fn"><a name="errorType"></a><a href="phonon.html#ErrorType-enum">ErrorType</a> MediaObject::errorType () const</h3>
<p>Tells your program what to do about the last error that occurred. Use this function after receiving a <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal with <a href="phonon.html#State-enum">ErrorState</a>.</p>
<p>See also <a href="phonon.html#ErrorType-enum">Phonon::ErrorType</a>, <a href="phonon.html#State-enum">Phonon::ErrorState</a>, and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@errorType -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn"><a name="finished"></a>void MediaObject::finished ()<tt> [signal]</tt></h3>
<p>Emitted when the object has finished playback. It is not emitted if you call <a href="phonon-mediaobject.html#stop">stop</a>(), <a href="phonon-mediaobject.html#pause">pause</a>() or load(). It is emitted only when the current media source has finished playing and the media <a href="phonon-mediaobject.html#queue">queue</a>() is empty, or when a <a href="phonon.html#ErrorType-enum">fatal error</a> occurs.</p>
<p><b>Warning:</b> This signal is not emitted when the current source has finished and there's another source in the queue. It is only emitted when the queue is empty.</p>
<p>See also <a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged</a>(), <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>(), and <a href="phonon-mediaobject.html#prefinishMarkReached">prefinishMarkReached</a>().</p>
<!-- @@@finished -->
<!-- $$$hasVideo[overload1]$$$hasVideo -->
<h3 class="fn"><a name="hasVideo"></a>bool MediaObject::hasVideo () const</h3>
<p>Check whether the current media source includes a video stream.</p>
<p><b>Warning:</b> This information is not resolved immediately after a media object gets a new source. Listen to the <a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a>() signal instead.</p>
<pre class="highlightedCode brush: cpp">   connect(media, SIGNAL(hasVideoChanged(bool)), hasVideoChanged(bool));
   media-&gt;setCurrentSource(&quot;somevideo.avi&quot;);
   media-&gt;hasVideo(); // returns false;
 }

 void hasVideoChanged(bool b)
 {
   // b == true
   media-&gt;hasVideo(); // returns true;
 }</pre>
<p>Returns <tt>true</tt> if the media contains video data; otherwise, returns <tt>false</tt>.</p>
<p>See also <a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a>().</p>
<!-- @@@hasVideo -->
<!-- $$$hasVideoChanged[overload1]$$$hasVideoChangedbool -->
<h3 class="fn"><a name="hasVideoChanged"></a>void MediaObject::hasVideoChanged ( bool <i>hasVideo</i> )<tt> [signal]</tt></h3>
<p>Emitted whenever the return value of <a href="phonon-mediaobject.html#hasVideo">hasVideo</a>() changes, i.e&#x2e;, the media source being played back contains video.</p>
<p>Normally you'll check <a href="phonon-mediaobject.html#hasVideo">hasVideo</a>() first and then let this signal tell you whether video is available now or not. That way you don't have to poll <a href="phonon-mediaobject.html#hasVideo">hasVideo</a>().</p>
<p><i>hasVideo</i> is true when the stream contains video and adding a <a href="phonon-videowidget.html">VideoWidget</a> will show a video, and false if there is no video data in the stream and adding a <a href="phonon-videowidget.html">VideoWidget</a> will show an empty (black) <a href="phonon-videowidget.html">VideoWidget</a>.</p>
<!-- @@@hasVideoChanged -->
<!-- $$$isSeekable[overload1]$$$isSeekable -->
<h3 class="fn"><a name="isSeekable"></a>bool MediaObject::isSeekable () const</h3>
<p>Check whether it is possible to seek, i.e&#x2e;, change the playback position in the media stream.</p>
<p><b>Warning:</b> This information is not solved immediately after the media object gets a new media source. The <a href="phonon-mediaobject.html#hasVideoChanged">hasVideoChanged</a>() signal is emitted after this information is available.</p>
<pre class="highlightedCode brush: cpp">   connect(media, SIGNAL(hasVideoChanged(bool)), hasVideoChanged(bool));
   media-&gt;setCurrentSource(&quot;somevideo.avi&quot;);
   media-&gt;hasVideo(); // returns false;
 }

 void hasVideoChanged(bool b)
 {
   // b == true
   media-&gt;hasVideo(); // returns true;
 }</pre>
<p>Returns <tt>true</tt> if the current media may be seeked; otherwise, returns <tt>false</tt>.</p>
<p>See also <a href="phonon-mediaobject.html#seekableChanged">seekableChanged</a>().</p>
<!-- @@@isSeekable -->
<!-- $$$metaData[overload1]$$$metaDataconstQString& -->
<h3 class="fn"><a name="metaData"></a><a href="qstringlist.html">QStringList</a> MediaObject::metaData ( const <a href="qstring.html">QString</a> &amp; <i>key</i> ) const</h3>
<p>Returns the strings associated with the given <i>key</i>.</p>
<p>Backends should use the keys specified in the Ogg Vorbis documentation: <a href="http://xiph.org/vorbis/doc/v-comment.html">http://xiph.org/vorbis/doc/v-comment.html</a></p>
<p>Therefore the following should work with every backend:</p>
<p>Note that meta data is not resolved before the <tt>metaDataChanged()</tt> signal is emitted.</p>
<p>A typical usage looks like this:</p>
<pre class="highlightedCode brush: cpp"> setMetaArtist(media-&gt;metaData(&quot;ARTIST&quot;));
 setMetaAlbum(media-&gt;metaData(&quot;ALBUM&quot;));
 setMetaTitle(media-&gt;metaData(&quot;TITLE&quot;));
 setMetaDate(media-&gt;metaData(&quot;DATE&quot;));
 setMetaGenre(media-&gt;metaData(&quot;GENRE&quot;));
 setMetaTrack(media-&gt;metaData(&quot;TRACKNUMBER&quot;));
 setMetaComment(media-&gt;metaData(&quot;DESCRIPTION&quot;));</pre>
<!-- @@@metaData -->
<!-- $$$metaData$$$metaDataPhonon::MetaData -->
<h3 class="fn"><a name="metaData-2"></a><a href="qstringlist.html">QStringList</a> MediaObject::metaData ( <a href="phonon.html#MetaData-enum">Phonon::MetaData</a> <i>key</i> ) const</h3>
<p>Returns the strings associated with the given <i>key</i>.</p>
<p>Same as above except that the keys are defined in the <a href="phonon.html#MetaData-enum">Phonon::MetaData</a> enum.</p>
<p>See also <a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a>().</p>
<!-- @@@metaData -->
<!-- $$$metaData$$$metaData -->
<h3 class="fn"><a name="metaData-3"></a><a href="qmultimap.html">QMultiMap</a>&lt;<a href="qstring.html">QString</a>, <a href="qstring.html">QString</a>&gt; MediaObject::metaData () const</h3>
<p>Returns all meta data in a multi map.</p>
<p>See also <a href="phonon-mediaobject.html#metaDataChanged">metaDataChanged</a>().</p>
<!-- @@@metaData -->
<!-- $$$metaDataChanged[overload1]$$$metaDataChanged -->
<h3 class="fn"><a name="metaDataChanged"></a>void MediaObject::metaDataChanged ()<tt> [signal]</tt></h3>
<p>This signal is emitted when the media object has resolved new meta data. This will happen before the media object leaves the <a href="phonon.html#State-enum">LoadingState</a> after a new source has been set.</p>
<p>This signal is not emitted when the media object removes the current data, i.e&#x2e;, when a new source is set or an error has occurred. If you need to know this, you can listen for the <a href="phonon.html#State-enum">ErrorState</a>, and connect to the <a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged()</a> signal.</p>
<p>You can get the new meta data with the metaData methods.</p>
<p>See also <a href="phonon-mediaobject.html#metaData">metaData</a>(), <a href="phonon-mediaobject.html#currentSourceChanged">currentSourceChanged</a>(), <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>(), and <a href="phonon.html#State-enum">Phonon::State</a>.</p>
<!-- @@@metaDataChanged -->
<!-- $$$pause[overload1]$$$pause -->
<h3 class="fn"><a name="pause"></a>void MediaObject::pause ()<tt> [slot]</tt></h3>
<p>Requests playback to pause, and the media object to enter the <a href="phonon.html#State-enum">PausedState</a>. If it was paused already, nothing changes.</p>
<p>This function is asynchronous and the media might not be paused immediately.</p>
<p>See also <a href="phonon-mediaobject.html#play">play</a>(), <a href="phonon-mediaobject.html#stop">stop</a>(), and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@pause -->
<!-- $$$play[overload1]$$$play -->
<h3 class="fn"><a name="play"></a>void MediaObject::play ()<tt> [slot]</tt></h3>
<p>Requests playback of the media data to start.</p>
<p>Playback starts when the <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>() signal is emitted with <a href="phonon.html#State-enum">PlayingState</a>.</p>
<p>If the media object is already in a <a href="phonon.html#State-enum">PlayingState</a>, nothing happens.</p>
<p>See also <a href="phonon-mediaobject.html#stop">stop</a>(), <a href="phonon-mediaobject.html#pause">pause</a>(), and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@play -->
<!-- $$$prefinishMarkReached[overload1]$$$prefinishMarkReachedqint32 -->
<h3 class="fn"><a name="prefinishMarkReached"></a>void MediaObject::prefinishMarkReached ( <a href="qtglobal.html#qint32-typedef">qint32</a> <i>msecToEnd</i> )<tt> [signal]</tt></h3>
<p>Emitted when there are only <i>msecToEnd</i> milliseconds left of playback.</p>
<p><b>Warning:</b> This signal is not emitted when there is another source in the queue. It is only emitted when the queue is empty.</p>
<p>See also <a href="phonon-mediaobject.html#prefinishMark-prop">setPrefinishMark</a>(), <a href="phonon-mediaobject.html#prefinishMark-prop">prefinishMark</a>(), <a href="phonon-mediaobject.html#aboutToFinish">aboutToFinish</a>(), and <a href="phonon-mediaobject.html#finished">finished</a>().</p>
<!-- @@@prefinishMarkReached -->
<!-- $$$queue[overload1]$$$queue -->
<h3 class="fn"><a name="queue"></a><a href="qlist.html">QList</a>&lt;<a href="phonon-mediasource.html">MediaSource</a>&gt; MediaObject::queue () const</h3>
<p>Returns the queued media sources.</p>
<p>This does list does not include the current source, returned by <a href="phonon-mediaobject.html#currentSource">currentSource</a>().</p>
<p>See also <a href="phonon-mediaobject.html#setQueue">setQueue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@queue -->
<!-- $$$remainingTime[overload1]$$$remainingTime -->
<h3 class="fn"><a name="remainingTime"></a><a href="qtglobal.html#qint64-typedef">qint64</a> MediaObject::remainingTime () const</h3>
<p>Get the remaining time (in milliseconds) of the file currently being played.</p>
<p>Returns the remaining time in milliseconds.</p>
<p>See also <a href="phonon-mediaobject.html#totalTime">totalTime</a>(), <a href="phonon-mediaobject.html#currentTime">currentTime</a>(), and <a href="phonon-mediaobject.html#totalTimeChanged">totalTimeChanged</a>().</p>
<!-- @@@remainingTime -->
<!-- $$$seek[overload1]$$$seekqint64 -->
<h3 class="fn"><a name="seek"></a>void MediaObject::seek ( <a href="qtglobal.html#qint64-typedef">qint64</a> <i>time</i> )<tt> [slot]</tt></h3>
<p>Requests a seek to the <i>time</i> indicated, specified in milliseconds.</p>
<p>You can only seek if <a href="phonon-mediaobject.html#state">state</a>() is <a href="phonon.html#State-enum">PlayingState</a>, <a href="phonon.html#State-enum">BufferingState</a> or <a href="phonon.html#State-enum">PausedState</a>.</p>
<p>The call is asynchronous, so currentTime can still be the old value right after this method was called. If all you need is a slider that shows the current position and allows the user to seek, use the class <a href="phonon-seekslider.html">SeekSlider</a>.</p>
<p>If the current source of the media object is not seekable, calls to this functions do nothing.</p>
<p>See also <a href="phonon-seekslider.html">SeekSlider</a> and <a href="phonon-mediaobject.html#tick">tick</a>().</p>
<!-- @@@seek -->
<!-- $$$seekableChanged[overload1]$$$seekableChangedbool -->
<h3 class="fn"><a name="seekableChanged"></a>void MediaObject::seekableChanged ( bool <i>isSeekable</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when the media object's ability to seek in the media stream changes. <i>isSeekable</i> is true if it is possible to <a href="phonon-mediaobject.html#seek">seek</a>(); otherwise, it is false.</p>
<p>Change in the ability to seek in the stream usually happens when the current source changes or when an error occurs.</p>
<p>Normally you'll check <a href="phonon-mediaobject.html#isSeekable">isSeekable</a>() after setting a new media source, and then let this signal tell you when seeking is possible. That way you don't have to poll <a href="phonon-mediaobject.html#isSeekable">isSeekable</a>().</p>
<!-- @@@seekableChanged -->
<!-- $$$setCurrentSource[overload1]$$$setCurrentSourceconstMediaSource& -->
<h3 class="fn"><a name="setCurrentSource"></a>void MediaObject::setCurrentSource ( const <a href="phonon-mediasource.html">MediaSource</a> &amp; <i>source</i> )</h3>
<p>Set the media source the <a href="phonon-mediaobject.html">MediaObject</a> should use.</p>
<p>After the media object receives a new source, it will enter the <a href="phonon.html#State-enum">LoadingState</a>. When it is ready to play, it enters the <a href="phonon.html#State-enum">StoppedState</a> unless another state has been requested, e.g&#x2e;, by calling <a href="phonon-mediaobject.html#play">play</a>().</p>
<p><i>source</i> is the <a href="phonon-mediasource.html">MediaSource</a> object to the media data. You can just as well use a <a href="qurl.html">QUrl</a> or <a href="qstring.html">QString</a> (for a local file) here.</p>
<p>We show an example:</p>
<pre class="highlightedCode brush: cpp"> QUrl url(&quot;http://www.example.com/music.ogg&quot;);
 media-&gt;setCurrentSource(url);</pre>
<p>See also <a href="phonon-mediaobject.html#currentSource">currentSource</a>() and <a href="phonon-mediasource.html">MediaSource</a>.</p>
<!-- @@@setCurrentSource -->
<!-- $$$setQueue[overload1]$$$setQueueconstQList<MediaSource>& -->
<h3 class="fn"><a name="setQueue"></a>void MediaObject::setQueue ( const <a href="qlist.html">QList</a>&lt;<a href="phonon-mediasource.html">MediaSource</a>&gt; &amp; <i>sources</i> )</h3>
<p>Set the <i>sources</i> to play when the current source has finished.</p>
<p>This function will overwrite the current queue.</p>
<p>See also <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@setQueue -->
<!-- $$$setQueue$$$setQueueconstQList<QUrl>& -->
<h3 class="fn"><a name="setQueue-2"></a>void MediaObject::setQueue ( const <a href="qlist.html">QList</a>&lt;<a href="qurl.html">QUrl</a>&gt; &amp; <i>urls</i> )</h3>
<p>Set the <i>urls</i> to play when the current media has finished.</p>
<p>This function overwrites the current queue.</p>
<p>See also <a href="phonon-mediaobject.html#clearQueue">clearQueue</a>() and <a href="phonon-mediaobject.html#enqueue">enqueue</a>().</p>
<!-- @@@setQueue -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn"><a name="state"></a><a href="phonon.html#State-enum">State</a> MediaObject::state () const</h3>
<p>Returns the current <a href="phonon.html#State-enum">Phonon::State</a> of the object.</p>
<p>See also <a href="phonon.html#State-enum">Phonon::State</a> and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedPhonon::StatePhonon::State -->
<h3 class="fn"><a name="stateChanged"></a>void MediaObject::stateChanged ( <a href="phonon.html#State-enum">Phonon::State</a> <i>newstate</i>, <a href="phonon.html#State-enum">Phonon::State</a> <i>oldstate</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when the state of the <a href="phonon-mediaobject.html">MediaObject</a> has changed. The <i>oldstate</i> and <i>newstate</i> parameters indicate the previous state and current state of the media object.</p>
<p>If you are only interested in the new state of the media object, you can connect this signal to a slot that accepts only one State argument.</p>
<!-- @@@stateChanged -->
<!-- $$$stop[overload1]$$$stop -->
<h3 class="fn"><a name="stop"></a>void MediaObject::stop ()<tt> [slot]</tt></h3>
<p>Requests playback to stop, and the media object to enter the <a href="phonon.html#State-enum">StoppedState</a>. If it was stopped before nothing changes.</p>
<p>This function is asynchronous and the media might not be stopped immediately.</p>
<p>See also <a href="phonon-mediaobject.html#play">play</a>(), <a href="phonon-mediaobject.html#pause">pause</a>(), and <a href="phonon-mediaobject.html#stateChanged">stateChanged</a>().</p>
<!-- @@@stop -->
<!-- $$$tick[overload1]$$$tickqint64 -->
<h3 class="fn"><a name="tick"></a>void MediaObject::tick ( <a href="qtglobal.html#qint64-typedef">qint64</a> <i>time</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted in intervals defined by the <a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a> property. The current position of the media object in the stream is given by the <i>time</i> parameter. The <i>time</i> is specified in milliseconds.</p>
<p>See also <a href="phonon-mediaobject.html#tickInterval-prop">tickInterval</a>.</p>
<!-- @@@tick -->
<!-- $$$totalTime[overload1]$$$totalTime -->
<h3 class="fn"><a name="totalTime"></a><a href="qtglobal.html#qint64-typedef">qint64</a> MediaObject::totalTime () const</h3>
<p>Get the total time (in milliseconds) of the file currently being played.</p>
<p>Returns the total time in milliseconds.</p>
<p><b>Warning:</b> The total time is not defined before the media object enters the <a href="phonon.html#State-enum">LoadingState</a>.</p>
<p>See also <a href="phonon-mediaobject.html#totalTimeChanged">totalTimeChanged</a>().</p>
<!-- @@@totalTime -->
<!-- $$$totalTimeChanged[overload1]$$$totalTimeChangedqint64 -->
<h3 class="fn"><a name="totalTimeChanged"></a>void MediaObject::totalTimeChanged ( <a href="qtglobal.html#qint64-typedef">qint64</a> <i>newTotalTime</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted as soon as the total time of the media file is known or has changed. For most non-local media data the total time of the media can only be known after some time. At that time the totalTime function can not return useful information. You have to wait for this signal to know the real total time.</p>
<p><i>newTotalTime</i> is the length of the media file in milliseconds.</p>
<p>See also <a href="phonon-mediaobject.html#totalTime">totalTime</a>().</p>
<!-- @@@totalTimeChanged -->
</div>
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
