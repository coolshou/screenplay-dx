<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- extending.qdoc -->
  <title>Qt 4.7: Extending QML in C++</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li>Extending QML in C++</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#adding-types">Adding Types</a></li>
<li class="level1"><a href="#object-and-list-property-types">Object and List Property Types</a></li>
<li class="level1"><a href="#inheritance-and-coercion">Inheritance and Coercion</a></li>
<li class="level1"><a href="#default-property">Default Property</a></li>
<li class="level1"><a href="#grouped-properties">Grouped Properties</a></li>
<li class="level1"><a href="#attached-properties">Attached Properties</a></li>
<li class="level1"><a href="#memory-management-and-qvariant-types">Memory Management and QVariant types</a></li>
<li class="level1"><a href="#signal-support">Signal Support</a></li>
<li class="level1"><a href="#property-value-sources">Property Value Sources</a></li>
<li class="level1"><a href="#property-binding">Property Binding</a></li>
<li class="level1"><a href="#extension-objects">Extension Objects</a></li>
<li class="level1"><a href="#optimization">Optimization</a></li>
</ul>
</div>
<h1 class="title">Extending QML in C++</h1>
<span class="subtitle"></span>
<!-- $$$qml-extending.html-description -->
<div class="descr"> <a name="details"></a>
<p>The QML syntax declaratively describes how to construct an in-memory object tree. In Qt, QML is mainly used to describe a visual scene graph, but it is not conceptually limited to this: the QML format is an abstract description of any object tree. All the QML element types included in Qt are implemented using the C++ extension mechanisms describe on this page. Programmers can use these APIs to add new types that interact with the existing Qt types, or to repurpose QML for their own independent use.</p>
<a name="adding-types"></a>
<h2>Adding Types</h2>
<a name="adding-types"></a><pre class="highlightedCode brush: cpp"> import People 1.0

 Person {
     name: &quot;Bob Jones&quot;
     shoeSize: 12
 }</pre>
<p>The QML snippet shown above instantiates one <tt>Person</tt> instance and sets the <tt>name</tt> and <tt>shoeSize</tt> properties on it. Everything in QML ultimately comes down to either instantiating an object instance, or assigning a property a value.</p>
<p>QML relies heavily on Qt's meta object system and can only instantiate classes that derive from <a href="qobject.html">QObject</a>. For visual element types, this will usually mean a subclass of <a href="qdeclarativeitem.html">QDeclarativeItem</a>; for models used with the view elements, a subclass of <a href="qabstractitemmodel.html">QAbstractItemModel</a>; and for abitrary objects with properties, a direct subclass of <a href="qobject.html">QObject</a>.</p>
<p>The QML engine has no intrinsic knowledge of any class types. Instead the programmer must register the C++ types with their corresponding QML names.</p>
<p>Custom C++ types are registered using a template function:</p>
<blockquote><pre class="highlightedCode brush: cpp"> template&lt;typename T&gt;
 int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)</pre>
<p>Calling <a href="qdeclarativeengine.html#qmlRegisterType">qmlRegisterType</a>() registers the C++ type <i>T</i> with the QML system, and makes it available in QML under the name <i>qmlName</i> in library <i>uri</i> version <i>versionMajor.versionMinor</i>. The <i>qmlName</i> can be the same as the C++ type name.</p>
<p>Type <i>T</i> must be a concrete type that inherits <a href="qobject.html">QObject</a> and has a default constructor.</p>
</blockquote>
<p>Types can be registered by libraries, application code, or by plugins (see <a href="qdeclarativeextensionplugin.html">QDeclarativeExtensionPlugin</a>).</p>
<p>Once registered, all <a href="properties.html#qt-s-property-system">properties</a> of the supported types are available in QML. QML has intrinsic support for properties of these types:</p>
<ul>
<li>bool</li>
<li>unsigned int, int</li>
<li>float, double, qreal</li>
<li><a href="qstring.html">QString</a></li>
<li><a href="qurl.html">QUrl</a></li>
<li><a href="qcolor.html">QColor</a></li>
<li><a href="qdate.html">QDate</a>, <a href="qtime.html">QTime</a>, <a href="qdatetime.html">QDateTime</a></li>
<li><a href="qpoint.html">QPoint</a>, <a href="qpointf.html">QPointF</a></li>
<li><a href="qsize.html">QSize</a>, <a href="qsizef.html">QSizeF</a></li>
<li><a href="qrect.html">QRect</a>, <a href="qrectf.html">QRectF</a></li>
<li><a href="qvariant.html">QVariant</a></li>
</ul>
<p>When a property of a supported type is added to a C++ class, in a QML element based on the C++ class, a <i>value-changed</i> signal handler will be available. See <a href="#signal-support">Signal Support</a> below.</p>
<p>QML is typesafe. Attempting to assign an invalid value to a property will generate an error. For example, assuming the <i>name</i> property of the <tt>Person</tt> element had a type of <a href="qstring.html">QString</a>, this would cause an error:</p>
<pre class="highlightedCode brush: cpp"> Person {
     <span class="comment">// Will NOT work</span>
     name: 12
 }</pre>
<p><a href="declarative-cppextensions-referenceexamples-adding.html">Extending QML - Adding Types Example</a> shows the complete code used to create the <tt>Person</tt> type.</p>
<a name="object-and-list-property-types"></a>
<h2>Object and List Property Types</h2>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     host: Person {
         name: &quot;Bob Jones&quot;
         shoeSize: 12
     }
     guests: [
         Person { name: &quot;Leo Hodges&quot; },
         Person { name: &quot;Jack Smith&quot; },
         Person { name: &quot;Anne Brown&quot; }
     ]
 }</pre>
<p>The QML snippet shown above assigns a <tt>Person</tt> object to the <tt>BirthdayParty</tt>'s <tt>host</tt> property, and assigns three <tt>Person</tt> objects to the guests property.</p>
<p>QML can set properties of types that are more complex than basic intrinsics like integers and strings. Properties can also be object pointers, Qt interface pointers, lists of object points, and lists of Qt interface pointers. As QML is typesafe it ensures that only valid types are assigned to these properties, just like it does for primitive types.</p>
<p>Properties that are pointers to objects or Qt interfaces are declared with the <a href="qobject.html#Q_PROPERTY">Q_PROPERTY</a>() macro, just like other properties. The <tt>host</tt> property declaration looks like this:</p>
<pre class="highlightedCode brush: cpp">     Q_PROPERTY(Person *host READ host WRITE setHost)</pre>
<p>As long as the property type, in this case <tt>Person</tt>, is registered with QML the property can be assigned.</p>
<p>QML also supports assigning Qt interfaces. To assign to a property whose type is a Qt interface pointer, the interface must also be registered with QML. As they cannot be instantiated directly, registering a Qt interface is different from registering a new QML type. The following function is used instead:</p>
<blockquote><pre class="highlightedCode brush: cpp"> template&lt;typename T&gt;
 int qmlRegisterInterface(const char *typeName)</pre>
<p>This registers the C++ interface <i>T</i> with the QML system as <i>typeName</i>.</p>
<p>Following registration, QML can coerce objects that implement this interface for assignment to appropriately typed properties.</p>
</blockquote>
<p>The <tt>guests</tt> property is a list of <tt>Person</tt> objects. Properties that are lists of objects or Qt interfaces are also declared with the <a href="qobject.html#Q_PROPERTY">Q_PROPERTY</a>() macro, just like other properties. List properties must have the type <tt>QDeclarativeListProperty&lt;T&gt;</tt>. As with object properties, the type <i>T</i> must be registered with QML.</p>
<p>The <tt>guest</tt> property declaration looks like this:</p>
<pre class="highlightedCode brush: cpp">     Q_PROPERTY(QDeclarativeListProperty&lt;Person&gt; guests READ guests)</pre>
<p><a href="declarative-cppextensions-referenceexamples-properties.html">Extending QML - Object and List Property Types Example</a> shows the complete code used to create the <tt>BirthdayParty</tt> type.</p>
<a name="inheritance-and-coercion"></a>
<h2>Inheritance and Coercion</h2>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     host: Boy {
         name: &quot;Bob Jones&quot;
         shoeSize: 12
     }
     guests: [
         Boy { name: &quot;Leo Hodges&quot; },
         Boy { name: &quot;Jack Smith&quot; },
         Girl { name: &quot;Anne Brown&quot; }
     ]
 }</pre>
<p>The QML snippet shown above assigns a <tt>Boy</tt> object to the <tt>BirthdayParty</tt>'s <tt>host</tt> property, and assigns three other objects to the <tt>guests</tt> property.</p>
<p>QML supports C++ inheritance hierarchies and can freely coerce between known, valid object types. This enables the creation of common base classes that allow the assignment of specialized classes to object or list properties. In the snippet shown, both the <tt>host</tt> and the <tt>guests</tt> properties retain the <tt>Person</tt> type used in the previous section, but the assignment is valid as both the <tt>Boy</tt> and <tt>Girl</tt> objects inherit from <tt>Person</tt>.</p>
<p>To assign to a property, the property's type must have been registered with QML. Both the <a href="qdeclarativeengine.html#qmlRegisterType">qmlRegisterType</a>() and <a href="qdeclarativeengine.html#qmlRegisterInterface">qmlRegisterInterface</a>() template functions already shown can be used to register a type with QML. Additionally, if a type that acts purely as a base class that cannot be instantiated from QML needs to be registered, the following function can be used:</p>
<blockquote><pre class="highlightedCode brush: cpp">     template&lt;typename T&gt;
     int qmlRegisterType()</pre>
<p>This registers the C++ type <i>T</i> with the QML system. The parameterless call to the template function <a href="qdeclarativeengine.html#qmlRegisterType">qmlRegisterType</a>() does not define a mapping between the C++ class and a QML element name, so the type is not instantiable from QML, but it is available for type coercion.</p>
<p>Type <i>T</i> must inherit <a href="qobject.html">QObject</a>, but there are no restrictions on whether it is concrete or the signature of its constructor.</p>
</blockquote>
<p>QML will automatically coerce C++ types when assigning to either an object property, or to a list property. Only if coercion fails does an assignment error occur.</p>
<p><a href="declarative-cppextensions-referenceexamples-coercion.html">Extending QML - Inheritance and Coercion Example</a> shows the complete code used to create the <tt>Boy</tt> and <tt>Girl</tt> types.</p>
<a name="default-property"></a>
<h2>Default Property</h2>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     host: Boy {
         name: &quot;Bob Jones&quot;
         shoeSize: 12
     }

     Boy { name: &quot;Leo Hodges&quot; }
     Boy { name: &quot;Jack Smith&quot; }
     Girl { name: &quot;Anne Brown&quot; }
 }</pre>
<p>The QML snippet shown above assigns a collection of objects to the <tt>BirthdayParty</tt>'s default property.</p>
<p>The <i>default property</i> is a syntactic convenience that allows a type designer to specify a single property as the type's default. The default property is assigned to whenever no explicit property is specified. As a convenience, it is behaviorally identical to assigning to the default property explicitly by name.</p>
<p>From C++, type designers mark the default property using a <a href="qobject.html#Q_CLASSINFO">Q_CLASSINFO</a>() annotation:</p>
<blockquote><pre class="highlightedCode brush: cpp"> Q_CLASSINFO(&quot;DefaultProperty&quot;, &quot;property&quot;)</pre>
<p>This marks <i>property</i> as the class's default property. <i>property</i> must be either an object property, or a list property.</p>
<p>A default property is optional. A derived class inherits its base class's default property, but may override it in its own declaration. <i>property</i> can refer to a property declared in the class itself, or a property inherited from a base class.</p>
</blockquote>
<p><a href="declarative-cppextensions-referenceexamples-default.html">Extending QML - Default Property Example</a> shows the complete code used to specify a default property.</p>
<a name="grouped-properties"></a>
<h2>Grouped Properties</h2>
<pre class="highlightedCode brush: cpp">     Boy {
         name: &quot;Jack Smith&quot;
         shoe {
             size: 8
             color: &quot;blue&quot;
             brand: &quot;Puma&quot;
             price: 19.95
         }
     }</pre>
<p>The QML snippet shown above assigns a number of properties to the <tt>Boy</tt> object, including four properties using the grouped property syntax.</p>
<p>Grouped properties collect similar properties together into a single named block. Grouped properties can be used to present a nicer API to developers, and may also simplify the implementation of common property collections across different types through implementation reuse.</p>
<p>A grouped property block is implemented as a read-only object property. The <tt>shoe</tt> property shown is declared like this:</p>
<pre class="highlightedCode brush: cpp">     Q_PROPERTY(ShoeDescription *shoe READ shoe)</pre>
<p>The <tt>ShoeDescription</tt> type declares the properties available to the grouped property block - in this case the <tt>size</tt>, <tt>color</tt>, <tt>brand</tt> and <tt>price</tt> properties.</p>
<p>Grouped property blocks may declared and accessed be recusively.</p>
<p><a href="declarative-cppextensions-referenceexamples-grouped.html">Extending QML - Grouped Properties Example</a> shows the complete code used to implement the <tt>shoe</tt> property grouping.</p>
<a name="attached-properties"></a>
<h2>Attached Properties</h2>
<pre class="highlightedCode brush: cpp">     Boy {
         name: &quot;Leo Hodges&quot;
         shoe { size: 10; color: &quot;black&quot;; brand: &quot;Reebok&quot;; price: 59.95 }

         BirthdayParty.rsvp: &quot;2009-07-06&quot;
     }</pre>
<p>The QML snippet shown above assigns a date to the <tt>rsvp</tt> property using the attached property syntax.</p>
<p>Attached properties allow unrelated types to annotate other types with some additional properties, generally for their own use. Attached properties are identified through the use of the attacher type name, in the case shown <tt>BirthdayParty</tt>, as a prefix to the property name.</p>
<p>In the example shown, <tt>BirthdayParty</tt> is called the attaching type, and the <tt>Boy</tt> instance the attachee object instance.</p>
<p>For the attaching type, an attached property block is implemented as a new <a href="qobject.html">QObject</a> derived type, called the attachment object. The properties on the attachment object are those that become available for use as the attached property block.</p>
<p>Any QML type can become an attaching type by declaring the <tt>qmlAttachedProperties()</tt> public function and declaring that the class has QML_HAS_ATTACHED_PROPERTIES:</p>
<blockquote><pre class="highlightedCode brush: cpp"> class MyType : public QObject {
     Q_OBJECT
 public:

     ...

     static AttachedPropertiesType *qmlAttachedProperties(QObject *object);
 };

 QML_DECLARE_TYPEINFO(MyType, QML_HAS_ATTACHED_PROPERTIES)</pre>
<p>This returns an attachment object, of type <i>AttachedPropertiesType</i>, for the attachee <i>object</i> instance. It is customary, though not strictly required, for the attachment object to be parented to <i>object</i> to prevent memory leaks.</p>
<p><i>AttachedPropertiesType</i> must be a <a href="qobject.html">QObject</a> derived type. The properties on this type will be accessible through the attached properties syntax.</p>
<p>This method will be called at most once for each attachee object instance. The QML engine will cache the returned instance pointer for subsequent attached property accesses. Consequently the attachment object may not be deleted until <i>object</i> is destroyed.</p>
</blockquote>
<p>Conceptually, attached properties are a <i>type</i> exporting a set of additional properties that can be set on <i>any</i> other object instance. Attached properties cannot be limited to only attaching to a sub-set of object instances, although their effect may be so limited.</p>
<p>For example, a common usage scenario is for a type to enhance the properties available to its children in order to gather instance specific data. Here we add a <tt>rsvp</tt> field to all the guests coming to a birthday party:</p>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     Boy { BirthdayParty.rsvp: &quot;2009-06-01&quot; }
 }</pre>
<p>However, as a type cannot limit the instances to which the attachment object must attach, the following is also allowed, even though adding a birthday party rsvp in this context will have no effect.</p>
<pre class="highlightedCode brush: cpp"> GraduationParty {
     Boy { BirthdayParty.rsvp: &quot;2009-06-01&quot; }
 }</pre>
<p>From C++, including the attaching type implementation, the attachment object for an instance can be accessed using the following method:</p>
<blockquote><pre class="highlightedCode brush: cpp"> template&lt;typename T&gt;
 QObject *qmlAttachedPropertiesObject&lt;T&gt;(QObject *attachee, bool create = true);</pre>
<p>This returns the attachment object attached to <i>attachee</i> by the attaching type <i>T</i>. If type <i>T</i> is not a valid attaching type, this method always returns 0.</p>
<p>If <i>create</i> is true, a valid attachment object will always be returned, creating it if it does not already exist. If <i>create</i> is false, the attachment object will only be returned if it has previously been created.</p>
</blockquote>
<p><a href="declarative-cppextensions-referenceexamples-attached.html">Extending QML - Attached Properties Example</a> shows the complete code used to implement the rsvp attached property.</p>
<a name="memory-management-and-qvariant-types"></a>
<h2>Memory Management and QVariant types</h2>
<p>It is an element's responsibility to ensure that it does not access or return pointers to invalid objects. QML makes the following guarentees:</p>
<ul>
<li>An object assigned to a <a href="qobject.html">QObject</a> (or <a href="qobject.html">QObject</a>-derived) pointer property will be valid at the time of assignment.<p>Following assignment, it is the responsibility of the class to subsequently guard this pointer, either through a class specific method or the generic <a href="qpointer.html">QPointer</a> class.</p>
</li>
<li>An object assigned to a <a href="qvariant.html">QVariant</a> will be valid at the time of assignment.<p>When assigning an object to a <a href="qvariant.html">QVariant</a> property, QML will always use a <a href="qmetatype.html#Type-enum">QMetaType::QObjectStar</a> typed <a href="qvariant.html">QVariant</a>. It is the responsibility of the class to guard the pointer. A general rule when writing a class that uses <a href="qvariant.html">QVariant</a> properties is to check the type of the <a href="qvariant.html">QVariant</a> when it is set and if the type is not handled by your class, reset it to an invalid variant.</p>
</li>
<li>An object assigned to a <a href="qobject.html">QObject</a> (or <a href="qobject.html">QObject</a>-derived) list property will be valid at the time of assignment.<p>Following assignment, it is the responsibility of the class to subsequently guard this pointer, either through a class specific method or the generic <a href="qpointer.html">QPointer</a> class.</p>
</li>
</ul>
<p>Elements should assume that any QML assigned object can be deleted at any time, and respond accordingly. If documented as such an element need not continue to work in this situation, but it must not crash.</p>
<a name="signal-support"></a>
<h2>Signal Support</h2>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     onPartyStarted: console.log(&quot;This party started rockin' at &quot; + time);
 }</pre>
<p>The QML snippet shown above associates the evaluation of a <a href="https://developer.mozilla.org/en/JavaScript">JavaScript</a> expression with the emission of a Qt signal.</p>
<p>All Qt signals on a registered class become available as special &quot;signal properties&quot; within QML to which the user can assign a single <a href="https://developer.mozilla.org/en/JavaScript">JavaScript</a> expression. The signal property's name is a transformed version of the Qt signal name: &quot;on&quot; is prepended, and the first letter of the signal name upper cased. For example, the signal used in the example above has the following C++ signature:</p>
<pre class="highlightedCode brush: cpp"> signals:
     void partyStarted(const QTime &amp;time);</pre>
<p>In classes with multiple signals with the same name, only the final signal is accessible as a signal property. Note that signals with the same name but different parameters cannot be distinguished.</p>
<p>Signal parameters become accessible by name to the assigned script. An unnamed parameter cannot be accessed, so care should be taken to name all the signal parameters in the C++ class declaration. The intrinsic types listed in <a href="#adding-types">Adding Types</a>, as well registered object types are permitted as signal parameter types. Using other types is not an error, but the parameter value will not be accessible from script.</p>
<p><a href="declarative-cppextensions-referenceexamples-signal.html">Extending QML - Signal Support Example</a> shows the complete code used to implement the onPartyStarted signal property.</p>
<p>If you want to use signals from items not created in QML, you can access their signals with the <a href="qml-connections.html">Connections</a> element.</p>
<p>Additionally, if a property is added to a C++ class, all QML elements based on that C++ class will have a <i>value-changed</i> signal handler for that property. The name of the signal handler is <i>on&lt;Property-name&gt;Changed</i>, with the first letter of the property name being upper case.</p>
<p><b>Note:</b> The QML signal handler will always be named on&lt;Property-name&gt;Changed, regardless of the name used for the NOTIFY signal in C++. We recommend using &lt;property-name&gt;Changed() for the NOTIFY signal in C++.</p>
<p>See also <a href="qml-extending-types.html">Extending types from QML</a>.</p>
<a name="property-value-sources"></a>
<h2>Property Value Sources</h2>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     HappyBirthdaySong on announcement { name: &quot;Bob Jones&quot; }
 }</pre>
<p>The QML snippet shown above applies a property value source to the <tt>announcment</tt> property. A property value source generates a value for a property that changes over time.</p>
<p>Property value sources are most commonly used to do animation. Rather than constructing an animation object and manually setting the animation's &quot;target&quot; property, a property value source can be assigned directly to a property of any type and automatically set up this association.</p>
<p>The example shown here is rather contrived: the <tt>announcment</tt> property of the <tt>BirthdayParty</tt> object is a string that is printed every time it is assigned and the <tt>HappyBirthdaySong</tt> value source generates the lyrics of the song &quot;Happy Birthday&quot;.</p>
<pre class="highlightedCode brush: cpp">     Q_PROPERTY(QString announcement READ announcement WRITE setAnnouncement)</pre>
<p>Normally, assigning an object to a string property would not be allowed. In the case of a property value source, rather than assigning the object instance itself, the QML engine sets up an association between the value source and the property.</p>
<p>Property value sources are special types that derive from the <a href="qdeclarativepropertyvaluesource.html">QDeclarativePropertyValueSource</a> base class. This base class contains a single method, <a href="qdeclarativepropertyvaluesource.html#setTarget">QDeclarativePropertyValueSource::setTarget</a>(), that the QML engine invokes when associating the property value source with a property. The relevant part of the <tt>HappyBirthdaySong</tt> type declaration looks like this:</p>
<pre class="highlightedCode brush: cpp"> class HappyBirthdaySong : public QObject, public QDeclarativePropertyValueSource
 {
     Q_OBJECT
     Q_INTERFACES(QDeclarativePropertyValueSource)
 public:
     HappyBirthdaySong(QObject *parent = 0);

     virtual void setTarget(const QDeclarativeProperty &amp;);
 };</pre>
<p>In all other respects, property value sources are regular QML types. They must be registered with the QML engine using the same macros as other types, and can contain properties, signals and methods just like other types.</p>
<p>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the <a href="qdeclarativepropertyvaluesource.html#setTarget">setTarget()</a> method. This allows the type to also be used in contexts other than just as a value source.</p>
<p><a href="declarative-cppextensions-referenceexamples-valuesource.html">Extending QML - Property Value Source Example</a> shows the complete code used implement the <tt>HappyBirthdaySong</tt> property value source.</p>
<a name="property-binding"></a>
<h2>Property Binding</h2>
<pre class="highlightedCode brush: cpp"> BirthdayParty {
     id: theParty

     HappyBirthdaySong on announcement { name: theParty.host.name }

     host: Boy {
         name: &quot;Bob Jones&quot;
         shoe { size: 12; color: &quot;white&quot;; brand: &quot;Nike&quot;; price: 90.0 }
     }
 }</pre>
<p>The QML snippet shown above uses a property binding to ensure the <tt>HappyBirthdaySong</tt>'s <tt>name</tt> property remains up to date with the <tt>host</tt>.</p>
<p>Property binding is a core feature of QML. In addition to assigning literal values, property bindings allow the developer to assign an arbitrarily complex <a href="https://developer.mozilla.org/en/JavaScript">JavaScript</a> expression that may include dependencies on other property values. Whenever the expression's result changes - through a change in one of its constituent values - the expression is automatically reevaluated and the new result assigned to the property.</p>
<p>All properties on custom types automatically support property binding. However, for binding to work correctly, QML must be able to reliably determine when a property has changed so that it knows to reevaluate any bindings that depend on the property's value. QML relies on the presence of a <a href="properties.html#qt-s-property-system">NOTIFY signal</a> for this determination.</p>
<p>Here is the <tt>host</tt> property declaration:</p>
<pre class="highlightedCode brush: cpp">     Q_PROPERTY(Person *host READ host WRITE setHost NOTIFY hostChanged)</pre>
<p>The NOTIFY attribute is followed by a signal name. It is the responsibility of the class implementer to ensure that whenever the property's value changes, the NOTIFY signal is emitted. The signature of the NOTIFY signal is not important to QML.</p>
<p>To prevent loops or excessive evaluation, developers should ensure that the signal is only emitted whenever the property's value is actually changed. If a property, or group of properties, is infrequently used it is permitted to use the same NOTIFY signal for several properties. This should be done with care to ensure that performance doesn't suffer.</p>
<p>To keep QML reliable, if a property does not have a NOTIFY signal, it cannot be used in a binding expression. However, the property can still be assigned a binding as QML does not need to monitor the property for change in that scenario.</p>
<p>Consider a custom type, <tt>TestElement</tt>, that has two properties, &quot;a&quot; and &quot;b&quot;. Property &quot;a&quot; does not have a NOTIFY signal, and property &quot;b&quot; does have a NOTIFY signal.</p>
<pre class="highlightedCode brush: cpp"> TestElement {
     <span class="comment">// This is OK</span>
     a: b
 }
 TestElement {
     <span class="comment">// Will NOT work</span>
     b: a
 }</pre>
<p>The presence of a NOTIFY signal does incur a small overhead. There are cases where a property's value is set at object construction time, and does not subsequently change. The most common case of this is when a type uses <a href="#grouped-properties">Grouped Properties</a>, and the grouped property object is allocated once, and only freed when the object is deleted. In these cases, the CONSTANT attribute may be added to the property declaration instead of a NOTIFY signal.</p>
<pre class="highlightedCode brush: cpp">     Q_PROPERTY(ShoeDescription *shoe READ shoe CONSTANT)</pre>
<p>Extreme care must be taken here or applications using your type may misbehave. The CONSTANT attribute should only be used for properties whose value is set, and finalized, only in the class constructor. All other properties that want to be used in bindings should have a NOTIFY signal instead.</p>
<p><a href="declarative-cppextensions-referenceexamples-binding.html">Extending QML - Binding Example</a> shows the BirthdayParty example updated to include NOTIFY signals for use in binding.</p>
<a name="extension-objects"></a>
<h2>Extension Objects</h2>
<pre class="highlightedCode brush: cpp"> QLineEdit {
     leftMargin: 20
 }</pre>
<p>The QML snippet shown above adds a new property to an existing C++ type without modifying its source code.</p>
<p>When integrating existing classes and technology into QML, their APIs will often need to be tweaked to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</p>
<p>Extension objects are used to add additional properties to an existing type. Extension objects can only add properties, not signals or methods. An extended type definition allows the programmer to supply an additional type - known as the extension type - when registering the target class whose properties are transparently merged with the original target class when used from within QML.</p>
<p>An extension class is a regular <a href="qobject.html">QObject</a>, with a constructor that takes a <a href="qobject.html">QObject</a> pointer. When needed (extension class creation is delayed until the first extended property is accessed) the extension class is created and the target object is passed in as the parent. When an extended property on the original is accessed, the appropriate property on the extension object is used instead.</p>
<p>When an extended type is installed, one of the</p>
<pre class="highlightedCode brush: cpp"> template&lt;typename T, typename ExtendedT&gt;
 int qmlRegisterType(const char *uri, int versionMajor, int versionMinor, const char *qmlName)

 template&lt;typename T, typename ExtendedT&gt;
 int qmlRegisterType()</pre>
<p>functions should be used instead of the regular <tt>qmlRegisterType()</tt> variations. The arguments are identical to the corresponding non-extension registration functions, except for the ExtendedT parameter which is the type of the extension object.</p>
<a name="optimization"></a>
<h2>Optimization</h2>
<p>Often to develop high performance elements it is helpful to know more about the status of the QML engine. For example, it might be beneficial to delay initializing some costly data structures until after all the properties have been set.</p>
<p>The QML engine defines an interface class called <a href="qdeclarativeparserstatus.html">QDeclarativeParserStatus</a>, which contains a number of virtual methods that are invoked at various stages during component instantiation. To receive these notifications, an element implementation inherits <a href="qdeclarativeparserstatus.html">QDeclarativeParserStatus</a> and notifies the Qt meta system using the <a href="qobject.html#Q_INTERFACES">Q_INTERFACES</a>() macro.</p>
<p>For example,</p>
<pre class="highlightedCode brush: cpp"> class Example : public QObject, public QDeclarativeParserStatus
 {
     Q_OBJECT
     Q_INTERFACES(QDeclarativeParserStatus)
 public:
     virtual void componentComplete()
     {
         qDebug() &lt;&lt; &quot;Woohoo!  Now to do my costly initialization&quot;;
     }
 };</pre>
</div>
<!-- @@@qml-extending.html -->
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
