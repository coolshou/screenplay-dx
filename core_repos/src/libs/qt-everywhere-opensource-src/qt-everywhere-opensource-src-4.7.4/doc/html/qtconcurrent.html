<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qtconcurrentmap.cpp -->
  <title>Qt 4.7: QtConcurrent Namespace</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
<li><a href="namespaces.html">Namespaces</a></li>
<li>QtConcurrent Namespace</li>
    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#classes">Classes</a></li>
<li class="level1"><a href="#types">Types</a></li>
<li class="level1"><a href="#functions">Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QtConcurrent Namespace</h1>
<!-- $$$QtConcurrent-brief -->
<p>The QtConcurrent namespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives. <a href="#details">More...</a></p>
<!-- @@@QtConcurrent -->
<pre class="cpp"> <span class="preprocessor">#include &lt;<a href="qtcore.html">QtCore</a>&gt;</span></pre><p>This namespace was introduced in Qt 4.4.</p>
<ul>
</ul>
<a name="classes"></a>
<h2>Classes</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent-exception.html">Exception</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent-unhandledexception.html">UnhandledException</a></b></td></tr>
</table>
<a name="types"></a>
<h2>Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#ReduceOption-enum">ReduceOption</a></b> { UnorderedReduce, OrderedReduce, SequentialReduce }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#ReduceOption-enum">ReduceOptions</a></b></td></tr>
</table>
<a name="functions"></a>
<h2>Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingFilter">blockingFilter</a></b> ( Sequence &amp; <i>sequence</i>, FilterFunction <i>filterFunction</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Sequence </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingFiltered">blockingFiltered</a></b> ( const Sequence &amp; <i>sequence</i>, FilterFunction <i>filterFunction</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Sequence </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingFiltered-2">blockingFiltered</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, FilterFunction <i>filterFunction</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingFilteredReduced">blockingFilteredReduced</a></b> ( const Sequence &amp; <i>sequence</i>, FilterFunction <i>filterFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingFilteredReduced-2">blockingFilteredReduced</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, FilterFunction <i>filterFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingMap">blockingMap</a></b> ( Sequence &amp; <i>sequence</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingMap-2">blockingMap</a></b> ( Iterator <i>begin</i>, Iterator <i>end</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingMapped">blockingMapped</a></b> ( const Sequence &amp; <i>sequence</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrent.html#blockingMapped-2">blockingMapped</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#blockingMappedReduced">blockingMappedReduced</a></b> ( const Sequence &amp; <i>sequence</i>, MapFunction <i>mapFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#blockingMappedReduced-2">blockingMappedReduced</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, MapFunction <i>mapFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;void&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentfilter.html#filter">filter</a></b> ( Sequence &amp; <i>sequence</i>, FilterFunction <i>filterFunction</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentfilter.html#filtered">filtered</a></b> ( const Sequence &amp; <i>sequence</i>, FilterFunction <i>filterFunction</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentfilter.html#filtered-2">filtered</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, FilterFunction <i>filterFunction</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentfilter.html#filteredReduced">filteredReduced</a></b> ( const Sequence &amp; <i>sequence</i>, FilterFunction <i>filterFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentfilter.html#filteredReduced-2">filteredReduced</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, FilterFunction <i>filterFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;void&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#map">map</a></b> ( Sequence &amp; <i>sequence</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;void&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#map-2">map</a></b> ( Iterator <i>begin</i>, Iterator <i>end</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#mapped">mapped</a></b> ( const Sequence &amp; <i>sequence</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#mapped-2">mapped</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, MapFunction <i>function</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#mappedReduced">mappedReduced</a></b> ( const Sequence &amp; <i>sequence</i>, MapFunction <i>mapFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentmap.html#mappedReduced-2">mappedReduced</a></b> ( ConstIterator <i>begin</i>, ConstIterator <i>end</i>, MapFunction <i>mapFunction</i>, ReduceFunction <i>reduceFunction</i>, QtConcurrent::ReduceOptions <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qtconcurrentrun.html#run">run</a></b> ( Function <i>function</i>, ... )</td></tr>
</table>
<a name="details"></a>
<!-- $$$QtConcurrent-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QtConcurrent namespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives.</p>
<p>See the <a href="threads-qtconcurrent.html">Qt Concurrent</a> chapter in the <a href="threads.html">threading</a> documentation.</p>
</div>
<!-- @@@QtConcurrent -->
<div class="classes">
<h2>Classes</h2>
<h3> class <a href="qtconcurrent-exception.html">Exception</a></h3><!-- $$$Exception-brief -->
<p>The Exception class provides a base class for exceptions that can transferred across threads. <a href="qtconcurrent-exception.html#details">More...</a></p>
<!-- @@@Exception -->
<h3> class <a href="qtconcurrent-unhandledexception.html">UnhandledException</a></h3><!-- $$$UnhandledException-brief -->
<p>The UnhandledException class represents an unhandled exception in a worker thread. <a href="qtconcurrent-unhandledexception.html#details">More...</a></p>
<!-- @@@UnhandledException -->
</div>
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$ReduceOption$$$UnorderedReduce$$$OrderedReduce$$$SequentialReduce -->
<h3 class="flags"><a name="ReduceOption-enum"></a>enum QtConcurrent::<span class="name">ReduceOption</span><br/>flags QtConcurrent::<span class="name">ReduceOptions</span></h3>
<p>This enum specifies the order of which results from the map or filter function are passed to the reduce function.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QtConcurrent::UnorderedReduce</tt></td><td class="topAlign"><tt>0x1</tt></td><td class="topAlign">Reduction is done in an arbitrary order.</td></tr>
<tr><td class="topAlign"><tt>QtConcurrent::OrderedReduce</tt></td><td class="topAlign"><tt>0x2</tt></td><td class="topAlign">Reduction is done in the order of the original sequence.</td></tr>
<tr><td class="topAlign"><tt>QtConcurrent::SequentialReduce</tt></td><td class="topAlign"><tt>0x4</tt></td><td class="topAlign">Reduction is done sequentially: only one thread will enter the reduce function at a time. (Parallel reduction might be supported in a future version of Qt Concurrent.)</td></tr>
</table>
<p>The ReduceOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;ReduceOption&gt;. It stores an OR combination of ReduceOption values.</p>
<!-- @@@ReduceOption -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$blockingFilter[overload1]$$$blockingFilterSequence&FilterFunction -->
<h3 class="fn"><a name="blockingFilter"></a><span class="type">void</span> QtConcurrent::<span class="name">blockingFilter</span> ( <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">FilterFunction</span> <i>filterFunction</i> )</h3>
<p>Calls <i>filterFunction</i> once for each item in <i>sequence</i>. If <i>filterFunction</i> returns true, the item is kept in <i>sequence</i>; otherwise, the item is removed from <i>sequence</i>.</p>
<p><b>Note:</b> This function will block until all items in the sequence have been processed.</p>
<!-- @@@blockingFilter -->
<!-- $$$blockingFiltered[overload1]$$$blockingFilteredconstSequence&FilterFunction -->
<h3 class="fn"><a name="blockingFiltered"></a><span class="type">Sequence</span> QtConcurrent::<span class="name">blockingFiltered</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">FilterFunction</span> <i>filterFunction</i> )</h3>
<p>Calls <i>filterFunction</i> once for each item in <i>sequence</i> and returns a new Sequence of kept items. If <i>filterFunction</i> returns true, a copy of the item is put in the new Sequence. Otherwise, the item will <i>not</i> appear in the new Sequence.</p>
<p><b>Note:</b> This function will block until all items in the sequence have been processed.</p>
<p><b>See also </b><a href="qtconcurrentfilter.html#filtered">filtered</a>().</p>
<!-- @@@blockingFiltered -->
<!-- $$$blockingFiltered$$$blockingFilteredConstIteratorConstIteratorFilterFunction -->
<h3 class="fn"><a name="blockingFiltered-2"></a><span class="type">Sequence</span> QtConcurrent::<span class="name">blockingFiltered</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">FilterFunction</span> <i>filterFunction</i> )</h3>
<p>Calls <i>filterFunction</i> once for each item from <i>begin</i> to <i>end</i> and returns a new Sequence of kept items. If <i>filterFunction</i> returns true, a copy of the item is put in the new Sequence. Otherwise, the item will <i>not</i> appear in the new Sequence.</p>
<p><b>Note:</b> This function will block until the iterator reaches the end of the sequence being processed.</p>
<p><b>See also </b><a href="qtconcurrentfilter.html#filtered">filtered</a>().</p>
<!-- @@@blockingFiltered -->
<!-- $$$blockingFilteredReduced[overload1]$$$blockingFilteredReducedconstSequence&FilterFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="blockingFilteredReduced"></a><span class="type">T</span> QtConcurrent::<span class="name">blockingFilteredReduced</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">FilterFunction</span> <i>filterFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>filterFunction</i> once for each item in <i>sequence</i>. If <i>filterFunction</i> returns true for an item, that item is then passed to <i>reduceFunction</i>. In other words, the return value is the result of <i>reduceFunction</i> for each item where <i>filterFunction</i> returns true.</p>
<p>Note that while <i>filterFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is undefined if <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::UnorderedReduce</a>. If <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::OrderedReduce</a>, <i>reduceFunction</i> is called in the order of the original sequence.</p>
<p><b>Note:</b> This function will block until all items in the sequence have been processed.</p>
<p><b>See also </b><a href="qtconcurrentfilter.html#filteredReduced">filteredReduced</a>().</p>
<!-- @@@blockingFilteredReduced -->
<!-- $$$blockingFilteredReduced$$$blockingFilteredReducedConstIteratorConstIteratorFilterFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="blockingFilteredReduced-2"></a><span class="type">T</span> QtConcurrent::<span class="name">blockingFilteredReduced</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">FilterFunction</span> <i>filterFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>filterFunction</i> once for each item from <i>begin</i> to <i>end</i>. If <i>filterFunction</i> returns true for an item, that item is then passed to <i>reduceFunction</i>. In other words, the return value is the result of <i>reduceFunction</i> for each item where <i>filterFunction</i> returns true.</p>
<p>Note that while <i>filterFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is undefined if <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::UnorderedReduce</a>. If <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::OrderedReduce</a>, the <i>reduceFunction</i> is called in the order of the original sequence.</p>
<p><b>Note:</b> This function will block until the iterator reaches the end of the sequence being processed.</p>
<p><b>See also </b><a href="qtconcurrentfilter.html#filteredReduced">filteredReduced</a>().</p>
<!-- @@@blockingFilteredReduced -->
<!-- $$$blockingMap[overload1]$$$blockingMapSequence&MapFunction -->
<h3 class="fn"><a name="blockingMap"></a><span class="type">void</span> QtConcurrent::<span class="name">blockingMap</span> ( <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item in <i>sequence</i>. The <i>function</i> is passed a reference to the item, so that any modifications done to the item will appear in <i>sequence</i>.</p>
<p><b>Note:</b> This function will block until all items in the sequence have been processed.</p>
<p><b>See also </b><a href="qtconcurrentmap.html#map">map</a>().</p>
<!-- @@@blockingMap -->
<!-- $$$blockingMap$$$blockingMapIteratorIteratorMapFunction -->
<h3 class="fn"><a name="blockingMap-2"></a><span class="type">void</span> QtConcurrent::<span class="name">blockingMap</span> ( <span class="type">Iterator</span> <i>begin</i>, <span class="type">Iterator</span> <i>end</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item from <i>begin</i> to <i>end</i>. The <i>function</i> is passed a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</p>
<p><b>Note:</b> This function will block until the iterator reaches the end of the sequence being processed.</p>
<p><b>See also </b><a href="qtconcurrentmap.html#map">map</a>().</p>
<!-- @@@blockingMap -->
<!-- $$$blockingMapped[overload1]$$$blockingMappedconstSequence&MapFunction -->
<h3 class="fn"><a name="blockingMapped"></a><span class="type">T</span> QtConcurrent::<span class="name">blockingMapped</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item in <i>sequence</i> and returns a Sequence containing the results. The type of the results will match the type returned my the MapFunction.</p>
<p><b>Note:</b> This function will block until all items in the sequence have been processed.</p>
<p><b>See also </b><a href="qtconcurrentmap.html#mapped">mapped</a>().</p>
<!-- @@@blockingMapped -->
<!-- $$$blockingMapped$$$blockingMappedConstIteratorConstIteratorMapFunction -->
<h3 class="fn"><a name="blockingMapped-2"></a><span class="type">T</span> QtConcurrent::<span class="name">blockingMapped</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item from <i>begin</i> to <i>end</i> and returns a container with the results. Specify the type of container as the a template argument, like this:</p>
<pre class="cpp"> <span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> ints <span class="operator">=</span> <span class="type"><a href="qtconcurrent.html">QtConcurrent</a></span><span class="operator">::</span>blockingMapped<span class="operator">&lt;</span><span class="type"><a href="qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> <span class="operator">&gt;</span>(beginIterator<span class="operator">,</span> endIterator<span class="operator">,</span> fn);</pre>
<p><b>Note:</b> This function will block until the iterator reaches the end of the sequence being processed.</p>
<p><b>See also </b><a href="qtconcurrentmap.html#mapped">mapped</a>().</p>
<!-- @@@blockingMapped -->
<!-- $$$blockingMappedReduced[overload1]$$$blockingMappedReducedconstSequence&MapFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="blockingMappedReduced"></a><span class="type">T</span> QtConcurrent::<span class="name">blockingMappedReduced</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">MapFunction</span> <i>mapFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>mapFunction</i> once for each item in <i>sequence</i>. The return value of each <i>mapFunction</i> is passed to <i>reduceFunction</i>.</p>
<p>Note that while <i>mapFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is determined by <i>reduceOptions</i>.</p>
<p><b>Note:</b> This function will block until all items in the sequence have been processed.</p>
<p><b>See also </b><a href="qtconcurrentmap.html#mapped">mapped</a>().</p>
<!-- @@@blockingMappedReduced -->
<!-- $$$blockingMappedReduced$$$blockingMappedReducedConstIteratorConstIteratorMapFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="blockingMappedReduced-2"></a><span class="type">T</span> QtConcurrent::<span class="name">blockingMappedReduced</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">MapFunction</span> <i>mapFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>mapFunction</i> once for each item from <i>begin</i> to <i>end</i>. The return value of each <i>mapFunction</i> is passed to <i>reduceFunction</i>.</p>
<p>Note that while <i>mapFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is undefined.</p>
<p><b>Note:</b> This function will block until the iterator reaches the end of the sequence being processed.</p>
<p><b>See also </b><a href="qtconcurrentmap.html#blockingMappedReduced">blockingMappedReduced</a>().</p>
<!-- @@@blockingMappedReduced -->
<!-- $$$filter[overload1]$$$filterSequence&FilterFunction -->
<h3 class="fn"><a name="filter"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">void</span>&gt; QtConcurrent::<span class="name">filter</span> ( <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">FilterFunction</span> <i>filterFunction</i> )</h3>
<p>Calls <i>filterFunction</i> once for each item in <i>sequence</i>. If <i>filterFunction</i> returns true, the item is kept in <i>sequence</i>; otherwise, the item is removed from <i>sequence</i>.</p>
<!-- @@@filter -->
<!-- $$$filtered[overload1]$$$filteredconstSequence&FilterFunction -->
<h3 class="fn"><a name="filtered"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">filtered</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">FilterFunction</span> <i>filterFunction</i> )</h3>
<p>Calls <i>filterFunction</i> once for each item in <i>sequence</i> and returns a new Sequence of kept items. If <i>filterFunction</i> returns true, a copy of the item is put in the new Sequence. Otherwise, the item will <i>not</i> appear in the new Sequence.</p>
<!-- @@@filtered -->
<!-- $$$filtered$$$filteredConstIteratorConstIteratorFilterFunction -->
<h3 class="fn"><a name="filtered-2"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">filtered</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">FilterFunction</span> <i>filterFunction</i> )</h3>
<p>Calls <i>filterFunction</i> once for each item from <i>begin</i> to <i>end</i> and returns a new Sequence of kept items. If <i>filterFunction</i> returns true, a copy of the item is put in the new Sequence. Otherwise, the item will <i>not</i> appear in the new Sequence.</p>
<!-- @@@filtered -->
<!-- $$$filteredReduced[overload1]$$$filteredReducedconstSequence&FilterFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="filteredReduced"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">filteredReduced</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">FilterFunction</span> <i>filterFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>filterFunction</i> once for each item in <i>sequence</i>. If <i>filterFunction</i> returns true for an item, that item is then passed to <i>reduceFunction</i>. In other words, the return value is the result of <i>reduceFunction</i> for each item where <i>filterFunction</i> returns true.</p>
<p>Note that while <i>filterFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is undefined if <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::UnorderedReduce</a>. If <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::OrderedReduce</a>, <i>reduceFunction</i> is called in the order of the original sequence.</p>
<!-- @@@filteredReduced -->
<!-- $$$filteredReduced$$$filteredReducedConstIteratorConstIteratorFilterFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="filteredReduced-2"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">filteredReduced</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">FilterFunction</span> <i>filterFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>filterFunction</i> once for each item from <i>begin</i> to <i>end</i>. If <i>filterFunction</i> returns true for an item, that item is then passed to <i>reduceFunction</i>. In other words, the return value is the result of <i>reduceFunction</i> for each item where <i>filterFunction</i> returns true.</p>
<p>Note that while <i>filterFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is undefined if <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::UnorderedReduce</a>. If <i>reduceOptions</i> is <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::OrderedReduce</a>, the <i>reduceFunction</i> is called in the order of the original sequence.</p>
<!-- @@@filteredReduced -->
<!-- $$$map[overload1]$$$mapSequence&MapFunction -->
<h3 class="fn"><a name="map"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">void</span>&gt; QtConcurrent::<span class="name">map</span> ( <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item in <i>sequence</i>. The <i>function</i> is passed a reference to the item, so that any modifications done to the item will appear in <i>sequence</i>.</p>
<!-- @@@map -->
<!-- $$$map$$$mapIteratorIteratorMapFunction -->
<h3 class="fn"><a name="map-2"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">void</span>&gt; QtConcurrent::<span class="name">map</span> ( <span class="type">Iterator</span> <i>begin</i>, <span class="type">Iterator</span> <i>end</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item from <i>begin</i> to <i>end</i>. The <i>function</i> is passed a reference to the item, so that any modifications done to the item will appear in the sequence which the iterators belong to.</p>
<!-- @@@map -->
<!-- $$$mapped[overload1]$$$mappedconstSequence&MapFunction -->
<h3 class="fn"><a name="mapped"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">mapped</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item in <i>sequence</i> and returns a future with each mapped item as a result. You can use <a href="qfuture-const-iterator.html">QFuture::const_iterator</a> or <a href="qfutureiterator.html">QFutureIterator</a> to iterate through the results.</p>
<!-- @@@mapped -->
<!-- $$$mapped$$$mappedConstIteratorConstIteratorMapFunction -->
<h3 class="fn"><a name="mapped-2"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">mapped</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">MapFunction</span> <i>function</i> )</h3>
<p>Calls <i>function</i> once for each item from <i>begin</i> to <i>end</i> and returns a future with each mapped item as a result. You can use <a href="qfuture-const-iterator.html">QFuture::const_iterator</a> or <a href="qfutureiterator.html">QFutureIterator</a> to iterate through the results.</p>
<!-- @@@mapped -->
<!-- $$$mappedReduced[overload1]$$$mappedReducedconstSequence&MapFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="mappedReduced"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">mappedReduced</span> ( const <span class="type">Sequence</span> &amp; <i>sequence</i>, <span class="type">MapFunction</span> <i>mapFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>mapFunction</i> once for each item in <i>sequence</i>. The return value of each <i>mapFunction</i> is passed to <i>reduceFunction</i>.</p>
<p>Note that while <i>mapFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. The order in which <i>reduceFunction</i> is called is determined by <i>reduceOptions</i>.</p>
<!-- @@@mappedReduced -->
<!-- $$$mappedReduced$$$mappedReducedConstIteratorConstIteratorMapFunctionReduceFunctionQtConcurrent::ReduceOptions -->
<h3 class="fn"><a name="mappedReduced-2"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">mappedReduced</span> ( <span class="type">ConstIterator</span> <i>begin</i>, <span class="type">ConstIterator</span> <i>end</i>, <span class="type">MapFunction</span> <i>mapFunction</i>, <span class="type">ReduceFunction</span> <i>reduceFunction</i>, <span class="type"><a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::ReduceOptions</a></span> <i>reduceOptions</i> = UnorderedReduce | SequentialReduce )</h3>
<p>Calls <i>mapFunction</i> once for each item from <i>begin</i> to <i>end</i>. The return value of each <i>mapFunction</i> is passed to <i>reduceFunction</i>.</p>
<p>Note that while <i>mapFunction</i> is called concurrently, only one thread at a time will call <i>reduceFunction</i>. By default, the order in which <i>reduceFunction</i> is called is undefined.</p>
<p><b>Note:</b> <a href="qtconcurrent.html#ReduceOption-enum">QtConcurrent::OrderedReduce</a> results in the ordered reduction.</p>
<!-- @@@mappedReduced -->
<!-- $$$run[overload1]$$$runFunction... -->
<h3 class="fn"><a name="run"></a><span class="type"><a href="qfuture.html">QFuture</a></span>&lt;<span class="type">T</span>&gt; QtConcurrent::<span class="name">run</span> ( <span class="type">Function</span> <i>function</i>, ... )</h3>
<p>Runs <i>function</i> in a separate thread. The thread is taken from the global <a href="qthreadpool.html">QThreadPool</a>. Note that the function may not run immediately; the function will only be run when a thread is available.</p>
<p>T is the same type as the return value of <i>function</i>. Non-void return values can be accessed via the <a href="qfuture.html#result">QFuture::result</a>() function.</p>
<p>Note that the <a href="qfuture.html">QFuture</a> returned by QtConcurrent::run() does not support canceling, pausing, or progress reporting. The <a href="qfuture.html">QFuture</a> returned can only be used to query for the running/finished status and the return value of the function.</p>
<!-- @@@run -->
</div>
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
