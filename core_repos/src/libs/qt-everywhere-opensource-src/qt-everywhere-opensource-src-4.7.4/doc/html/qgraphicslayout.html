<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qgraphicslayout.cpp -->
  <title>Qt 4.7: QGraphicsLayout Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qtgui.html">QtGui</a></li>
<li>QGraphicsLayout</li>
    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#writing-a-custom-layout">Writing a Custom Layout</a></li>
<li class="level2"><a href="#activating-the-layout">Activating the Layout</a></li>
<li class="level3"><a href="#activating-the-layout-implicitly">Activating the Layout Implicitly</a></li>
<li class="level2"><a href="#event-handling">Event Handling</a></li>
<li class="level2"><a href="#margin-handling">Margin Handling</a></li>
</ul>
</div>
<h1 class="title">QGraphicsLayout Class Reference</h1>
<!-- $$$QGraphicsLayout-brief -->
<p>The QGraphicsLayout class provides the base class for all layouts in Graphics View. <a href="#details">More...</a></p>
<!-- @@@QGraphicsLayout -->
<pre class="cpp"> <span class="preprocessor">#include &lt;QGraphicsLayout&gt;</span></pre><p><b>Inherits: </b><a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a>.</p>
<p><b>Inherited by: </b><a href="qgraphicsanchorlayout.html">QGraphicsAnchorLayout</a>, <a href="qgraphicsgridlayout.html">QGraphicsGridLayout</a>, and <a href="qgraphicslinearlayout.html">QGraphicsLinearLayout</a>.</p>
<p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="qgraphicslayout-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#QGraphicsLayout">QGraphicsLayout</a></b> ( QGraphicsLayoutItem * <i>parent</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#dtor.QGraphicsLayout">~QGraphicsLayout</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#activate">activate</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#count">count</a></b> () const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#invalidate">invalidate</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#isActivated">isActivated</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QGraphicsLayoutItem * </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#itemAt">itemAt</a></b> ( int <i>i</i> ) const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#removeAt">removeAt</a></b> ( int <i>index</i> ) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#setContentsMargins">setContentsMargins</a></b> ( qreal <i>left</i>, qreal <i>top</i>, qreal <i>right</i>, qreal <i>bottom</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#widgetEvent">widgetEvent</a></b> ( QEvent * <i>e</i> )</td></tr>
</table>
<a name="reimplemented-public-functions"></a>
<h2>Reimplemented Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#getContentsMargins">getContentsMargins</a></b> ( qreal * <i>left</i>, qreal * <i>top</i>, qreal * <i>right</i>, qreal * <i>bottom</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#updateGeometry">updateGeometry</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">35 public functions inherited from <a href="qgraphicslayoutitem.html#public-functions">QGraphicsLayoutItem</a></li>
</ul>
<a name="protected-functions"></a>
<h2>Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qgraphicslayout.html#addChildLayoutItem">addChildLayoutItem</a></b> ( QGraphicsLayoutItem * <i>layoutItem</i> )</td></tr>
</table>
<ul>
<li class="fn">3 protected functions inherited from <a href="qgraphicslayoutitem.html#protected-functions">QGraphicsLayoutItem</a></li>
</ul>
<a name="details"></a>
<!-- $$$QGraphicsLayout-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QGraphicsLayout class provides the base class for all layouts in Graphics View.</p>
<p>QGraphicsLayout is an abstract class that defines a virtual API for arranging <a href="qgraphicswidget.html">QGraphicsWidget</a> children and other <a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a> objects for a <a href="qgraphicswidget.html">QGraphicsWidget</a>. <a href="qgraphicswidget.html">QGraphicsWidget</a> assigns responsibility to a QGraphicsLayout through <a href="qgraphicswidget.html#layout-prop">QGraphicsWidget::setLayout</a>(). As the widget is resized, the layout will automatically arrange the widget's children. QGraphicsLayout inherits <a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a>, so, it can be managed by any layout, including its own subclasses.</p>
<a name="writing-a-custom-layout"></a>
<h3>Writing a Custom Layout</h3>
<p>You can use QGraphicsLayout as a base to write your own custom layout (e.g&#x2e;, a flowlayout), but it is more common to use one of its subclasses instead - <a href="qgraphicslinearlayout.html">QGraphicsLinearLayout</a> or <a href="qgraphicsgridlayout.html">QGraphicsGridLayout</a>. When creating a custom layout, the following functions must be reimplemented as a bare minimum:</p>
<table class="generic">
<thead><tr class="qt-style"><th >Function</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qgraphicslayoutitem.html#setGeometry">QGraphicsLayoutItem::setGeometry</a>()</td><td >Notifies you when the geometry of the layout is set. You can store the geometry in your own layout class in a reimplementation of this function.</td></tr>
<tr valign="top" class="even"><td ><a href="qgraphicslayoutitem.html#sizeHint">QGraphicsLayoutItem::sizeHint</a>()</td><td >Returns the layout's size hints.</td></tr>
<tr valign="top" class="odd"><td ><a href="qgraphicslayout.html#count">QGraphicsLayout::count</a>()</td><td >Returns the number of items in your layout.</td></tr>
<tr valign="top" class="even"><td ><a href="qgraphicslayout.html#itemAt">QGraphicsLayout::itemAt</a>()</td><td >Returns a pointer to an item in your layout.</td></tr>
<tr valign="top" class="odd"><td ><a href="qgraphicslayout.html#removeAt">QGraphicsLayout::removeAt</a>()</td><td >Removes an item from your layout without destroying it.</td></tr>
</table>
<p>For more details on how to implement each function, refer to the individual function documentation.</p>
<p>Each layout defines its own API for arranging widgets and layout items. For example, with a grid layout, you require a row and a column index with optional row and column spans, alignment, spacing, and more. A linear layout, however, requires a single row or column index to position its items. For a grid layout, the order of insertion does not affect the layout in any way, but for a linear layout, the order is essential. When writing your own layout subclass, you are free to choose the API that best suits your layout.</p>
<a name="activating-the-layout"></a>
<h3>Activating the Layout</h3>
<p>When the layout's geometry changes, QGraphicsLayout immediately rearranges all of its managed items by calling <a href="qgraphicslayoutitem.html#setGeometry">setGeometry</a>() on each item. This rearrangement is called <i>activating</i> the layout.</p>
<p>QGraphicsLayout updates its own geometry to match the <a href="qgraphicslayoutitem.html#contentsRect">contentsRect</a>() of the <a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a> it is managing. Thus, it will automatically rearrange all its items when the widget is resized. QGraphicsLayout caches the sizes of all its managed items to avoid calling <a href="qgraphicslayoutitem.html#setGeometry">setGeometry</a>() too often.</p>
<p><b>Note:</b> A QGraphicsLayout will have the same geometry as the <a href="qgraphicslayoutitem.html#contentsRect">contentsRect</a>() of the widget (not the layout) it is assigned to.</p>
<a name="activating-the-layout-implicitly"></a>
<h4>Activating the Layout Implicitly</h4>
<p>The layout can be activated implicitly using one of two ways: by calling <a href="qgraphicslayout.html#activate">activate</a>() or by calling <a href="qgraphicslayout.html#invalidate">invalidate</a>(). Calling <a href="qgraphicslayout.html#activate">activate</a>() activates the layout immediately. In contrast, calling <a href="qgraphicslayout.html#invalidate">invalidate</a>() is delayed, as it posts a <a href="qevent.html#Type-enum">LayoutRequest</a> event to the managed widget. Due to event compression, the <a href="qgraphicslayout.html#activate">activate</a>() will only be called once after control has returned to the event loop. This is referred to as <i>invalidating</i> the layout. Invalidating the layout also invalidates any cached information. Also, the <a href="qgraphicslayout.html#invalidate">invalidate</a>() function is a virtual function. So, you can invalidate your own cache in a subclass of QGraphicsLayout by reimplementing this function.</p>
<a name="event-handling"></a>
<h3>Event Handling</h3>
<p>QGraphicsLayout listens to events for the widget it manages through the virtual <a href="qgraphicslayout.html#widgetEvent">widgetEvent</a>() event handler. When the layout is assigned to a widget, all events delivered to the widget are first processed by <a href="qgraphicslayout.html#widgetEvent">widgetEvent</a>(). This allows the layout to be aware of any relevant state changes on the widget such as visibility changes or layout direction changes.</p>
<a name="margin-handling"></a>
<h3>Margin Handling</h3>
<p>The margins of a QGraphicsLayout can be modified by reimplementing <a href="qgraphicslayout.html#setContentsMargins">setContentsMargins</a>() and <a href="qgraphicslayout.html#getContentsMargins">getContentsMargins</a>().</p>
</div>
<!-- @@@QGraphicsLayout -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGraphicsLayout[overload1]$$$QGraphicsLayoutQGraphicsLayoutItem* -->
<h3 class="fn"><a name="QGraphicsLayout"></a>QGraphicsLayout::<span class="name">QGraphicsLayout</span> ( <span class="type"><a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a></span> * <i>parent</i> = 0 )</h3>
<p>Contructs a <a href="qgraphicslayout.html">QGraphicsLayout</a> object.</p>
<p><i>parent</i> is passed to <a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a>'s constructor and the <a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a>'s isLayout argument is set to <i>true</i>.</p>
<p>If <i>parent</i> is a <a href="qgraphicswidget.html">QGraphicsWidget</a> the layout will be installed on that widget. (Note that installing a layout will delete the old one installed.)</p>
<!-- @@@QGraphicsLayout -->
<!-- $$$~QGraphicsLayout[overload1]$$$~QGraphicsLayout -->
<h3 class="fn"><a name="dtor.QGraphicsLayout"></a>QGraphicsLayout::<span class="name">~QGraphicsLayout</span> ()</h3>
<p>Destroys the <a href="qgraphicslayout.html">QGraphicsLayout</a> object.</p>
<!-- @@@~QGraphicsLayout -->
<!-- $$$activate[overload1]$$$activate -->
<h3 class="fn"><a name="activate"></a><span class="type">void</span> QGraphicsLayout::<span class="name">activate</span> ()</h3>
<p>Activates the layout, causing all items in the layout to be immediately rearranged. This function is based on calling <a href="qgraphicslayout.html#count">count</a>() and <a href="qgraphicslayout.html#itemAt">itemAt</a>(), and then calling <a href="qgraphicslayoutitem.html#setGeometry">setGeometry</a>() on all items sequentially. When activated, the layout will adjust its geometry to its parent's <a href="qgraphicslayoutitem.html#contentsRect">contentsRect</a>(). The parent will then invalidate any layout of its own.</p>
<p>If called in sequence or recursively, e.g&#x2e;, by one of the arranged items in response to being resized, this function will do nothing.</p>
<p>Note that the layout is free to use geometry caching to optimize this process. To forcefully invalidate any such cache, you can call <a href="qgraphicslayout.html#invalidate">invalidate</a>() before calling activate().</p>
<p><b>See also </b><a href="qgraphicslayout.html#invalidate">invalidate</a>().</p>
<!-- @@@activate -->
<!-- $$$addChildLayoutItem[overload1]$$$addChildLayoutItemQGraphicsLayoutItem* -->
<h3 class="fn"><a name="addChildLayoutItem"></a><span class="type">void</span> QGraphicsLayout::<span class="name">addChildLayoutItem</span> ( <span class="type"><a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a></span> * <i>layoutItem</i> )<tt> [protected]</tt></h3>
<p>This function is a convenience function provided for custom layouts, and will go through all items in the layout and reparent their graphics items to the closest <a href="qgraphicswidget.html">QGraphicsWidget</a> ancestor of the layout.</p>
<p>If <i>layoutItem</i> is already in a different layout, it will be removed from that layout.</p>
<p>If custom layouts want special behaviour they can ignore to use this function, and implement their own behaviour.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="qgraphicslayoutitem.html#graphicsItem">graphicsItem</a>().</p>
<!-- @@@addChildLayoutItem -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn"><a name="count"></a><span class="type">int</span> QGraphicsLayout::<span class="name">count</span> () const<tt> [pure virtual]</tt></h3>
<p>This pure virtual function must be reimplemented in a subclass of <a href="qgraphicslayout.html">QGraphicsLayout</a> to return the number of items in the layout.</p>
<p>The subclass is free to decide how to store the items.</p>
<p><b>See also </b><a href="qgraphicslayout.html#itemAt">itemAt</a>() and <a href="qgraphicslayout.html#removeAt">removeAt</a>().</p>
<!-- @@@count -->
<!-- $$$getContentsMargins[overload1]$$$getContentsMarginsqreal*qreal*qreal*qreal* -->
<h3 class="fn"><a name="getContentsMargins"></a><span class="type">void</span> QGraphicsLayout::<span class="name">getContentsMargins</span> ( <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> * <i>left</i>, <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> * <i>top</i>, <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> * <i>right</i>, <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> * <i>bottom</i> ) const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qgraphicslayoutitem.html#getContentsMargins">QGraphicsLayoutItem::getContentsMargins</a>().</p>
<!-- @@@getContentsMargins -->
<!-- $$$invalidate[overload1]$$$invalidate -->
<h3 class="fn"><a name="invalidate"></a><span class="type">void</span> QGraphicsLayout::<span class="name">invalidate</span> ()<tt> [virtual]</tt></h3>
<p>Clears any cached geometry and size hint information in the layout, and posts a <a href="qevent.html#Type-enum">LayoutRequest</a> event to the managed parent <a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a>.</p>
<p><b>See also </b><a href="qgraphicslayout.html#activate">activate</a>() and <a href="qgraphicslayoutitem.html#setGeometry">setGeometry</a>().</p>
<!-- @@@invalidate -->
<!-- $$$isActivated[overload1]$$$isActivated -->
<h3 class="fn"><a name="isActivated"></a><span class="type">bool</span> QGraphicsLayout::<span class="name">isActivated</span> () const</h3>
<p>Returns true if the layout is currently being activated; otherwise, returns false. If the layout is being activated, this means that it is currently in the process of rearranging its items (i.e&#x2e;, the <a href="qgraphicslayout.html#activate">activate</a>() function has been called, and has not yet returned).</p>
<p><b>See also </b><a href="qgraphicslayout.html#activate">activate</a>() and <a href="qgraphicslayout.html#invalidate">invalidate</a>().</p>
<!-- @@@isActivated -->
<!-- $$$itemAt[overload1]$$$itemAtint -->
<h3 class="fn"><a name="itemAt"></a><span class="type"><a href="qgraphicslayoutitem.html">QGraphicsLayoutItem</a></span> * QGraphicsLayout::<span class="name">itemAt</span> ( <span class="type">int</span> <i>i</i> ) const<tt> [pure virtual]</tt></h3>
<p>This pure virtual function must be reimplemented in a subclass of <a href="qgraphicslayout.html">QGraphicsLayout</a> to return a pointer to the item at index <i>i</i>. The reimplementation can assume that <i>i</i> is valid (i.e&#x2e;, it respects the value of <a href="qgraphicslayout.html#count">count</a>()). Together with <a href="qgraphicslayout.html#count">count</a>(), it is provided as a means of iterating over all items in a layout.</p>
<p>The subclass is free to decide how to store the items, and the visual arrangement does not have to be reflected through this function.</p>
<p><b>See also </b><a href="qgraphicslayout.html#count">count</a>() and <a href="qgraphicslayout.html#removeAt">removeAt</a>().</p>
<!-- @@@itemAt -->
<!-- $$$removeAt[overload1]$$$removeAtint -->
<h3 class="fn"><a name="removeAt"></a><span class="type">void</span> QGraphicsLayout::<span class="name">removeAt</span> ( <span class="type">int</span> <i>index</i> )<tt> [pure virtual]</tt></h3>
<p>This pure virtual function must be reimplemented in a subclass of <a href="qgraphicslayout.html">QGraphicsLayout</a> to remove the item at <i>index</i>. The reimplementation can assume that <i>index</i> is valid (i.e&#x2e;, it respects the value of <a href="qgraphicslayout.html#count">count</a>()).</p>
<p>The implementation must ensure that the <a href="qgraphicslayoutitem.html#parentLayoutItem">parentLayoutItem</a>() of the removed item does not point to this layout, since the item is considered to be removed from the layout hierarchy.</p>
<p>If the layout is to be reused between applications, we recommend that the layout deletes the item, but the graphics view framework does not depend on this.</p>
<p>The subclass is free to decide how to store the items.</p>
<p><b>See also </b><a href="qgraphicslayout.html#itemAt">itemAt</a>() and <a href="qgraphicslayout.html#count">count</a>().</p>
<!-- @@@removeAt -->
<!-- $$$setContentsMargins[overload1]$$$setContentsMarginsqrealqrealqrealqreal -->
<h3 class="fn"><a name="setContentsMargins"></a><span class="type">void</span> QGraphicsLayout::<span class="name">setContentsMargins</span> ( <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> <i>left</i>, <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> <i>top</i>, <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> <i>right</i>, <span class="type"><a href="qtglobal.html#qreal-typedef">qreal</a></span> <i>bottom</i> )</h3>
<p>Sets the contents margins to <i>left</i>, <i>top</i>, <i>right</i> and <i>bottom</i>. The default contents margins for toplevel layouts are style dependent (by querying the pixelMetric for <a href="qstyle.html#PixelMetric-enum">QStyle::PM_LayoutLeftMargin</a>, <a href="qstyle.html#PixelMetric-enum">QStyle::PM_LayoutTopMargin</a>, <a href="qstyle.html#PixelMetric-enum">QStyle::PM_LayoutRightMargin</a> and <a href="qstyle.html#PixelMetric-enum">QStyle::PM_LayoutBottomMargin</a>).</p>
<p>For sublayouts the default margins are 0.</p>
<p>Changing the contents margins automatically invalidates the layout.</p>
<p><b>See also </b><a href="qgraphicslayout.html#invalidate">invalidate</a>().</p>
<!-- @@@setContentsMargins -->
<!-- $$$updateGeometry[overload1]$$$updateGeometry -->
<h3 class="fn"><a name="updateGeometry"></a><span class="type">void</span> QGraphicsLayout::<span class="name">updateGeometry</span> ()<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qgraphicslayoutitem.html#updateGeometry">QGraphicsLayoutItem::updateGeometry</a>().</p>
<!-- @@@updateGeometry -->
<!-- $$$widgetEvent[overload1]$$$widgetEventQEvent* -->
<h3 class="fn"><a name="widgetEvent"></a><span class="type">void</span> QGraphicsLayout::<span class="name">widgetEvent</span> ( <span class="type"><a href="qevent.html">QEvent</a></span> * <i>e</i> )<tt> [virtual]</tt></h3>
<p>This virtual event handler receives all events for the managed widget. <a href="qgraphicslayout.html">QGraphicsLayout</a> uses this event handler to listen for layout related events such as geometry changes, layout changes or layout direction changes.</p>
<p><i>e</i> is a pointer to the event.</p>
<p>You can reimplement this event handler to track similar events for your own custom layout.</p>
<p><b>See also </b><a href="qgraphicswidget.html#event">QGraphicsWidget::event</a>() and <a href="qgraphicsitem.html#sceneEvent">QGraphicsItem::sceneEvent</a>().</p>
<!-- @@@widgetEvent -->
</div>
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
