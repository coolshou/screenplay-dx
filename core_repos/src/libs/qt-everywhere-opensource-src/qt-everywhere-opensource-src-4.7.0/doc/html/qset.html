<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qset.qdoc -->
  <title>Qt 4.7: QSet Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="qtcore.html">QtCore</a></li>
              <li>QSet</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QSet Class Reference</h1>
<!-- $$$QSet-brief -->
<p>The QSet class is a template class that provides a hash-table-based set. <a href="#details">More...</a></p>
<!-- @@@QSet -->
<pre class="highlightedCode brush: cpp"> #include &lt;QSet&gt;</pre><p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html#reentrant">reentrant</a>.</p>
<ul>
<li><a href="qset-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qset-const-iterator.html">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qset-iterator.html">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#ConstIterator-typedef">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#Iterator-typedef">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_pointer-typedef">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#const_reference-typedef">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#difference_type-typedef">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#key_type-typedef">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#pointer-typedef">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reference-typedef">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#size_type-typedef">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qset.html#value_type-typedef">value_type</a></b></td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet">QSet</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qset.html#QSet-2">QSet</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#begin">begin</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#begin-2">begin</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qset.html#capacity">capacity</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#clear">clear</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constBegin">constBegin</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constEnd">constEnd</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#constFind">constFind</a></b> ( const T &amp; <i>value</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#contains">contains</a></b> ( const T &amp; <i>value</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#contains-2">contains</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qset.html#count">count</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#empty">empty</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#end">end</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#end-2">end</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#erase">erase</a></b> ( iterator <i>pos</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#find">find</a></b> ( const T &amp; <i>value</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#find-2">find</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qset.html#insert">insert</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#intersect">intersect</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#isEmpty">isEmpty</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#remove">remove</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#reserve">reserve</a></b> ( int <i>size</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qset.html#size">size</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qset.html#squeeze">squeeze</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#subtract">subtract</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#toList">toList</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#unite">unite</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#values">values</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-not-eq">operator!=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and">operator&amp;</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-eq">operator&amp;=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-and-eq-2">operator&amp;=</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b">operator+</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-eq">operator+=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-2b-eq-2">operator+=</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-">operator-</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--eq">operator-=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator--eq-2">operator-=</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-lt-lt">operator&lt;&lt;</a></b> ( const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-eq">operator=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-eq-eq">operator==</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c">operator|</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-eq">operator|=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-7c-eq-2">operator|=</a></b> ( const T &amp; <i>value</i> )</td></tr>
</table>
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QSet&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#fromList">fromList</a></b> ( const QList&lt;T&gt; &amp; <i>list</i> )</td></tr>
</table>
<a name="related-non-members"></a>
<h2>Related Non-Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-lt-lt-88">operator&lt;&lt;</a></b> ( QDataStream &amp; <i>out</i>, const QSet&lt;T&gt; &amp; <i>set</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp; </td><td class="memItemRight bottomAlign"><b><a href="qset.html#operator-gt-gt-52">operator&gt;&gt;</a></b> ( QDataStream &amp; <i>in</i>, QSet&lt;T&gt; &amp; <i>set</i> )</td></tr>
</table>
<a name="details"></a>
<!-- $$$QSet-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QSet class is a template class that provides a hash-table-based set.</p>
<p>QSet&lt;T&gt; is one of Qt's generic <a href="containers.html#container-classes">container classes</a>. It stores values in an unspecified order and provides very fast lookup of the values. Internally, QSet&lt;T&gt; is implemented as a <a href="qhash.html">QHash</a>.</p>
<p>Here's an example QSet with <a href="qstring.html">QString</a> values:</p>
<pre class="highlightedCode brush: cpp"> QSet&lt;QString&gt; set;</pre>
<p>To insert a value into the set, use <a href="qset.html#insert">insert</a>():</p>
<pre class="highlightedCode brush: cpp"> set.insert(&quot;one&quot;);
 set.insert(&quot;three&quot;);
 set.insert(&quot;seven&quot;);</pre>
<p>Another way to insert items into the set is to use operator&lt;&lt;():</p>
<pre class="highlightedCode brush: cpp"> set &lt;&lt; &quot;twelve&quot; &lt;&lt; &quot;fifteen&quot; &lt;&lt; &quot;nineteen&quot;;</pre>
<p>To test whether an item belongs to the set or not, use <a href="qset.html#contains">contains</a>():</p>
<pre class="highlightedCode brush: cpp"> if (!set.contains(&quot;ninety-nine&quot;))
     ...</pre>
<p>If you want to navigate through all the values stored in a QSet, you can use an iterator. QSet supports both <a href="containers.html#java-style-iterators">Java-style iterators</a> (<a href="qsetiterator.html">QSetIterator</a> and <a href="qmutablesetiterator.html">QMutableSetIterator</a>) and <a href="containers.html#stl-style-iterators">STL-style iterators</a> (<a href="qset-iterator.html">QSet::iterator</a> and <a href="qset-const-iterator.html">QSet::const_iterator</a>). Here's how to iterate over a QSet&lt;<a href="qwidget.html">QWidget</a> *&gt; using a Java-style iterator:</p>
<pre class="highlightedCode brush: cpp"> QSetIterator&lt;QWidget *&gt; i(set);
 while (i.hasNext())
     qDebug() &lt;&lt; i.next();</pre>
<p>Here's the same code, but using an STL-style iterator:</p>
<pre class="highlightedCode brush: cpp"> QSet&lt;QWidget *&gt;::const_iterator i = set.constBegin();
 while (i != set.constEnd()) {
     qDebug() &lt;&lt; *i;
     ++i;
 }</pre>
<p>QSet is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <a href="qmap.html">QMap</a>.</p>
<p>To navigate through a QSet, you can also use <a href="containers.html#foreach">foreach</a>:</p>
<pre class="highlightedCode brush: cpp"> QSet&lt;QString&gt; set;
 ...
 foreach (QString value, set)
     qDebug() &lt;&lt; value;</pre>
<p>Items can be removed from the set using <a href="qset.html#remove">remove</a>(). There is also a <a href="qset.html#clear">clear</a>() function that removes all items.</p>
<p>QSet's value data type must be an <a href="containers.html#assignable-data-type">assignable data type</a>. You cannot, for example, store a <a href="qwidget.html">QWidget</a> as a value; instead, store a <a href="qwidget.html">QWidget</a> *. In addition, the type must provide <tt>operator==()</tt>, and there must also be a global <a href="qhash.html#qHashx">qHash</a>() function that returns a hash value for an argument of the key's type. See the <a href="qhash.html">QHash</a> documentation for a list of types supported by <a href="qhash.html#qHashx">qHash</a>().</p>
<p>Internally, QSet uses a hash table to perform lookups. The hash table automatically grows and shrinks to provide fast lookups without wasting memory. You can still control the size of the hash table by calling <a href="qset.html#reserve">reserve</a>(), if you already know approximately how many elements the QSet will contain, but this isn't necessary to obtain good performance. You can also call <a href="qset.html#capacity">capacity</a>() to retrieve the hash table's size.</p>
</div>
<p>See also <a href="qsetiterator.html">QSetIterator</a>, <a href="qmutablesetiterator.html">QMutableSetIterator</a>, <a href="qhash.html">QHash</a>, and <a href="qmap.html">QMap</a>.</p>
<!-- @@@QSet -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn"><a name="ConstIterator-typedef"></a>typedef QSet::ConstIterator</h3>
<p>Qt-style synonym for <a href="qset-const-iterator.html">QSet::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn"><a name="Iterator-typedef"></a>typedef QSet::Iterator</h3>
<p>Qt-style synonym for <a href="qset-iterator.html">QSet::iterator</a>.</p>
<p>This typedef was introduced in Qt 4.2.</p>
<!-- @@@Iterator -->
<!-- $$$const_pointer -->
<h3 class="fn"><a name="const_pointer-typedef"></a>typedef QSet::const_pointer</h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn"><a name="const_reference-typedef"></a>typedef QSet::const_reference</h3>
<p>Typedef for const T &amp;. Provided for STL compatibility.</p>
<!-- @@@const_reference -->
<!-- $$$difference_type -->
<h3 class="fn"><a name="difference_type-typedef"></a>typedef QSet::difference_type</h3>
<p>Typedef for const ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$key_type -->
<h3 class="fn"><a name="key_type-typedef"></a>typedef QSet::key_type</h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@key_type -->
<!-- $$$pointer -->
<h3 class="fn"><a name="pointer-typedef"></a>typedef QSet::pointer</h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn"><a name="reference-typedef"></a>typedef QSet::reference</h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<!-- @@@reference -->
<!-- $$$size_type -->
<h3 class="fn"><a name="size_type-typedef"></a>typedef QSet::size_type</h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn"><a name="value_type-typedef"></a>typedef QSet::value_type</h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSet[overload1]$$$QSet -->
<h3 class="fn"><a name="QSet"></a>QSet::QSet ()</h3>
<p>Constructs an empty set.</p>
<p>See also <a href="qset.html#clear">clear</a>().</p>
<!-- @@@QSet -->
<!-- $$$QSet$$$QSetconstQSet<T>& -->
<h3 class="fn"><a name="QSet-2"></a>QSet::QSet ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation occurs in <a href="containers.html#constant-time">constant time</a>, because <a href="qset.html">QSet</a> is <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>. This makes returning a <a href="qset.html">QSet</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <a href="containers.html#linear-time">linear time</a>.</p>
<p>See also <a href="qset.html#operator-eq">operator=</a>().</p>
<!-- @@@QSet -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn"><a name="begin"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::begin () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> positioned at the first item in the set.</p>
<p>See also <a href="qset.html#constBegin">constBegin</a>() and <a href="qset.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn"><a name="begin-2"></a><a href="qset-iterator.html">iterator</a> QSet::begin ()</h3>
<p>This is an overloaded function.</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators">STL-style iterator</a> positioned at the first item in the set.</p>
<p>This function was introduced in Qt 4.2.</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn"><a name="capacity"></a>int QSet::capacity () const</h3>
<p>Returns the number of buckets in the set's internal hash table.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html">QSet</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the set, call <a href="qset.html#size">size</a>().</p>
<p>See also <a href="qset.html#reserve">reserve</a>() and <a href="qset.html#squeeze">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn"><a name="clear"></a>void QSet::clear ()</h3>
<p>Removes all elements from the set.</p>
<p>See also <a href="qset.html#remove">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn"><a name="constBegin"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::constBegin () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> positioned at the first item in the set.</p>
<p>See also <a href="qset.html#begin">begin</a>() and <a href="qset.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn"><a name="constEnd"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::constEnd () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p>See also <a href="qset.html#constBegin">constBegin</a>() and <a href="qset.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindconstT& -->
<h3 class="fn"><a name="constFind"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::constFind ( const T &amp; <i>value</i> ) const</h3>
<p>Returns a const iterator positioned at the item <i>value</i> in the set. If the set contains no item <i>value</i>, the function returns <a href="qset.html#constEnd">constEnd</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qset.html#find">find</a>() and <a href="qset.html#contains">contains</a>().</p>
<!-- @@@constFind -->
<!-- $$$contains[overload1]$$$containsconstT& -->
<h3 class="fn"><a name="contains"></a>bool QSet::contains ( const T &amp; <i>value</i> ) const</h3>
<p>Returns true if the set contains item <i>value</i>; otherwise returns false.</p>
<p>See also <a href="qset.html#insert">insert</a>(), <a href="qset.html#remove">remove</a>(), and <a href="qset.html#find">find</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQSet<T>& -->
<h3 class="fn"><a name="contains-2"></a>bool QSet::contains ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if the set contains all items from the <i>other</i> set; otherwise returns false.</p>
<p>This function was introduced in Qt 4.6.</p>
<p>See also <a href="qset.html#insert">insert</a>(), <a href="qset.html#remove">remove</a>(), and <a href="qset.html#find">find</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$count -->
<h3 class="fn"><a name="count"></a>int QSet::count () const</h3>
<p>Same as <a href="qset.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn"><a name="empty"></a>bool QSet::empty () const</h3>
<p>Returns true if the set is empty. This function is provided for STL compatibility. It is equivalent to <a href="qset.html#isEmpty">isEmpty</a>().</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn"><a name="end"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::end () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> positioned at the imaginary item after the last item in the set.</p>
<p>See also <a href="qset.html#constEnd">constEnd</a>() and <a href="qset.html#begin">begin</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn"><a name="end-2"></a><a href="qset-iterator.html">iterator</a> QSet::end ()</h3>
<p>This is an overloaded function.</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p>This function was introduced in Qt 4.2.</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseiterator -->
<h3 class="fn"><a name="erase"></a><a href="qset-iterator.html">iterator</a> QSet::erase ( <a href="qset-iterator.html">iterator</a> <i>pos</i> )</h3>
<p>Removes the item at the iterator position <i>pos</i> from the set, and returns an iterator positioned at the next item in the set.</p>
<p>Unlike <a href="qset.html#remove">remove</a>(), this function never causes <a href="qset.html">QSet</a> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the set.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qset.html#remove">remove</a>() and <a href="qset.html#find">find</a>().</p>
<!-- @@@erase -->
<!-- $$$find[overload1]$$$findconstT& -->
<h3 class="fn"><a name="find"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::find ( const T &amp; <i>value</i> ) const</h3>
<p>Returns a const iterator positioned at the item <i>value</i> in the set. If the set contains no item <i>value</i>, the function returns <a href="qset.html#constEnd">constEnd</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qset.html#constFind">constFind</a>() and <a href="qset.html#contains">contains</a>().</p>
<!-- @@@find -->
<!-- $$$find$$$findconstT& -->
<h3 class="fn"><a name="find-2"></a><a href="qset-iterator.html">iterator</a> QSet::find ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>Returns a non-const iterator positioned at the item <i>value</i> in the set. If the set contains no item <i>value</i>, the function returns <a href="qset.html#end">end</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<!-- @@@find -->
<!-- $$$fromList[overload1]$$$fromListconstQList<T>& -->
<h3 class="fn"><a name="fromList"></a>QSet&lt;T&gt; QSet::fromList ( const <a href="qlist.html">QList</a>&lt;T&gt; &amp; <i>list</i> )<tt> [static]</tt></h3>
<p>Returns a new <a href="qset.html">QSet</a> object containing the data contained in <i>list</i>. Since <a href="qset.html">QSet</a> doesn't allow duplicates, the resulting <a href="qset.html">QSet</a> might be smaller than the <i>list</i>, because <a href="qlist.html">QList</a> can contain duplicates.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QStringList list;
 list &lt;&lt; &quot;Julia&quot; &lt;&lt; &quot;Mike&quot; &lt;&lt; &quot;Mike&quot; &lt;&lt; &quot;Julia&quot; &lt;&lt; &quot;Julia&quot;;

 QSet&lt;QString&gt; set = QSet&lt;QString&gt;::fromList(list);
 set.contains(&quot;Julia&quot;);  // returns true
 set.contains(&quot;Mike&quot;);   // returns true
 set.size();             // returns 2</pre>
<p>See also <a href="qset.html#toList">toList</a>() and <a href="qlist.html#toSet">QList::toSet</a>().</p>
<!-- @@@fromList -->
<!-- $$$insert[overload1]$$$insertconstT& -->
<h3 class="fn"><a name="insert"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::insert ( const T &amp; <i>value</i> )</h3>
<p>Inserts item <i>value</i> into the set, if <i>value</i> isn't already in the set, and returns an iterator pointing at the inserted item.</p>
<p>See also <a href="qset.html#operator-lt-lt">operator&lt;&lt;</a>(), <a href="qset.html#remove">remove</a>(), and <a href="qset.html#contains">contains</a>().</p>
<!-- @@@insert -->
<!-- $$$intersect[overload1]$$$intersectconstQSet<T>& -->
<h3 class="fn"><a name="intersect"></a>QSet&lt;T&gt; &amp; QSet::intersect ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Removes all items from this set that are not contained in the <i>other</i> set. A reference to this set is returned.</p>
<p>See also <a href="qset.html#operator-and-eq">operator&amp;=</a>(), <a href="qset.html#unite">unite</a>(), and <a href="qset.html#subtract">subtract</a>().</p>
<!-- @@@intersect -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn"><a name="isEmpty"></a>bool QSet::isEmpty () const</h3>
<p>Returns true if the set contains no elements; otherwise returns false.</p>
<p>See also <a href="qset.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$remove[overload1]$$$removeconstT& -->
<h3 class="fn"><a name="remove"></a>bool QSet::remove ( const T &amp; <i>value</i> )</h3>
<p>Removes any occurrence of item <i>value</i> from the set. Returns true if an item was actually removed; otherwise returns false.</p>
<p>See also <a href="qset.html#contains">contains</a>() and <a href="qset.html#insert">insert</a>().</p>
<!-- @@@remove -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn"><a name="reserve"></a>void QSet::reserve ( int <i>size</i> )</h3>
<p>Ensures that the set's internal hash table consists of at least <i>size</i> buckets.</p>
<p>This function is useful for code that needs to build a huge set and wants to avoid repeated reallocation. For example:</p>
<pre class="highlightedCode brush: cpp"> QSet&lt;QString&gt; set;
 set.reserve(20000);
 for (int i = 0; i &lt; 20000; ++i)
     set.insert(values[i]);</pre>
<p>Ideally, <i>size</i> should be slightly more than the maximum number of elements expected in the set. <i>size</i> doesn't have to be prime, because <a href="qset.html">QSet</a> will use a prime number internally anyway. If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qset.html">QSet</a> will be a bit slower.</p>
<p>In general, you will rarely ever need to call this function. <a href="qset.html">QSet</a>'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</p>
<p>See also <a href="qset.html#squeeze">squeeze</a>() and <a href="qset.html#capacity">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn"><a name="size"></a>int QSet::size () const</h3>
<p>Returns the number of items in the set.</p>
<p>See also <a href="qset.html#isEmpty">isEmpty</a>() and <a href="qset.html#count">count</a>().</p>
<!-- @@@size -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn"><a name="squeeze"></a>void QSet::squeeze ()</h3>
<p>Reduces the size of the set's internal hash table to save memory.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html">QSet</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p>See also <a href="qset.html#reserve">reserve</a>() and <a href="qset.html#capacity">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$subtract[overload1]$$$subtractconstQSet<T>& -->
<h3 class="fn"><a name="subtract"></a>QSet&lt;T&gt; &amp; QSet::subtract ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Removes all items from this set that are contained in the <i>other</i> set. Returns a reference to this set.</p>
<p>See also <a href="qset.html#operator--eq">operator-=</a>(), <a href="qset.html#unite">unite</a>(), and <a href="qset.html#intersect">intersect</a>().</p>
<!-- @@@subtract -->
<!-- $$$toList[overload1]$$$toList -->
<h3 class="fn"><a name="toList"></a><a href="qlist.html">QList</a>&lt;T&gt; QSet::toList () const</h3>
<p>Returns a new <a href="qlist.html">QList</a> containing the elements in the set. The order of the elements in the <a href="qlist.html">QList</a> is undefined.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QSet&lt;QString&gt; set;
 set &lt;&lt; &quot;red&quot; &lt;&lt; &quot;green&quot; &lt;&lt; &quot;blue&quot; &lt;&lt; ... &lt;&lt; &quot;black&quot;;

 QList&lt;QString&gt; list = set.toList();
 qSort(list);</pre>
<p>See also <a href="qset.html#fromList">fromList</a>(), <a href="qlist.html#fromSet">QList::fromSet</a>(), and <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<!-- @@@toList -->
<!-- $$$unite[overload1]$$$uniteconstQSet<T>& -->
<h3 class="fn"><a name="unite"></a>QSet&lt;T&gt; &amp; QSet::unite ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Each item in the <i>other</i> set that isn't already in this set is inserted into this set. A reference to this set is returned.</p>
<p>See also <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#intersect">intersect</a>(), and <a href="qset.html#subtract">subtract</a>().</p>
<!-- @@@unite -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn"><a name="values"></a><a href="qlist.html">QList</a>&lt;T&gt; QSet::values () const</h3>
<p>Returns a new <a href="qlist.html">QList</a> containing the elements in the set. The order of the elements in the <a href="qlist.html">QList</a> is undefined.</p>
<p>This is the same as <a href="qset.html#toList">toList</a>().</p>
<p>See also <a href="qset.html#fromList">fromList</a>(), <a href="qlist.html#fromSet">QList::fromSet</a>(), and <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<!-- @@@values -->
<!-- $$$operator!=[overload1]$$$operator!=constQSet<T>& -->
<h3 class="fn"><a name="operator-not-eq"></a>bool QSet::operator!= ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if the <i>other</i> set is not equal to this set; otherwise returns false.</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>This function requires the value type to implement <tt>operator==()</tt>.</p>
<p>See also <a href="qset.html#operator-eq-eq">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator&[overload1]$$$operator&constQSet<T>& -->
<h3 class="fn"><a name="operator-and"></a>QSet&lt;T&gt; QSet::operator&amp; ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns a new <a href="qset.html">QSet</a> that is the intersection of this set and the <i>other</i> set.</p>
<p>See also <a href="qset.html#intersect">intersect</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), <a href="qset.html#operator-7c">operator|</a>(), and <a href="qset.html#operator-">operator-</a>().</p>
<!-- @@@operator& -->
<!-- $$$operator&=[overload1]$$$operator&=constQSet<T>& -->
<h3 class="fn"><a name="operator-and-eq"></a>QSet&lt;T&gt; &amp; QSet::operator&amp;= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Same as intersect(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-and">operator&amp;</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), and <a href="qset.html#operator--eq">operator-=</a>().</p>
<!-- @@@operator&= -->
<!-- $$$operator&=$$$operator&=constT& -->
<h3 class="fn"><a name="operator-and-eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator&amp;= ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded function.</p>
<p>Same as intersect(<i>other</i>), if we consider <i>other</i> to be a set that contains the singleton <i>value</i>.</p>
<!-- @@@operator&= -->
<!-- $$$operator+[overload1]$$$operator+constQSet<T>& -->
<h3 class="fn"><a name="operator-2b"></a>QSet&lt;T&gt; QSet::operator+ ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns a new <a href="qset.html">QSet</a> that is the union of this set and the <i>other</i> set.</p>
<p>See also <a href="qset.html#unite">unite</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#operator-and">operator&amp;</a>(), and <a href="qset.html#operator-">operator-</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=constQSet<T>& -->
<h3 class="fn"><a name="operator-2b-eq"></a>QSet&lt;T&gt; &amp; QSet::operator+= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Same as unite(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-7c">operator|</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), and <a href="qset.html#operator--eq">operator-=</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constT& -->
<h3 class="fn"><a name="operator-2b-eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator+= ( const T &amp; <i>value</i> )</h3>
<p>Inserts a new item <i>value</i> and returns a reference to the set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#insert">insert</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator-[overload1]$$$operator-constQSet<T>& -->
<h3 class="fn"><a name="operator-"></a>QSet&lt;T&gt; QSet::operator- ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns a new <a href="qset.html">QSet</a> that is the set difference of this set and the <i>other</i> set, i.e&#x2e;, this set - <i>other</i> set.</p>
<p>See also <a href="qset.html#subtract">subtract</a>(), <a href="qset.html#operator--eq">operator-=</a>(), <a href="qset.html#operator-7c">operator|</a>(), and <a href="qset.html#operator-and">operator&amp;</a>().</p>
<!-- @@@operator- -->
<!-- $$$operator-=[overload1]$$$operator-=constQSet<T>& -->
<h3 class="fn"><a name="operator--eq"></a>QSet&lt;T&gt; &amp; QSet::operator-= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Same as subtract(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-">operator-</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), and <a href="qset.html#operator-and-eq">operator&amp;=</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator-=$$$operator-=constT& -->
<h3 class="fn"><a name="operator--eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator-= ( const T &amp; <i>value</i> )</h3>
<p>Removes the occurrence of item <i>value</i> from the set, if it is found, and returns a reference to the set. If the <i>value</i> is not contained the set, nothing is removed.</p>
<p>See also <a href="qset.html#remove">remove</a>().</p>
<!-- @@@operator-= -->
<!-- $$$operator<<[overload1]$$$operator<<constT& -->
<h3 class="fn"><a name="operator-lt-lt"></a>QSet&lt;T&gt; &amp; QSet::operator&lt;&lt; ( const T &amp; <i>value</i> )</h3>
<p>Inserts a new item <i>value</i> and returns a reference to the set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#insert">insert</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator=[overload1]$$$operator=constQSet<T>& -->
<h3 class="fn"><a name="operator-eq"></a>QSet&lt;T&gt; &amp; QSet::operator= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Assigns the <i>other</i> set to this set and returns a reference to this set.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQSet<T>& -->
<h3 class="fn"><a name="operator-eq-eq"></a>bool QSet::operator== ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if the <i>other</i> set is equal to this set; otherwise returns false.</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>This function requires the value type to implement <tt>operator==()</tt>.</p>
<p>See also <a href="qset.html#operator-not-eq">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator|[overload1]$$$operator|constQSet<T>& -->
<h3 class="fn"><a name="operator-7c"></a>QSet&lt;T&gt; QSet::operator| ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns a new <a href="qset.html">QSet</a> that is the union of this set and the <i>other</i> set.</p>
<p>See also <a href="qset.html#unite">unite</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#operator-and">operator&amp;</a>(), and <a href="qset.html#operator-">operator-</a>().</p>
<!-- @@@operator| -->
<!-- $$$operator|=[overload1]$$$operator|=constQSet<T>& -->
<h3 class="fn"><a name="operator-7c-eq"></a>QSet&lt;T&gt; &amp; QSet::operator|= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Same as unite(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-7c">operator|</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), and <a href="qset.html#operator--eq">operator-=</a>().</p>
<!-- @@@operator|= -->
<!-- $$$operator|=$$$operator|=constT& -->
<h3 class="fn"><a name="operator-7c-eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator|= ( const T &amp; <i>value</i> )</h3>
<p>Inserts a new item <i>value</i> and returns a reference to the set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#insert">insert</a>().</p>
<!-- @@@operator|= -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$operator<<$$$operator<<QDataStream&constQSet<T>& -->
<h3 class="fn"><a name="operator-lt-lt-88"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>out</i>, const QSet&lt;T&gt; &amp; <i>set</i> )</h3>
<p>Writes the <i>set</i> to stream <i>out</i>.</p>
<p>This function requires the value type to implement <tt>operator&lt;&lt;()</tt>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>$$$operator>>QDataStream&QSet<T>& -->
<h3 class="fn"><a name="operator-gt-gt-52"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>in</i>, QSet&lt;T&gt; &amp; <i>set</i> )</h3>
<p>Reads a set from stream <i>in</i> into <i>set</i>.</p>
<p>This function requires the value type to implement <tt>operator&gt;&gt;()</tt>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.</p>
<!-- @@@operator>> -->
</div>
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
