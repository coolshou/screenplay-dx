<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qimage.cpp -->
  <title>Qt 4.7: Qt 3 Support Members for QImage</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
<li><a href="modules.html">Modules</a></li>
<li><a href="qtgui.html">QtGui</a></li>
<li>QImage</li>
    </ul>
  </div>
</div>
<div class="content mainContent">
<h1 class="title">Qt 3 Support Members for QImage</h1>
<p><b>The following class members are part of the <a href="qt3support.html">Qt 3 support layer</a>.</b> They are provided to help you port old code to Qt 4. We advise against using them in new code.</p>
<p><ul><li><a href="qimage.html">QImage class reference</a></li></ul></p>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#Endian-enum">Endian</a></b> { IgnoreEndian, BigEndian, LittleEndian }</td></tr>
</table>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-12">QImage</a></b> ( int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-13">QImage</a></b> ( const QSize &amp; <i>size</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-14">QImage</a></b> ( uchar * <i>data</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, const QRgb * <i>colortable</i>, int <i>numColors</i>, Endian <i>bitOrder</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-15">QImage</a></b> ( uchar * <i>data</i>, int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>bytesPerLine</i>, const QRgb * <i>colortable</i>, int <i>numColors</i>, Endian <i>bitOrder</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#QImage-16">QImage</a></b> ( const QByteArray &amp; <i>data</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Endian </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#bitOrder">bitOrder</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#convertBitOrder">convertBitOrder</a></b> ( Endian <i>bitOrder</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#convertDepth">convertDepth</a></b> ( int <i>depth</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#convertDepthWithPalette">convertDepthWithPalette</a></b> ( int <i>depth</i>, QRgb * <i>palette</i>, int <i>palette_count</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#copy-2">copy</a></b> ( int <i>x</i>, int <i>y</i>, int <i>w</i>, int <i>h</i>, Qt::ImageConversionFlags <i>flags</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#copy-3">copy</a></b> ( const QRect &amp; <i>rect</i>, Qt::ImageConversionFlags <i>flags</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#create">create</a></b> ( int <i>width</i>, int <i>height</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#create-2">create</a></b> ( const QSize &amp; <i>size</i>, int <i>depth</i>, int <i>numColors</i> = 0, Endian <i>bitOrder</i> = IgnoreEndian )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#hasAlphaBuffer">hasAlphaBuffer</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#invertPixels-2">invertPixels</a></b> ( bool <i>invertAlpha</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> uchar ** </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#jumpTable">jumpTable</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> const uchar * const * </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#jumpTable-2">jumpTable</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#mirror">mirror</a></b> ( bool <i>horizontal</i> = false, bool <i>vertical</i> = true ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#numBytes">numBytes</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#numColors">numColors</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#reset">reset</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#scaleHeight">scaleHeight</a></b> ( int <i>h</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#scaleWidth">scaleWidth</a></b> ( int <i>w</i> ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#setAlphaBuffer">setAlphaBuffer</a></b> ( bool <i>enable</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#setNumColors">setNumColors</a></b> ( int <i>numColors</i> )</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#smoothScale">smoothScale</a></b> ( int <i>width</i>, int <i>height</i>, Qt::AspectRatioMode <i>mode</i> = Qt::IgnoreAspectRatio ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#smoothScale-2">smoothScale</a></b> ( const QSize &amp; <i>size</i>, Qt::AspectRatioMode <i>mode</i> = Qt::IgnoreAspectRatio ) const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#swapRGB">swapRGB</a></b> () const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#xForm">xForm</a></b> ( const QMatrix &amp; <i>matrix</i> ) const</td></tr>
</table>
<ul>
<li class="fn">8 public functions inherited from <a href="qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Endian </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#systemBitOrder">systemBitOrder</a></b> ()</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> Endian </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#systemByteOrder">systemByteOrder</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">13 static public members inherited from <a href="qpaintdevice.html#static-public-members">QPaintDevice</a></li>
</ul>
<h2>Related Non-Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qimage-qt3.html#bitBlt">bitBlt</a></b> ( QImage * <i>dst</i>, int <i>dx</i>, int <i>dy</i>, const QImage * <i>src</i>, int <i>sx</i> = 0, int <i>sy</i> = 0, int <i>sw</i> = -1, int <i>sh</i> = -1, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor )</td></tr>
</table>
<h2>Member Type Documentation</h2>
<!-- $$$Endian$$$BigEndian$$$LittleEndian$$$IgnoreEndian -->
<h3 class="fn"><a name="Endian-enum"></a>enum QImage::<span class="name">Endian</span></h3>
<p>This enum type is used to describe the endianness of the CPU and graphics hardware. It is provided here for compatibility with earlier versions of Qt.</p>
<p>Use the <a href="qimage.html#Format-enum">Format</a> enum instead. The <a href="qimage.html#Format-enum">Format</a> enum specify the endianess for monchrome formats, but for other formats the endianess is not relevant.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QImage::IgnoreEndian</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">Endianness does not matter. Useful for some operations that are independent of endianness.</td></tr>
<tr><td class="topAlign"><tt>QImage::BigEndian</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">Most significant bit first or network byte order, as on SPARC, PowerPC, and Motorola CPUs.</td></tr>
<tr><td class="topAlign"><tt>QImage::LittleEndian</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign">Least significant bit first or little endian byte order, as on Intel x86.</td></tr>
</table>
<!-- @@@Endian -->
<h2>Member Function Documentation</h2>
<!-- $$$QImage$$$QImageintintintintEndian -->
<h3 class="fn"><a name="QImage-12"></a>QImage::<span class="name">QImage</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>Constructs an image with the given <i>width</i>, <i>height</i>, <i>depth</i>, <i>numColors</i> colors and <i>bitOrder</i>.</p>
<p>Use the constructor that accepts a width, a height and a format (i.e&#x2e; specifying the depth and bit order), in combination with the <a href="qimage.html#setColorCount">setColorCount</a>() function, instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image(width, height, depth, numColors);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image(width<span class="operator">,</span> height<span class="operator">,</span> format);

 <span class="comment">// For 8 bit images the default number of colors is 256. If</span>
 <span class="comment">// another number of colors is required it can be specified</span>
 <span class="comment">// using the setColorCount() function.</span>
 image<span class="operator">.</span><a href="qimage.html#setColorCount">setColorCount</a>(numColors);</pre>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageconstQSize&intintEndian -->
<h3 class="fn"><a name="QImage-13"></a>QImage::<span class="name">QImage</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>Constructs an image with the given <i>size</i>, <i>depth</i>, <i>numColors</i> and <i>bitOrder</i>.</p>
<p>Use the constructor that accepts a size and a format (i.e&#x2e; specifying the depth and bit order), in combination with the <a href="qimage.html#setColorCount">setColorCount</a>() function, instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QSize mySize(width, height);
 QImage image(mySize, depth, numColors);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qsize.html">QSize</a></span> mySize(width<span class="operator">,</span> height);
 <span class="type"><a href="qimage.html">QImage</a></span> image(mySize<span class="operator">,</span> format);

 <span class="comment">// For 8 bit images the default number of colors is 256. If</span>
 <span class="comment">// another number of colors is required it can be specified</span>
 <span class="comment">// using the setColorCount() function.</span>
 image<span class="operator">.</span><a href="qimage.html#setColorCount">setColorCount</a>(numColors);</pre>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageuchar*intintintconstQRgb*intEndian -->
<h3 class="fn"><a name="QImage-14"></a>QImage::<span class="name">QImage</span> ( <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * <i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, const <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * <i>colortable</i>, <span class="type">int</span> <i>numColors</i>, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> )</h3>
<p>Constructs an image with the given <i>width</i>, <i>height</i>, depth, <i>colortable</i>, <i>numColors</i> and <i>bitOrder</i>, that uses an existing memory buffer, <i>data</i>.</p>
<p>Use the constructor that accepts a uchar pointer, a width, a height and a format (i.e&#x2e; specifying the depth and bit order), in combination with the <a href="qimage.html#setColorTable">setColorTable</a>() function, instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> uchar *myData;
 QRgb *myColorTable;

 QImage image(myData, width, height, depth,
                        myColorTable, numColors, IgnoreEndian);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> <span class="operator">*</span>myData;
 <span class="type"><a href="qvector.html">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span><span class="operator">&gt;</span> myColorTable;

 <span class="type"><a href="qimage.html">QImage</a></span> image(myData<span class="operator">,</span> width<span class="operator">,</span> height<span class="operator">,</span> format);
 image<span class="operator">.</span><a href="qimage.html#setColorTable">setColorTable</a>(myColorTable);</pre>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageuchar*intintintintconstQRgb*intEndian -->
<h3 class="fn"><a name="QImage-15"></a>QImage::<span class="name">QImage</span> ( <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * <i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>bytesPerLine</i>, const <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * <i>colortable</i>, <span class="type">int</span> <i>numColors</i>, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> )</h3>
<p>Constructs an image with the given <i>width</i>, <i>height</i>, <i>depth</i>, <i>bytesPerLine</i>, <i>colortable</i>, <i>numColors</i> and <i>bitOrder</i>, that uses an existing memory buffer, <i>data</i>. The image does not delete the buffer at destruction.</p>
<p><b>Warning:</b> This constructor is only available in Qt for Embedded Linux.</p>
<p>The data has to be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned, so it's no longer possible to specify a custom <i>bytesPerLine</i> value.</p>
<!-- @@@QImage -->
<!-- $$$QImage$$$QImageconstQByteArray& -->
<h3 class="fn"><a name="QImage-16"></a>QImage::<span class="name">QImage</span> ( const <span class="type"><a href="qbytearray.html">QByteArray</a></span> &amp; <i>data</i> )</h3>
<p>Use the static <a href="qimage.html#fromData">fromData</a>() function instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QByteArray data;
 ..&#x2e;
 QImage image(data);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qbytearray.html">QByteArray</a></span> data;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 <span class="type"><a href="qimage.html">QImage</a></span> image <span class="operator">=</span> <span class="type"><a href="qimage.html">QImage</a></span><span class="operator">::</span><a href="qimage.html#fromData">fromData</a>(data);</pre>
<!-- @@@QImage -->
<!-- $$$bitOrder[overload1]$$$bitOrder -->
<h3 class="fn"><a name="bitOrder"></a><span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> QImage::<span class="name">bitOrder</span> () const</h3>
<p>Returns the bit order for the image. If it is a 1-bpp image, this function returns either <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a> or <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a>. Otherwise, this function returns <a href="qimage-qt3.html#Endian-enum">QImage::IgnoreEndian</a>.</p>
<p>Use the <a href="qimage.html#format">format</a>() function instead for the monochrome formats. For non-monochrome formats the bit order is irrelevant.</p>
<!-- @@@bitOrder -->
<!-- $$$convertBitOrder[overload1]$$$convertBitOrderEndian -->
<h3 class="fn"><a name="convertBitOrder"></a><span class="type">QImage</span> QImage::<span class="name">convertBitOrder</span> ( <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> ) const</h3>
<p>Converts the bit order of the image to the given <i>bitOrder</i> and returns the converted image. The original image is not changed. Returns this image if the given <i>bitOrder</i> is equal to the image current bit order, or a null image if this image cannot be converted.</p>
<p>Use <a href="qimage.html#convertToFormat">convertToFormat</a>() instead.</p>
<!-- @@@convertBitOrder -->
<!-- $$$convertDepth[overload1]$$$convertDepthintQt::ImageConversionFlags -->
<h3 class="fn"><a name="convertDepth"></a><span class="type">QImage</span> QImage::<span class="name">convertDepth</span> ( <span class="type">int</span> <i>depth</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor ) const</h3>
<p>Converts the depth (bpp) of the image to the given <i>depth</i> and returns the converted image. The original image is not changed. Returns this image if <i>depth</i> is equal to the image depth, or a null image if this image cannot be converted. The <i>depth</i> argument must be 1, 8 or 32. If the image needs to be modified to fit in a lower-resolution result (e.g&#x2e; converting from 32-bit to 8-bit), use the <i>flags</i> to specify how you'd prefer this to happen.</p>
<p>Use the <a href="qimage.html#convertToFormat">convertToFormat</a>() function instead.</p>
<!-- @@@convertDepth -->
<!-- $$$convertDepthWithPalette[overload1]$$$convertDepthWithPaletteintQRgb*intQt::ImageConversionFlags -->
<h3 class="fn"><a name="convertDepthWithPalette"></a><span class="type">QImage</span> QImage::<span class="name">convertDepthWithPalette</span> ( <span class="type">int</span> <i>depth</i>, <span class="type"><a href="qcolor.html#QRgb-typedef">QRgb</a></span> * <i>palette</i>, <span class="type">int</span> <i>palette_count</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor ) const</h3>
<p>Returns an image with the given <i>depth</i>, using the <i>palette_count</i> colors pointed to by <i>palette</i>. If <i>depth</i> is 1 or 8, the returned image will have its color table ordered in the same way as <i>palette</i>.</p>
<p>If the image needs to be modified to fit in a lower-resolution result (e.g&#x2e; converting from 32-bit to 8-bit), use the <i>flags</i> to specify how you'd prefer this to happen.</p>
<p>Note: currently no closest-color search is made. If colors are found that are not in the palette, the palette may not be used at all. This result should not be considered valid because it may change in future implementations.</p>
<p>Currently inefficient for non-32-bit images.</p>
<p>Use the <a href="qimage.html#convertToFormat">convertToFormat</a>() function in combination with the <a href="qimage.html#setColorTable">setColorTable</a>() function instead.</p>
<!-- @@@convertDepthWithPalette -->
<!-- $$$copy$$$copyintintintintQt::ImageConversionFlags -->
<h3 class="fn"><a name="copy-2"></a><span class="type">QImage</span> QImage::<span class="name">copy</span> ( <span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> ) const</h3>
<p>Use <a href="qimage.html#copy">copy</a>() instead.</p>
<!-- @@@copy -->
<!-- $$$copy$$$copyconstQRect&Qt::ImageConversionFlags -->
<h3 class="fn"><a name="copy-3"></a><span class="type">QImage</span> QImage::<span class="name">copy</span> ( const <span class="type"><a href="qrect.html">QRect</a></span> &amp; <i>rect</i>, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> ) const</h3>
<p>Use <a href="qimage.html#copy">copy</a>() instead.</p>
<!-- @@@copy -->
<!-- $$$create[overload1]$$$createintintintintEndian -->
<h3 class="fn"><a name="create"></a><span class="type">bool</span> QImage::<span class="name">create</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>Sets the image <i>width</i>, <i>height</i>, <i>depth</i>, its number of colors (in <i>numColors</i>), and bit order. Returns true if successful, or false if the parameters are incorrect or if memory cannot be allocated.</p>
<p>The <i>width</i> and <i>height</i> is limited to 32767. <i>depth</i> must be 1, 8, or 32. If <i>depth</i> is 1, <i>bitOrder</i> must be set to either <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a> or <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a>. For other depths <i>bitOrder</i> must be <a href="qimage-qt3.html#Endian-enum">QImage::IgnoreEndian</a>.</p>
<p>This function allocates a color table and a buffer for the image data. The image data is not initialized. The image buffer is allocated as a single block that consists of a table of <a href="qimage.html#scanLine">scanLine</a>() pointers (<a href="qimage-qt3.html#jumpTable">jumpTable</a>()) and the image data (<a href="qimage.html#bits">bits</a>()).</p>
<p>Use a <a href="qimage.html">QImage</a> constructor instead.</p>
<!-- @@@create -->
<!-- $$$create$$$createconstQSize&intintEndian -->
<h3 class="fn"><a name="create-2"></a><span class="type">bool</span> QImage::<span class="name">create</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i>, <span class="type">int</span> <i>depth</i>, <span class="type">int</span> <i>numColors</i> = 0, <span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> <i>bitOrder</i> = IgnoreEndian )</h3>
<p>This is an overloaded function.</p>
<p>The width and height are specified in the <i>size</i> argument.</p>
<p>Use a <a href="qimage.html">QImage</a> constructor instead.</p>
<!-- @@@create -->
<!-- $$$hasAlphaBuffer[overload1]$$$hasAlphaBuffer -->
<h3 class="fn"><a name="hasAlphaBuffer"></a><span class="type">bool</span> QImage::<span class="name">hasAlphaBuffer</span> () const</h3>
<p>Returns true if alpha buffer mode is enabled; otherwise returns false.</p>
<p>Use the <a href="qimage.html#hasAlphaChannel">hasAlphaChannel</a>() function instead.</p>
<!-- @@@hasAlphaBuffer -->
<!-- $$$invertPixels$$$invertPixelsbool -->
<h3 class="fn"><a name="invertPixels-2"></a><span class="type">void</span> QImage::<span class="name">invertPixels</span> ( <span class="type">bool</span> <i>invertAlpha</i> )</h3>
<p>Use the <a href="qimage.html#invertPixels">invertPixels</a>() function that takes a <a href="qimage.html#InvertMode-enum">QImage::InvertMode</a> parameter instead.</p>
<!-- @@@invertPixels -->
<!-- $$$jumpTable[overload1]$$$jumpTable -->
<h3 class="fn"><a name="jumpTable"></a><span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> ** QImage::<span class="name">jumpTable</span> ()</h3>
<p>Returns a pointer to the scanline pointer table. This is the beginning of the data block for the image. Returns 0 in case of an error.</p>
<p>Use the <a href="qimage.html#bits">bits</a>() or <a href="qimage.html#scanLine">scanLine</a>() function instead.</p>
<!-- @@@jumpTable -->
<!-- $$$jumpTable$$$jumpTable -->
<h3 class="fn"><a name="jumpTable-2"></a>const <span class="type"><a href="qtglobal.html#uchar-typedef">uchar</a></span> * const * QImage::<span class="name">jumpTable</span> () const</h3>
<p>This is an overloaded function.</p>
<!-- @@@jumpTable -->
<!-- $$$mirror[overload1]$$$mirrorboolbool -->
<h3 class="fn"><a name="mirror"></a><span class="type">QImage</span> QImage::<span class="name">mirror</span> ( <span class="type">bool</span> <i>horizontal</i> = false, <span class="type">bool</span> <i>vertical</i> = true ) const</h3>
<p>Use <a href="qimage.html#mirrored">mirrored</a>() instead.</p>
<!-- @@@mirror -->
<!-- $$$numBytes[overload1]$$$numBytes -->
<h3 class="fn"><a name="numBytes"></a><span class="type">int</span> QImage::<span class="name">numBytes</span> () const</h3>
<p>Returns the number of bytes occupied by the image data.</p>
<p><b>See also </b><a href="qimage.html#byteCount">byteCount</a>().</p>
<!-- @@@numBytes -->
<!-- $$$numColors[overload1]$$$numColors -->
<h3 class="fn"><a name="numColors"></a><span class="type">int</span> QImage::<span class="name">numColors</span> () const</h3>
<p>Returns the size of the color table for the image.</p>
<p><b>See also </b><a href="qimage-qt3.html#setNumColors">setNumColors</a>() and <a href="qimage.html#setColorCount">setColorCount</a>().</p>
<!-- @@@numColors -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn"><a name="reset"></a><span class="type">void</span> QImage::<span class="name">reset</span> ()</h3>
<p>Resets all image parameters and deallocates the image data.</p>
<p>Assign a null image instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 image.reset();</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 image <span class="operator">=</span> <span class="type"><a href="qimage.html">QImage</a></span>();</pre>
<!-- @@@reset -->
<!-- $$$scaleHeight[overload1]$$$scaleHeightint -->
<h3 class="fn"><a name="scaleHeight"></a><span class="type">QImage</span> QImage::<span class="name">scaleHeight</span> ( <span class="type">int</span> <i>h</i> ) const</h3>
<p>Use <a href="qimage.html#scaledToHeight">scaledToHeight</a>() instead.</p>
<!-- @@@scaleHeight -->
<!-- $$$scaleWidth[overload1]$$$scaleWidthint -->
<h3 class="fn"><a name="scaleWidth"></a><span class="type">QImage</span> QImage::<span class="name">scaleWidth</span> ( <span class="type">int</span> <i>w</i> ) const</h3>
<p>Use <a href="qimage.html#scaledToWidth">scaledToWidth</a>() instead.</p>
<!-- @@@scaleWidth -->
<!-- $$$setAlphaBuffer[overload1]$$$setAlphaBufferbool -->
<h3 class="fn"><a name="setAlphaBuffer"></a><span class="type">void</span> QImage::<span class="name">setAlphaBuffer</span> ( <span class="type">bool</span> <i>enable</i> )</h3>
<p>Enables alpha buffer mode if <i>enable</i> is true, otherwise disables it. The alpha buffer is used to set a mask when a <a href="qimage.html">QImage</a> is translated to a <a href="qpixmap.html">QPixmap</a>.</p>
<p>If a monochrome or indexed 8-bit image has alpha channels in their color tables they will automatically detect that they have an alpha channel, so this function is not required. To force alpha channels on 32-bit images, use the <a href="qimage.html#convertToFormat">convertToFormat</a>() function.</p>
<p><b>See also </b><a href="qimage-qt3.html#hasAlphaBuffer">hasAlphaBuffer</a>().</p>
<!-- @@@setAlphaBuffer -->
<!-- $$$setNumColors[overload1]$$$setNumColorsint -->
<h3 class="fn"><a name="setNumColors"></a><span class="type">void</span> QImage::<span class="name">setNumColors</span> ( <span class="type">int</span> <i>numColors</i> )</h3>
<p>Resizes the color table to contain <i>numColors</i> entries.</p>
<p><b>See also </b><a href="qimage-qt3.html#numColors">numColors</a>() and <a href="qimage.html#setColorCount">setColorCount</a>().</p>
<!-- @@@setNumColors -->
<!-- $$$smoothScale[overload1]$$$smoothScaleintintQt::AspectRatioMode -->
<h3 class="fn"><a name="smoothScale"></a><span class="type">QImage</span> QImage::<span class="name">smoothScale</span> ( <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qt.html#AspectRatioMode-enum">Qt::AspectRatioMode</a></span> <i>mode</i> = Qt::IgnoreAspectRatio ) const</h3>
<p>Use <a href="qimage.html#scaled">scaled</a>() instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 image.smoothScale(width, height, mode);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 image<span class="operator">.</span><a href="qimage.html#scaled">scaled</a>(width<span class="operator">,</span> height<span class="operator">,</span> mode<span class="operator">,</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>SmoothTransformation);</pre>
<!-- @@@smoothScale -->
<!-- $$$smoothScale$$$smoothScaleconstQSize&Qt::AspectRatioMode -->
<h3 class="fn"><a name="smoothScale-2"></a><span class="type">QImage</span> QImage::<span class="name">smoothScale</span> ( const <span class="type"><a href="qsize.html">QSize</a></span> &amp; <i>size</i>, <span class="type"><a href="qt.html#AspectRatioMode-enum">Qt::AspectRatioMode</a></span> <i>mode</i> = Qt::IgnoreAspectRatio ) const</h3>
<p>This is an overloaded function.</p>
<p>Use <a href="qimage.html#scaled">scaled</a>() instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 image.smoothScale(size, mode);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 image<span class="operator">.</span><a href="qimage.html#scaled">scaled</a>(size<span class="operator">,</span> mode<span class="operator">,</span> <span class="type"><a href="qt.html">Qt</a></span><span class="operator">::</span>SmoothTransformation);</pre>
<!-- @@@smoothScale -->
<!-- $$$swapRGB[overload1]$$$swapRGB -->
<h3 class="fn"><a name="swapRGB"></a><span class="type">QImage</span> QImage::<span class="name">swapRGB</span> () const</h3>
<p>Use <a href="qimage.html#rgbSwapped">rgbSwapped</a>() instead.</p>
<!-- @@@swapRGB -->
<!-- $$$systemBitOrder[overload1]$$$systemBitOrder -->
<h3 class="fn"><a name="systemBitOrder"></a><span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> QImage::<span class="name">systemBitOrder</span> ()<tt> [static]</tt></h3>
<p>Determines the bit order of the display hardware. Returns <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a> (LSB first) or <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a> (MSB first).</p>
<p>This function is no longer relevant for <a href="qimage.html">QImage</a>. Use <a href="qsysinfo.html">QSysInfo</a> instead.</p>
<!-- @@@systemBitOrder -->
<!-- $$$systemByteOrder[overload1]$$$systemByteOrder -->
<h3 class="fn"><a name="systemByteOrder"></a><span class="type"><a href="qimage-qt3.html#Endian-enum">Endian</a></span> QImage::<span class="name">systemByteOrder</span> ()<tt> [static]</tt></h3>
<p>Determines the host computer byte order. Returns <a href="qimage-qt3.html#Endian-enum">QImage::LittleEndian</a> (LSB first) or <a href="qimage-qt3.html#Endian-enum">QImage::BigEndian</a> (MSB first).</p>
<p>This function is no longer relevant for <a href="qimage.html">QImage</a>. Use <a href="qsysinfo.html">QSysInfo</a> instead.</p>
<!-- @@@systemByteOrder -->
<!-- $$$xForm[overload1]$$$xFormconstQMatrix& -->
<h3 class="fn"><a name="xForm"></a><span class="type">QImage</span> QImage::<span class="name">xForm</span> ( const <span class="type"><a href="qmatrix.html">QMatrix</a></span> &amp; <i>matrix</i> ) const</h3>
<p>Use <a href="qimage.html#transformed">transformed</a>() instead.</p>
<p>For example, if you have code like</p>
<pre class="cpp"> QImage image;
 ..&#x2e;
 image.xForm(matrix);</pre>
<p>you can rewrite it as</p>
<pre class="cpp"> <span class="type"><a href="qimage.html">QImage</a></span> image;
 <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
 image<span class="operator">.</span><a href="qimage.html#transformed">transformed</a>(matrix);</pre>
<!-- @@@xForm -->
<h2>Related Non-Members</h2>
<!-- $$$bitBlt[overload1]$$$bitBltQImage*intintconstQImage*intintintintQt::ImageConversionFlags -->
<h3 class="fn"><a name="bitBlt"></a><span class="type">void</span> <span class="name">bitBlt</span> ( <span class="type">QImage</span> * <i>dst</i>, <span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>, const <span class="type">QImage</span> * <i>src</i>, <span class="type">int</span> <i>sx</i> = 0, <span class="type">int</span> <i>sy</i> = 0, <span class="type">int</span> <i>sw</i> = -1, <span class="type">int</span> <i>sh</i> = -1, <span class="type"><a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor )</h3>
<p>Copies a block of pixels from <i>src</i> to <i>dst</i>. The pixels copied from source (src) are converted according to <i>flags</i> if it is incompatible with the destination (<i>dst</i>).</p>
<p><i>sx</i>, <i>sy</i> is the top-left pixel in <i>src</i>, <i>dx</i>, <i>dy</i> is the top-left position in <i>dst</i> and <i>sw</i>, <i>sh</i> is the size of the copied block. The copying is clipped if areas outside <i>src</i> or <i>dst</i> are specified. If <i>sw</i> is -1, it is adjusted to src-&gt;width(). Similarly, if <i>sh</i> is -1, it is adjusted to src-&gt;height().</p>
<p>Currently inefficient for non 32-bit images.</p>
<p>Use copy() or <a href="qpainter.html#drawImage">QPainter::drawImage</a>() instead.</p>
<!-- @@@bitBlt -->
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
