<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qmap.cpp -->
  <title>Qt 4.7: QMap Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="qtcore.html">QtCore</a></li>
              <li>QMap</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QMap Class Reference</h1>
<!-- $$$QMap-brief -->
<p>The QMap class is a template class that provides a skip-list-based dictionary. <a href="#details">More...</a></p>
<!-- @@@QMap -->
<pre class="highlightedCode brush: cpp"> #include &lt;QMap&gt;</pre><p>Inherited by <a href="qmultimap.html">QMultiMap</a>.</p>
<p><b>Note:</b> All functions in this class are <a href="threads-reentrancy.html#reentrant">reentrant</a>.</p>
<ul>
<li><a href="qmap-members.html">List of all members, including inherited members</a></li>
<li><a href="qmap-qt3.html">Qt 3 support members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmap-const-iterator.html">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qmap-iterator.html">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#ConstIterator-typedef">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#Iterator-typedef">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#difference_type-typedef">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#key_type-typedef">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#mapped_type-typedef">mapped_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#size_type-typedef">size_type</a></b></td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#QMap">QMap</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#QMap-2">QMap</a></b> ( const QMap&lt;Key, T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#QMap-3">QMap</a></b> ( const std::map&lt;Key, T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#dtor.QMap">~QMap</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#begin">begin</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#begin-2">begin</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#clear">clear</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#constBegin">constBegin</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#constEnd">constEnd</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#constFind">constFind</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#contains">contains</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#count">count</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#count-2">count</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#empty">empty</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#end">end</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#end-2">end</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#erase">erase</a></b> ( iterator <i>pos</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#find">find</a></b> ( const Key &amp; <i>key</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#find-2">find</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#insert">insert</a></b> ( const Key &amp; <i>key</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#insertMulti">insertMulti</a></b> ( const Key &amp; <i>key</i>, const T &amp; <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#isEmpty">isEmpty</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#key">key</a></b> ( const T &amp; <i>value</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#key-2">key</a></b> ( const T &amp; <i>value</i>, const Key &amp; <i>defaultKey</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#keys">keys</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#keys-2">keys</a></b> ( const T &amp; <i>value</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#lowerBound">lowerBound</a></b> ( const Key &amp; <i>key</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#lowerBound-2">lowerBound</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#remove">remove</a></b> ( const Key &amp; <i>key</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#size">size</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#take">take</a></b> ( const Key &amp; <i>key</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> std::map&lt;Key, T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#toStdMap">toStdMap</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#uniqueKeys">uniqueKeys</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap&lt;Key, T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#unite">unite</a></b> ( const QMap&lt;Key, T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#upperBound">upperBound</a></b> ( const Key &amp; <i>key</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const_iterator </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#upperBound-2">upperBound</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#value">value</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#value-2">value</a></b> ( const Key &amp; <i>key</i>, const T &amp; <i>defaultValue</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#values">values</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#values-2">values</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-not-eq">operator!=</a></b> ( const QMap&lt;Key, T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap&lt;Key, T&gt; &amp; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-eq">operator=</a></b> ( const QMap&lt;Key, T&gt; &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-eq-eq">operator==</a></b> ( const QMap&lt;Key, T&gt; &amp; <i>other</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-5b-5d">operator[]</a></b> ( const Key &amp; <i>key</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-5b-5d-2">operator[]</a></b> ( const Key &amp; <i>key</i> ) const</td></tr>
</table>
<a name="related-non-members"></a>
<h2>Related Non-Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-lt-lt-90">operator&lt;&lt;</a></b> ( QDataStream &amp; <i>out</i>, const QMap&lt;Key, T&gt; &amp; <i>map</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp; </td><td class="memItemRight bottomAlign"><b><a href="qmap.html#operator-gt-gt-54">operator&gt;&gt;</a></b> ( QDataStream &amp; <i>in</i>, QMap&lt;Key, T&gt; &amp; <i>map</i> )</td></tr>
</table>
<a name="details"></a>
<!-- $$$QMap-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QMap class is a template class that provides a skip-list-based dictionary.</p>
<p>QMap&lt;Key, T&gt; is one of Qt's generic <a href="containers.html#container-classes">container classes</a>. It stores (key, value) pairs and provides fast lookup of the value associated with a key.</p>
<p>QMap and <a href="qhash.html">QHash</a> provide very similar functionality. The differences are:</p>
<ul>
<li><a href="qhash.html">QHash</a> provides faster lookups than QMap. (See <a href="containers.html#algorithmic-complexity">Algorithmic Complexity</a> for details.)</li>
<li>When iterating over a <a href="qhash.html">QHash</a>, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</li>
<li>The key type of a <a href="qhash.html">QHash</a> must provide operator==() and a global qHash(Key) function. The key type of a QMap must provide operator&lt;() specifying a total order.</li>
</ul>
<p>Here's an example QMap with <a href="qstring.html">QString</a> keys and <tt>int</tt> values:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;QString, int&gt; map;</pre>
<p>To insert a (key, value) pair into the map, you can use operator[]():</p>
<pre class="highlightedCode brush: cpp"> map[&quot;one&quot;] = 1;
 map[&quot;three&quot;] = 3;
 map[&quot;seven&quot;] = 7;</pre>
<p>This inserts the following three (key, value) pairs into the QMap: (&quot;one&quot;, 1), (&quot;three&quot;, 3), and (&quot;seven&quot;, 7). Another way to insert items into the map is to use <a href="qmap.html#insert">insert</a>():</p>
<pre class="highlightedCode brush: cpp"> map.insert(&quot;twelve&quot;, 12);</pre>
<p>To look up a value, use operator[]() or <a href="qmap.html#value">value</a>():</p>
<pre class="highlightedCode brush: cpp"> int num1 = map[&quot;thirteen&quot;];
 int num2 = map.value(&quot;thirteen&quot;);</pre>
<p>If there is no item with the specified key in the map, these functions return a <a href="containers.html#default-constructed-values">default-constructed value</a>.</p>
<p>If you want to check whether the map contains a certain key, use <a href="qmap.html#contains">contains</a>():</p>
<pre class="highlightedCode brush: cpp"> int timeout = 30;
 if (map.contains(&quot;TIMEOUT&quot;))
     timeout = map.value(&quot;TIMEOUT&quot;);</pre>
<p>There is also a <a href="qmap.html#value">value</a>() overload that uses its second argument as a default value if there is no item with the specified key:</p>
<pre class="highlightedCode brush: cpp"> int timeout = map.value(&quot;TIMEOUT&quot;, 30);</pre>
<p>In general, we recommend that you use <a href="qmap.html#contains">contains</a>() and <a href="qmap.html#value">value</a>() rather than operator[]() for looking up a key in a map. The reason is that operator[]() silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create 1000 items in memory:</p>
<pre class="highlightedCode brush: cpp"><span class="comment"> // WRONG</span>
 QMap&lt;int, QWidget *&gt; map;
 ...
 for (int i = 0; i &lt; 1000; ++i) {
     if (map[i] == okButton)
         cout &lt;&lt; &quot;Found button at index &quot; &lt;&lt; i &lt;&lt; endl;
 }</pre>
<p>To avoid this problem, replace <tt>map[i]</tt> with <tt>map.value(i)</tt> in the code above.</p>
<p>If you want to navigate through all the (key, value) pairs stored in a QMap, you can use an iterator. QMap provides both <a href="containers.html#java-style-iterators">Java-style iterators</a> (<a href="qmapiterator.html">QMapIterator</a> and <a href="qmutablemapiterator.html">QMutableMapIterator</a>) and <a href="containers.html#stl-style-iterators">STL-style iterators</a> (<a href="qmap-const-iterator.html">QMap::const_iterator</a> and <a href="qmap-iterator.html">QMap::iterator</a>). Here's how to iterate over a QMap&lt;<a href="qstring.html">QString</a>, int&gt; using a Java-style iterator:</p>
<pre class="highlightedCode brush: cpp"> QMapIterator&lt;QString, int&gt; i(map);
 while (i.hasNext()) {
     i.next();
     cout &lt;&lt; i.key() &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
 }</pre>
<p>Here's the same code, but using an STL-style iterator this time:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;QString, int&gt;::const_iterator i = map.constBegin();
 while (i != map.constEnd()) {
     cout &lt;&lt; i.key() &lt;&lt; &quot;: &quot; &lt;&lt; i.value() &lt;&lt; endl;
     ++i;
 }</pre>
<p>The items are traversed in ascending key order.</p>
<p>Normally, a QMap allows only one value per key. If you call <a href="qmap.html#insert">insert</a>() with a key that already exists in the QMap, the previous value will be erased. For example:</p>
<pre class="highlightedCode brush: cpp"> map.insert(&quot;plenty&quot;, 100);
 map.insert(&quot;plenty&quot;, 2000);
<span class="comment"> // map.value(&quot;plenty&quot;) == 2000</span></pre>
<p>However, you can store multiple values per key by using <a href="qmap.html#insertMulti">insertMulti</a>() instead of <a href="qmap.html#insert">insert</a>() (or using the convenience subclass <a href="qmultimap.html">QMultiMap</a>). If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <a href="qlist.html">QList</a>&lt;T&gt;:</p>
<pre class="highlightedCode brush: cpp"> QList&lt;int&gt; values = map.values(&quot;plenty&quot;);
 for (int i = 0; i &lt; values.size(); ++i)
     cout &lt;&lt; values.at(i) &lt;&lt; endl;</pre>
<p>The items that share the same key are available from most recently to least recently inserted. Another approach is to call <a href="qmap.html#find">find</a>() to get the STL-style iterator for the first item with a key and iterate from there:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;QString, int&gt;::iterator i = map.find(&quot;plenty&quot;);
 while (i != map.end() &amp;&amp; i.key() == &quot;plenty&quot;) {
     cout &lt;&lt; i.value() &lt;&lt; endl;
     ++i;
 }</pre>
<p>If you only need to extract the values from a map (not the keys), you can also use <a href="containers.html#foreach">foreach</a>:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;QString, int&gt; map;
 ...
 foreach (int value, map)
     cout &lt;&lt; value &lt;&lt; endl;</pre>
<p>Items can be removed from the map in several ways. One way is to call <a href="qmap.html#remove">remove</a>(); this will remove any item with the given key. Another way is to use <a href="qmutablemapiterator.html#remove">QMutableMapIterator::remove</a>(). In addition, you can clear the entire map using <a href="qmap.html#clear">clear</a>().</p>
<p>QMap's key and value data types must be <a href="containers.html#assignable-data-types">assignable data types</a>. This covers most data types you are likely to encounter, but the compiler won't let you, for example, store a <a href="qwidget.html">QWidget</a> as a value; instead, store a <a href="qwidget.html">QWidget</a> *. In addition, QMap's key type must provide operator&lt;(). QMap uses it to keep its items sorted, and assumes that two keys <tt>x</tt> and <tt>y</tt> are equal if neither <tt>x &lt; y</tt> nor <tt>y &lt; x</tt> is true.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> #ifndef EMPLOYEE_H
 #define EMPLOYEE_H

 class Employee
 {
 public:
     Employee() {}
     Employee(const QString &amp;name, const QDate &amp;dateOfBirth);
     ...

 private:
     QString myName;
     QDate myDateOfBirth;
 };

 inline bool operator&lt;(const Employee &amp;e1, const Employee &amp;e2)
 {
     if (e1.name() != e2.name())
         return e1.name() &lt; e2.name();
     return e1.dateOfBirth() &lt; e2.dateOfBirth();
 }

 #endif <span class="comment">// EMPLOYEE_H</span></pre>
<p>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</p>
</div>
<p>See also <a href="qmapiterator.html">QMapIterator</a>, <a href="qmutablemapiterator.html">QMutableMapIterator</a>, <a href="qhash.html">QHash</a>, and <a href="qset.html">QSet</a>.</p>
<!-- @@@QMap -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn"><a name="ConstIterator-typedef"></a>typedef QMap::ConstIterator</h3>
<p>Qt-style synonym for <a href="qmap-const-iterator.html">QMap::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn"><a name="Iterator-typedef"></a>typedef QMap::Iterator</h3>
<p>Qt-style synonym for <a href="qmap-iterator.html">QMap::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$difference_type -->
<h3 class="fn"><a name="difference_type-typedef"></a>typedef QMap::difference_type</h3>
<p>Typedef for ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$key_type -->
<h3 class="fn"><a name="key_type-typedef"></a>typedef QMap::key_type</h3>
<p>Typedef for Key. Provided for STL compatibility.</p>
<!-- @@@key_type -->
<!-- $$$mapped_type -->
<h3 class="fn"><a name="mapped_type-typedef"></a>typedef QMap::mapped_type</h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@mapped_type -->
<!-- $$$size_type -->
<h3 class="fn"><a name="size_type-typedef"></a>typedef QMap::size_type</h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QMap[overload1]$$$QMap -->
<h3 class="fn"><a name="QMap"></a>QMap::QMap ()</h3>
<p>Constructs an empty map.</p>
<p>See also <a href="qmap.html#clear">clear</a>().</p>
<!-- @@@QMap -->
<!-- $$$QMap$$$QMapconstQMap<Key,T>& -->
<h3 class="fn"><a name="QMap-2"></a>QMap::QMap ( const QMap&lt;Key, T&gt; &amp; <i>other</i> )</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation occurs in <a href="containers.html#constant-time">constant time</a>, because <a href="qmap.html">QMap</a> is <a href="implicit-sharing.html#implicitly-shared">implicitly shared</a>. This makes returning a <a href="qmap.html">QMap</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <a href="containers.html#linear-time">linear time</a>.</p>
<p>See also <a href="qmap.html#operator-eq">operator=</a>().</p>
<!-- @@@QMap -->
<!-- $$$QMap$$$QMapconststd::map<Key,T>& -->
<h3 class="fn"><a name="QMap-3"></a>QMap::QMap ( const std::map&lt;Key, T&gt; &amp; <i>other</i> )</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This function is only available if Qt is configured with STL compatibility enabled.</p>
<p>See also <a href="qmap.html#toStdMap">toStdMap</a>().</p>
<!-- @@@QMap -->
<!-- $$$~QMap[overload1]$$$~QMap -->
<h3 class="fn"><a name="dtor.QMap"></a>QMap::~QMap ()</h3>
<p>Destroys the map. References to the values in the map, and all iterators over this map, become invalid.</p>
<!-- @@@~QMap -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn"><a name="begin"></a><a href="qmap-iterator.html">iterator</a> QMap::begin ()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the map.</p>
<p>See also <a href="qmap.html#constBegin">constBegin</a>() and <a href="qmap.html#end">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn"><a name="begin-2"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::begin () const</h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn"><a name="clear"></a>void QMap::clear ()</h3>
<p>Removes all items from the map.</p>
<p>See also <a href="qmap.html#remove">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn"><a name="constBegin"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::constBegin () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the map.</p>
<p>See also <a href="qmap.html#begin">begin</a>() and <a href="qmap.html#constEnd">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn"><a name="constEnd"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::constEnd () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the map.</p>
<p>See also <a href="qmap.html#constBegin">constBegin</a>() and <a href="qmap.html#end">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindconstKey& -->
<h3 class="fn"><a name="constFind"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::constFind ( const Key &amp; <i>key</i> ) const</h3>
<p>Returns an const iterator pointing to the item with key <i>key</i> in the map.</p>
<p>If the map contains no item with key <i>key</i>, the function returns <a href="qmap.html#constEnd">constEnd</a>().</p>
<p>This function was introduced in Qt 4.1.</p>
<p>See also <a href="qmap.html#find">find</a>() and <a href="qmultimap.html#constFind">QMultiMap::constFind</a>().</p>
<!-- @@@constFind -->
<!-- $$$contains[overload1]$$$containsconstKey& -->
<h3 class="fn"><a name="contains"></a>bool QMap::contains ( const Key &amp; <i>key</i> ) const</h3>
<p>Returns true if the map contains an item with key <i>key</i>; otherwise returns false.</p>
<p>See also <a href="qmap.html#count">count</a>() and <a href="qmultimap.html#contains">QMultiMap::contains</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstKey& -->
<h3 class="fn"><a name="count"></a>int QMap::count ( const Key &amp; <i>key</i> ) const</h3>
<p>Returns the number of items associated with key <i>key</i>.</p>
<p>See also <a href="qmap.html#contains">contains</a>(), <a href="qmap.html#insertMulti">insertMulti</a>(), and <a href="qmultimap.html#count">QMultiMap::count</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn"><a name="count-2"></a>int QMap::count () const</h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="qmap.html#size">size</a>().</p>
<!-- @@@count -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn"><a name="empty"></a>bool QMap::empty () const</h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="qmap.html#isEmpty">isEmpty</a>(), returning true if the map is empty; otherwise returning false.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn"><a name="end"></a><a href="qmap-iterator.html">iterator</a> QMap::end ()</h3>
<p>Returns an <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the map.</p>
<p>See also <a href="qmap.html#begin">begin</a>() and <a href="qmap.html#constEnd">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn"><a name="end-2"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::end () const</h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseiterator -->
<h3 class="fn"><a name="erase"></a><a href="qmap-iterator.html">iterator</a> QMap::erase ( <a href="qmap-iterator.html">iterator</a> <i>pos</i> )</h3>
<p>Removes the (key, value) pair pointed to by the iterator <i>pos</i> from the map, and returns an iterator to the next item in the map.</p>
<p>See also <a href="qmap.html#remove">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$find[overload1]$$$findconstKey& -->
<h3 class="fn"><a name="find"></a><a href="qmap-iterator.html">iterator</a> QMap::find ( const Key &amp; <i>key</i> )</h3>
<p>Returns an iterator pointing to the item with key <i>key</i> in the map.</p>
<p>If the map contains no item with key <i>key</i>, the function returns <a href="qmap.html#end">end</a>().</p>
<p>If the map contains multiple items with key <i>key</i>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;QString, int&gt; map;
 ...
 QMap&lt;QString, int&gt;::const_iterator i = map.find(&quot;HDR&quot;);
 while (i != map.end() &amp;&amp; i.key() == &quot;HDR&quot;) {
     cout &lt;&lt; i.value() &lt;&lt; endl;
     ++i;
 }</pre>
<p>See also <a href="qmap.html#constFind">constFind</a>(), <a href="qmap.html#value">value</a>(), <a href="qmap.html#values">values</a>(), <a href="qmap.html#lowerBound">lowerBound</a>(), <a href="qmap.html#upperBound">upperBound</a>(), and <a href="qmultimap.html#find">QMultiMap::find</a>().</p>
<!-- @@@find -->
<!-- $$$find$$$findconstKey& -->
<h3 class="fn"><a name="find-2"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::find ( const Key &amp; <i>key</i> ) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@find -->
<!-- $$$insert[overload1]$$$insertconstKey&constT& -->
<h3 class="fn"><a name="insert"></a><a href="qmap-iterator.html">iterator</a> QMap::insert ( const Key &amp; <i>key</i>, const T &amp; <i>value</i> )</h3>
<p>Inserts a new item with the key <i>key</i> and a value of <i>value</i>.</p>
<p>If there is already an item with the key <i>key</i>, that item's value is replaced with <i>value</i>.</p>
<p>If there are multiple items with the key <i>key</i>, the most recently inserted item's value is replaced with <i>value</i>.</p>
<p>See also <a href="qmap.html#insertMulti">insertMulti</a>().</p>
<!-- @@@insert -->
<!-- $$$insertMulti[overload1]$$$insertMulticonstKey&constT& -->
<h3 class="fn"><a name="insertMulti"></a><a href="qmap-iterator.html">iterator</a> QMap::insertMulti ( const Key &amp; <i>key</i>, const T &amp; <i>value</i> )</h3>
<p>Inserts a new item with the key <i>key</i> and a value of <i>value</i>.</p>
<p>If there is already an item with the same key in the map, this function will simply create a new one. (This behavior is different from <a href="qmap.html#insert">insert</a>(), which overwrites the value of an existing item.)</p>
<p>See also <a href="qmap.html#insert">insert</a>() and <a href="qmap.html#values">values</a>().</p>
<!-- @@@insertMulti -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn"><a name="isEmpty"></a>bool QMap::isEmpty () const</h3>
<p>Returns true if the map contains no items; otherwise returns false.</p>
<p>See also <a href="qmap.html#size">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$key[overload1]$$$keyconstT& -->
<h3 class="fn"><a name="key"></a>const Key QMap::key ( const T &amp; <i>value</i> ) const</h3>
<p>Returns the first key with value <i>value</i>.</p>
<p>If the map contains no item with value <i>value</i>, the function returns a <a href="containers.html#default-constructed-values">default-constructed key</a>.</p>
<p>This function can be slow (<a href="containers.html#linear-time">linear time</a>), because <a href="qmap.html">QMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<p>See also <a href="qmap.html#value">value</a>() and <a href="qmap.html#keys">keys</a>().</p>
<!-- @@@key -->
<!-- $$$key$$$keyconstT&constKey& -->
<h3 class="fn"><a name="key-2"></a>const Key QMap::key ( const T &amp; <i>value</i>, const Key &amp; <i>defaultKey</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Returns the first key with value <i>value</i>, or <i>defaultKey</i> if the map contains no item with value <i>value</i>.</p>
<p>This function can be slow (<a href="containers.html#linear-time">linear time</a>), because <a href="qmap.html">QMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<p>This function was introduced in Qt 4.3.</p>
<!-- @@@key -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn"><a name="keys"></a><a href="qlist.html">QList</a>&lt;Key&gt; QMap::keys () const</h3>
<p>Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <a href="qmap.html#insertMulti">insertMulti</a>(), or <a href="qmap.html#unite">unite</a>() was used) also occur multiple times in the list.</p>
<p>To obtain a list of unique keys, where each key from the map only occurs once, use <a href="qmap.html#uniqueKeys">uniqueKeys</a>().</p>
<p>The order is guaranteed to be the same as that used by <a href="qmap.html#values">values</a>().</p>
<p>See also <a href="qmap.html#uniqueKeys">uniqueKeys</a>(), <a href="qmap.html#values">values</a>(), and <a href="qmap.html#key">key</a>().</p>
<!-- @@@keys -->
<!-- $$$keys$$$keysconstT& -->
<h3 class="fn"><a name="keys-2"></a><a href="qlist.html">QList</a>&lt;Key&gt; QMap::keys ( const T &amp; <i>value</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a list containing all the keys associated with value <i>value</i> in ascending order.</p>
<p>This function can be slow (<a href="containers.html#linear-time">linear time</a>), because <a href="qmap.html">QMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<!-- @@@keys -->
<!-- $$$lowerBound[overload1]$$$lowerBoundconstKey& -->
<h3 class="fn"><a name="lowerBound"></a><a href="qmap-iterator.html">iterator</a> QMap::lowerBound ( const Key &amp; <i>key</i> )</h3>
<p>Returns an iterator pointing to the first item with key <i>key</i> in the map. If the map contains no item with key <i>key</i>, the function returns an iterator to the nearest item with a greater key.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;int, QString&gt; map;
 map.insert(1, &quot;one&quot;);
 map.insert(5, &quot;five&quot;);
 map.insert(10, &quot;ten&quot;);

 map.lowerBound(0);      <span class="comment">// returns iterator to (1, &quot;one&quot;)</span>
 map.lowerBound(1);      <span class="comment">// returns iterator to (1, &quot;one&quot;)</span>
 map.lowerBound(2);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 map.lowerBound(10);     <span class="comment">// returns iterator to (10, &quot;ten&quot;)</span>
 map.lowerBound(999);    <span class="comment">// returns end()</span></pre>
<p>If the map contains multiple items with key <i>key</i>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;QString, int&gt; map;
 ...
 QMap&lt;QString, int&gt;::const_iterator i = map.lowerBound(&quot;HDR&quot;);
 QMap&lt;QString, int&gt;::const_iterator upperBound = map.upperBound(&quot;HDR&quot;);
 while (i != upperBound) {
     cout &lt;&lt; i.value() &lt;&lt; endl;
     ++i;
 }</pre>
<p>See also <a href="qtalgorithms.html#qLowerBound">qLowerBound</a>(), <a href="qmap.html#upperBound">upperBound</a>(), and <a href="qmap.html#find">find</a>().</p>
<!-- @@@lowerBound -->
<!-- $$$lowerBound$$$lowerBoundconstKey& -->
<h3 class="fn"><a name="lowerBound-2"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::lowerBound ( const Key &amp; <i>key</i> ) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@lowerBound -->
<!-- $$$remove[overload1]$$$removeconstKey& -->
<h3 class="fn"><a name="remove"></a>int QMap::remove ( const Key &amp; <i>key</i> )</h3>
<p>Removes all the items that have the key <i>key</i> from the map. Returns the number of items removed which is usually 1 but will be 0 if the key isn't in the map, or &gt; 1 if <a href="qmap.html#insertMulti">insertMulti</a>() has been used with the <i>key</i>.</p>
<p>See also <a href="qmap.html#clear">clear</a>(), <a href="qmap.html#take">take</a>(), and <a href="qmultimap.html#remove">QMultiMap::remove</a>().</p>
<!-- @@@remove -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn"><a name="size"></a>int QMap::size () const</h3>
<p>Returns the number of (key, value) pairs in the map.</p>
<p>See also <a href="qmap.html#isEmpty">isEmpty</a>() and <a href="qmap.html#count">count</a>().</p>
<!-- @@@size -->
<!-- $$$take[overload1]$$$takeconstKey& -->
<h3 class="fn"><a name="take"></a>T QMap::take ( const Key &amp; <i>key</i> )</h3>
<p>Removes the item with the key <i>key</i> from the map and returns the value associated with it.</p>
<p>If the item does not exist in the map, the function simply returns a <a href="containers.html#default-constructed-values">default-constructed value</a>. If there are multiple items for <i>key</i> in the map, only the most recently inserted one is removed and returned.</p>
<p>If you don't use the return value, <a href="qmap.html#remove">remove</a>() is more efficient.</p>
<p>See also <a href="qmap.html#remove">remove</a>().</p>
<!-- @@@take -->
<!-- $$$toStdMap[overload1]$$$toStdMap -->
<h3 class="fn"><a name="toStdMap"></a>std::map&lt;Key, T&gt; QMap::toStdMap () const</h3>
<p>Returns an STL map equivalent to this <a href="qmap.html">QMap</a>.</p>
<p>This function is only available if Qt is configured with STL compatibility enabled.</p>
<!-- @@@toStdMap -->
<!-- $$$uniqueKeys[overload1]$$$uniqueKeys -->
<h3 class="fn"><a name="uniqueKeys"></a><a href="qlist.html">QList</a>&lt;Key&gt; QMap::uniqueKeys () const</h3>
<p>Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because items were inserted with <a href="qmap.html#insertMulti">insertMulti</a>(), or <a href="qmap.html#unite">unite</a>() was used) occur only once in the returned list.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qmap.html#keys">keys</a>() and <a href="qmap.html#values">values</a>().</p>
<!-- @@@uniqueKeys -->
<!-- $$$unite[overload1]$$$uniteconstQMap<Key,T>& -->
<h3 class="fn"><a name="unite"></a>QMap&lt;Key, T&gt; &amp; QMap::unite ( const QMap&lt;Key, T&gt; &amp; <i>other</i> )</h3>
<p>Inserts all the items in the <i>other</i> map into this map. If a key is common to both maps, the resulting map will contain the key multiple times.</p>
<p>See also <a href="qmap.html#insertMulti">insertMulti</a>().</p>
<!-- @@@unite -->
<!-- $$$upperBound[overload1]$$$upperBoundconstKey& -->
<h3 class="fn"><a name="upperBound"></a><a href="qmap-iterator.html">iterator</a> QMap::upperBound ( const Key &amp; <i>key</i> )</h3>
<p>Returns an iterator pointing to the item that immediately follows the last item with key <i>key</i> in the map. If the map contains no item with key <i>key</i>, the function returns an iterator to the nearest item with a greater key.</p>
<p>Example:</p>
<pre class="highlightedCode brush: cpp"> QMap&lt;int, QString&gt; map;
 map.insert(1, &quot;one&quot;);
 map.insert(5, &quot;five&quot;);
 map.insert(10, &quot;ten&quot;);

 map.upperBound(0);      <span class="comment">// returns iterator to (1, &quot;one&quot;)</span>
 map.upperBound(1);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 map.upperBound(2);      <span class="comment">// returns iterator to (5, &quot;five&quot;)</span>
 map.upperBound(10);     <span class="comment">// returns end()</span>
 map.upperBound(999);    <span class="comment">// returns end()</span></pre>
<p>See also <a href="qtalgorithms.html#qUpperBound">qUpperBound</a>(), <a href="qmap.html#lowerBound">lowerBound</a>(), and <a href="qmap.html#find">find</a>().</p>
<!-- @@@upperBound -->
<!-- $$$upperBound$$$upperBoundconstKey& -->
<h3 class="fn"><a name="upperBound-2"></a><a href="qmap-const-iterator.html">const_iterator</a> QMap::upperBound ( const Key &amp; <i>key</i> ) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@upperBound -->
<!-- $$$value[overload1]$$$valueconstKey& -->
<h3 class="fn"><a name="value"></a>const T QMap::value ( const Key &amp; <i>key</i> ) const</h3>
<p>Returns the value associated with the key <i>key</i>.</p>
<p>If the map contains no item with key <i>key</i>, the function returns a <a href="containers.html#default-constructed-values">default-constructed value</a>. If there are multiple items for <i>key</i> in the map, the value of the most recently inserted one is returned.</p>
<p>See also <a href="qmap.html#key">key</a>(), <a href="qmap.html#values">values</a>(), <a href="qmap.html#contains">contains</a>(), and <a href="qmap.html#operator-5b-5d">operator[]</a>().</p>
<!-- @@@value -->
<!-- $$$value$$$valueconstKey&constT& -->
<h3 class="fn"><a name="value-2"></a>const T QMap::value ( const Key &amp; <i>key</i>, const T &amp; <i>defaultValue</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>If the map contains no item with key <i>key</i>, the function returns <i>defaultValue</i>.</p>
<!-- @@@value -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn"><a name="values"></a><a href="qlist.html">QList</a>&lt;T&gt; QMap::values () const</h3>
<p>Returns a list containing all the values in the map, in ascending order of their keys. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</p>
<p>See also <a href="qmap.html#keys">keys</a>() and <a href="qmap.html#value">value</a>().</p>
<!-- @@@values -->
<!-- $$$values$$$valuesconstKey& -->
<h3 class="fn"><a name="values-2"></a><a href="qlist.html">QList</a>&lt;T&gt; QMap::values ( const Key &amp; <i>key</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Returns a list containing all the values associated with key <i>key</i>, from the most recently inserted to the least recently inserted one.</p>
<p>See also <a href="qmap.html#count">count</a>() and <a href="qmap.html#insertMulti">insertMulti</a>().</p>
<!-- @@@values -->
<!-- $$$operator!=[overload1]$$$operator!=constQMap<Key,T>& -->
<h3 class="fn"><a name="operator-not-eq"></a>bool QMap::operator!= ( const QMap&lt;Key, T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if <i>other</i> is not equal to this map; otherwise returns false.</p>
<p>Two maps are considered equal if they contain the same (key, value) pairs.</p>
<p>This function requires the value type to implement <tt>operator==()</tt>.</p>
<p>See also <a href="qmap.html#operator-eq-eq">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator=[overload1]$$$operator=constQMap<Key,T>& -->
<h3 class="fn"><a name="operator-eq"></a>QMap&lt;Key, T&gt; &amp; QMap::operator= ( const QMap&lt;Key, T&gt; &amp; <i>other</i> )</h3>
<p>Assigns <i>other</i> to this map and returns a reference to this map.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQMap<Key,T>& -->
<h3 class="fn"><a name="operator-eq-eq"></a>bool QMap::operator== ( const QMap&lt;Key, T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if <i>other</i> is equal to this map; otherwise returns false.</p>
<p>Two maps are considered equal if they contain the same (key, value) pairs.</p>
<p>This function requires the value type to implement <tt>operator==()</tt>.</p>
<p>See also <a href="qmap.html#operator-not-eq">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]constKey& -->
<h3 class="fn"><a name="operator-5b-5d"></a>T &amp; QMap::operator[] ( const Key &amp; <i>key</i> )</h3>
<p>Returns the value associated with the key <i>key</i> as a modifiable reference.</p>
<p>If the map contains no item with key <i>key</i>, the function inserts a <a href="containers.html#default-constructed-values">default-constructed value</a> into the map with key <i>key</i>, and returns a reference to it. If the map contains multiple items with key <i>key</i>, this function returns a reference to the most recently inserted value.</p>
<p>See also <a href="qmap.html#insert">insert</a>() and <a href="qmap.html#value">value</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constKey& -->
<h3 class="fn"><a name="operator-5b-5d-2"></a>const T QMap::operator[] ( const Key &amp; <i>key</i> ) const</h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="qmap.html#value">value</a>().</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$operator<<$$$operator<<QDataStream&constQMap<Key,T>& -->
<h3 class="fn"><a name="operator-lt-lt-90"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>out</i>, const QMap&lt;Key, T&gt; &amp; <i>map</i> )</h3>
<p>Writes the map <i>map</i> to stream <i>out</i>.</p>
<p>This function requires the key and value types to implement <tt>operator&lt;&lt;()</tt>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>$$$operator>>QDataStream&QMap<Key,T>& -->
<h3 class="fn"><a name="operator-gt-gt-54"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>in</i>, QMap&lt;Key, T&gt; &amp; <i>map</i> )</h3>
<p>Reads a map from stream <i>in</i> into <i>map</i>.</p>
<p>This function requires the key and value types to implement <tt>operator&gt;&gt;()</tt>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.</p>
<!-- @@@operator>> -->
</div>
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
