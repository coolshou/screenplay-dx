<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- q3socket.cpp -->
  <title>Qt 4.7: Q3Socket Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="qt3support.html">Qt3Support</a></li>
              <li>Q3Socket</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">Q3Socket Class Reference</h1>
<!-- $$$Q3Socket-brief -->
<p>The Q3Socket class provides a buffered TCP connection. <a href="#details">More...</a></p>
<!-- @@@Q3Socket -->
<pre class="highlightedCode brush: cpp"> #include &lt;Q3Socket&gt;</pre><p><b>This class is part of the Qt 3 support library.</b> It is provided to keep old source code working. We strongly advise against using it in new code. See <a href="porting4.html#qsocket">Porting to Qt 4</a> for more information.</p>
<p>Inherits <a href="qiodevice.html">QIODevice</a>.</p>
<ul>
<li><a href="q3socket-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#Error-enum">Error</a></b> { ErrConnectionRefused, ErrHostNotFound, ErrSocketRead }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#State-enum">State</a></b> { Idle, HostLookup, Connecting, Connected, Closing }</td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#Q3Socket">Q3Socket</a></b> ( QObject * <i>parent</i> = 0, const char * <i>name</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#dtor.Q3Socket">~Q3Socket</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#address">address</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Offset </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#at">at</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#at-2">at</a></b> ( Offset <i>index</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#clearPendingData">clearPendingData</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#connectToHost">connectToHost</a></b> ( const QString &amp; <i>host</i>, Q_UINT16 <i>port</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#flush">flush</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#getch">getch</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#open-2">open</a></b> ( int <i>m</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#peerAddress">peerAddress</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#peerName">peerName</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_UINT16 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#peerPort">peerPort</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_UINT16 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#port">port</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#putch">putch</a></b> ( int <i>ch</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_ULONG </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#readBufferSize">readBufferSize</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#setReadBufferSize">setReadBufferSize</a></b> ( Q_ULONG <i>bufSize</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#setSocket">setSocket</a></b> ( int <i>socket</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#setSocketDevice">setSocketDevice</a></b> ( Q3SocketDevice * <i>device</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#socket">socket</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q3SocketDevice * </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#socketDevice">socketDevice</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> State </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#state">state</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#ungetch">ungetch</a></b> ( int <i>ch</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_ULONG </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#waitForMore">waitForMore</a></b> ( int <i>msecs</i>, bool * <i>timeout</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Q_ULONG </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#waitForMore-2">waitForMore</a></b> ( int <i>msecs</i> ) const</td></tr>
</table>
<a name="reimplemented-public-functions"></a>
<h2>Reimplemented Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#atEnd">atEnd</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#bytesAvailable">bytesAvailable</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#bytesToWrite">bytesToWrite</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#canReadLine">canReadLine</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#close">close</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#open">open</a></b> ( OpenMode <i>m</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual Offset </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#size">size</a></b> () const</td></tr>
</table>
<ul>
<li class="fn">33 public functions inherited from <a href="qiodevice.html#public-functions">QIODevice</a></li>
<li class="fn">29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#bytesWritten">bytesWritten</a></b> ( int <i>nbytes</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#connected">connected</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#connectionClosed">connectionClosed</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#error">error</a></b> ( int <i>error</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#hostFound">hostFound</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#readyRead">readyRead</a></b> ()</td></tr>
</table>
<ul>
<li class="fn">4 signals inherited from <a href="qiodevice.html#signals">QIODevice</a></li>
<li class="fn">1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2>Reimplemented Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#readData">readData</a></b> ( char * <i>data</i>, qint64 <i>maxlen</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="q3socket.html#writeData">writeData</a></b> ( const char * <i>data</i>, qint64 <i>len</i> )</td></tr>
</table>
<ul>
<li class="fn">5 protected functions inherited from <a href="qiodevice.html#protected-functions">QIODevice</a></li>
<li class="fn">7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li class="fn">5 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li class="fn">5 protected functions inherited from <a href="qiodevice.html#protected-functions">QIODevice</a></li>
<li class="fn">7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$Q3Socket-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The Q3Socket class provides a buffered TCP connection.</p>
<p>It provides a totally non-blocking <a href="qiodevice.html">QIODevice</a>, and modifies and extends the API of <a href="qiodevice.html">QIODevice</a> with socket-specific code.</p>
<p>The functions you're likely to call most are <a href="q3socket.html#connectToHost">connectToHost</a>(), <a href="q3socket.html#bytesAvailable">bytesAvailable</a>(), <a href="q3socket.html#canReadLine">canReadLine</a>() and the ones it inherits from <a href="qiodevice.html">QIODevice</a>.</p>
<p><a href="q3socket.html#connectToHost">connectToHost</a>() is the most-used function. As its name implies, it opens a connection to a named host.</p>
<p>Most network protocols are either packet-oriented or line-oriented. <a href="q3socket.html#canReadLine">canReadLine</a>() indicates whether a connection contains an entire unread line or not, and <a href="q3socket.html#bytesAvailable">bytesAvailable</a>() returns the number of bytes available for reading.</p>
<p>The signals <a href="q3socket.html#error">error</a>(), <a href="q3socket.html#connected">connected</a>(), <a href="q3socket.html#readyRead">readyRead</a>() and <a href="q3socket.html#connectionClosed">connectionClosed</a>() inform you of the progress of the connection. There are also some less commonly used signals. <a href="q3socket.html#hostFound">hostFound</a>() is emitted when <a href="q3socket.html#connectToHost">connectToHost</a>() has finished its DNS lookup and is starting its TCP connection. <a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a>() is emitted when <a href="q3socket.html#close">close</a>() succeeds. <a href="q3socket.html#bytesWritten">bytesWritten</a>() is emitted when Q3Socket moves data from its &quot;to be written&quot; queue into the TCP implementation.</p>
<p>There are several access functions for the socket: <a href="q3socket.html#state">state</a>() returns whether the object is idle, is doing a DNS lookup, is connecting, has an operational connection, etc. <a href="q3socket.html#address">address</a>() and <a href="q3socket.html#port">port</a>() return the IP address and port used for the connection. The <a href="q3socket.html#peerAddress">peerAddress</a>() and <a href="q3socket.html#peerPort">peerPort</a>() functions return the IP address and port used by the peer, and <a href="q3socket.html#peerName">peerName</a>() returns the name of the peer (normally the name that was passed to <a href="q3socket.html#connectToHost">connectToHost</a>()). <a href="q3socket.html#socketDevice">socketDevice</a>() returns a pointer to the <a href="q3socketdevice.html">Q3SocketDevice</a> used for this socket.</p>
<p>Q3Socket inherits <a href="qiodevice.html">QIODevice</a>, and reimplements some functions. In general, you can treat it as a <a href="qiodevice.html">QIODevice</a> for writing, and mostly also for reading. The match isn't perfect, since the <a href="qiodevice.html">QIODevice</a> API is designed for devices that are controlled by the same machine, and an asynchronous peer-to-peer network connection isn't quite like that. For example, there is nothing that matches <a href="qiodevice.html#size">QIODevice::size</a>() exactly. The documentation for <a href="q3socket.html#open">open</a>(), <a href="q3socket.html#close">close</a>(), <a href="q3socket.html#flush">flush</a>(), <a href="q3socket.html#size">size</a>(), <a href="q3socket.html#at">at</a>(), <a href="q3socket.html#atEnd">atEnd</a>(), <a href="qiodevice.html#readBlock">readBlock</a>(), <a href="qiodevice.html#writeBlock">writeBlock</a>(), <a href="q3socket.html#getch">getch</a>(), <a href="q3socket.html#putch">putch</a>(), <a href="q3socket.html#ungetch">ungetch</a>() and <a href="qiodevice.html#readLine">readLine</a>() describes the differences in detail.</p>
<p><b>Warning:</b> Q3Socket is not suitable for use in threads. If you need to uses sockets in threads use the lower-level <a href="q3socketdevice.html">Q3SocketDevice</a> class.</p>
</div>
<p>See also <a href="q3socketdevice.html">Q3SocketDevice</a>, <a href="qhostaddress.html">QHostAddress</a>, and <a href="qsocketnotifier.html">QSocketNotifier</a>.</p>
<!-- @@@Q3Socket -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Error$$$ErrConnectionRefused$$$ErrHostNotFound$$$ErrSocketRead -->
<h3 class="fn"><a name="Error-enum"></a>enum Q3Socket::Error</h3>
<p>This enum specifies the possible errors:</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>Q3Socket::ErrConnectionRefused</tt></td><td class=" topAlign"><tt>0</tt></td><td  class="topAlign">if the connection was refused</td></tr>
<tr><td  class="topAlign"><tt>Q3Socket::ErrHostNotFound</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">if the host was not found</td></tr>
<tr><td  class="topAlign"><tt>Q3Socket::ErrSocketRead</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">if a read from the socket failed</td></tr>
</table>
<!-- @@@Error -->
<!-- $$$State$$$Idle$$$HostLookup$$$Connecting$$$Connected$$$Closing$$$Connection -->
<h3 class="fn"><a name="State-enum"></a>enum Q3Socket::State</h3>
<p>This enum defines the connection states:</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>Q3Socket::Idle</tt></td><td class=" topAlign"><tt>0</tt></td><td  class="topAlign">if there is no connection</td></tr>
<tr><td  class="topAlign"><tt>Q3Socket::HostLookup</tt></td><td class=" topAlign"><tt>1</tt></td><td  class="topAlign">during a DNS lookup</td></tr>
<tr><td  class="topAlign"><tt>Q3Socket::Connecting</tt></td><td class=" topAlign"><tt>2</tt></td><td  class="topAlign">during TCP connection establishment</td></tr>
<tr><td  class="topAlign"><tt>Q3Socket::Connected</tt></td><td class=" topAlign"><tt>3</tt></td><td  class="topAlign">when there is an operational connection</td></tr>
<tr><td  class="topAlign"><tt>Q3Socket::Closing</tt></td><td class=" topAlign"><tt>4</tt></td><td  class="topAlign">if the socket is closing down, but is not yet closed.</td></tr>
</table>
<!-- @@@State -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$Q3Socket[overload1]$$$Q3SocketQObject*constchar* -->
<h3 class="fn"><a name="Q3Socket"></a>Q3Socket::Q3Socket ( <a href="qobject.html">QObject</a> * <i>parent</i> = 0, const char * <i>name</i> = 0 )</h3>
<p>Creates a <a href="q3socket.html" class="compat">Q3Socket</a> object in <a href="q3socket.html#State-enum">Q3Socket::Idle</a> state.</p>
<p>The <i>parent</i> and <i>name</i> arguments are passed on to the <a href="qobject.html">QObject</a> constructor.</p>
<!-- @@@Q3Socket -->
<!-- $$$~Q3Socket[overload1]$$$~Q3Socket -->
<h3 class="fn"><a name="dtor.Q3Socket"></a>Q3Socket::~Q3Socket ()<tt> [virtual]</tt></h3>
<p>Destroys the socket. Closes the connection if necessary.</p>
<p>See also <a href="q3socket.html#close">close</a>().</p>
<!-- @@@~Q3Socket -->
<!-- $$$address[overload1]$$$address -->
<h3 class="fn"><a name="address"></a><a href="qhostaddress.html">QHostAddress</a> Q3Socket::address () const</h3>
<p>Returns the host address of this socket. (This is normally the main IP address of the host, but can be e.g&#x2e; 127.0&#x2e;0&#x2e;1 for connections to localhost.)</p>
<!-- @@@address -->
<!-- $$$at[overload1]$$$at -->
<h3 class="fn"><a name="at"></a><a href="qiodevice.html#Offset-typedef">Offset</a> Q3Socket::at () const</h3>
<p>Returns the current read index. Since <a href="q3socket.html" class="compat">Q3Socket</a> is a sequential device, the current read index is always zero.</p>
<!-- @@@at -->
<!-- $$$at$$$atOffset -->
<h3 class="fn"><a name="at-2"></a>bool Q3Socket::at ( <a href="qiodevice.html#Offset-typedef">Offset</a> <i>index</i> )</h3>
<p>This is an overloaded function.</p>
<p>Moves the read index forward to <i>index</i> and returns true if the operation was successful; otherwise returns false. Moving the index forward means skipping incoming data.</p>
<!-- @@@at -->
<!-- $$$atEnd[overload1]$$$atEnd -->
<h3 class="fn"><a name="atEnd"></a>bool Q3Socket::atEnd () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#atEnd">QIODevice::atEnd</a>().</p>
<p>Returns true if there is no more data to read; otherwise returns false.</p>
<!-- @@@atEnd -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn"><a name="bytesAvailable"></a><a href="qtglobal.html#qint64-typedef">qint64</a> Q3Socket::bytesAvailable () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#bytesAvailable">QIODevice::bytesAvailable</a>().</p>
<p>Returns the number of incoming bytes that can be read, i.e&#x2e; the size of the input buffer. Equivalent to <a href="q3socket.html#size">size</a>().</p>
<p>See also <a href="q3socket.html#bytesToWrite">bytesToWrite</a>().</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn"><a name="bytesToWrite"></a><a href="qtglobal.html#qint64-typedef">qint64</a> Q3Socket::bytesToWrite () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#bytesToWrite">QIODevice::bytesToWrite</a>().</p>
<p>Returns the number of bytes that are waiting to be written, i.e&#x2e; the size of the output buffer.</p>
<p>See also <a href="q3socket.html#bytesAvailable">bytesAvailable</a>() and <a href="q3socket.html#clearPendingData">clearPendingData</a>().</p>
<!-- @@@bytesToWrite -->
<!-- $$$bytesWritten[overload1]$$$bytesWrittenint -->
<h3 class="fn"><a name="bytesWritten"></a>void Q3Socket::bytesWritten ( int <i>nbytes</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted when data has been written to the network. The <i>nbytes</i> parameter specifies how many bytes were written.</p>
<p>The <a href="q3socket.html#bytesToWrite">bytesToWrite</a>() function is often used in the same context; it indicates how many buffered bytes there are left to write.</p>
<p>See also <a href="qiodevice.html#writeBlock" class="compat">writeBlock</a>() and <a href="q3socket.html#bytesToWrite">bytesToWrite</a>().</p>
<!-- @@@bytesWritten -->
<!-- $$$canReadLine[overload1]$$$canReadLine -->
<h3 class="fn"><a name="canReadLine"></a>bool Q3Socket::canReadLine () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#canReadLine">QIODevice::canReadLine</a>().</p>
<p>Returns true if it's possible to read an entire line of text from this socket at this time; otherwise returns false.</p>
<p>Note that if the peer closes the connection unexpectedly, this function returns false. This means that loops such as this won't work:</p>
<pre class="highlightedCode brush: cpp"> while( !socket-&gt;canReadLine() ) <span class="comment">// WRONG</span>
     ;</pre>
<p>See also <a href="qiodevice.html#readLine">readLine</a>().</p>
<!-- @@@canReadLine -->
<!-- $$$clearPendingData[overload1]$$$clearPendingData -->
<h3 class="fn"><a name="clearPendingData"></a>void Q3Socket::clearPendingData ()</h3>
<p>Deletes the data that is waiting to be written. This is useful if you want to close the socket without waiting for all the data to be written.</p>
<p>See also <a href="q3socket.html#bytesToWrite">bytesToWrite</a>(), <a href="q3socket.html#close">close</a>(), and <a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a>().</p>
<!-- @@@clearPendingData -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn"><a name="close"></a>void Q3Socket::close ()<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#close">QIODevice::close</a>().</p>
<p>Closes the socket.</p>
<p>The read buffer is cleared.</p>
<p>If the output buffer is empty, the state is set to <tt>Q3Socket::Idle</tt> and the connection is terminated immediately. If the output buffer still contains data to be written, <a href="q3socket.html" class="compat">Q3Socket</a> goes into the <a href="q3socket.html#State-enum">Q3Socket::Closing</a> state and the rest of the data will be written. When all of the outgoing data have been written, the state is set to <a href="q3socket.html#State-enum">Q3Socket::Idle</a> and the connection is terminated. At this point, the <a href="q3socket.html#delayedCloseFinished">delayedCloseFinished</a>() signal is emitted.</p>
<p>If you don't want that the data of the output buffer is written, call <a href="q3socket.html#clearPendingData">clearPendingData</a>() before you call close().</p>
<p>See also <a href="q3socket.html#state">state</a>(), <a href="q3socket.html#bytesToWrite">bytesToWrite</a>(), and <a href="q3socket.html#clearPendingData">clearPendingData</a>().</p>
<!-- @@@close -->
<!-- $$$connectToHost[overload1]$$$connectToHostconstQString&Q_UINT16 -->
<h3 class="fn"><a name="connectToHost"></a>void Q3Socket::connectToHost ( const <a href="qstring.html">QString</a> &amp; <i>host</i>, <a href="qtglobal.html#Q_UINT16-typedef">Q_UINT16</a> <i>port</i> )<tt> [virtual]</tt></h3>
<p>Attempts to make a connection to <i>host</i> on the specified <i>port</i> and return immediately.</p>
<p>Any connection or pending connection is closed immediately, and <a href="q3socket.html" class="compat">Q3Socket</a> goes into the <tt>HostLookup</tt> state. When the lookup succeeds, it emits <a href="q3socket.html#hostFound">hostFound</a>(), starts a TCP connection and goes into the <tt>Connecting</tt> state. Finally, when the connection succeeds, it emits <a href="q3socket.html#connected">connected</a>() and goes into the <tt>Connected</tt> state. If there is an error at any point, it emits <a href="q3socket.html#error">error</a>().</p>
<p><i>host</i> may be an IP address in string form, or it may be a DNS name. <a href="q3socket.html" class="compat">Q3Socket</a> will do a normal DNS lookup if required. Note that <i>port</i> is in native byte order, unlike some other libraries.</p>
<p>See also <a href="q3socket.html#state">state</a>().</p>
<!-- @@@connectToHost -->
<!-- $$$connected[overload1]$$$connected -->
<h3 class="fn"><a name="connected"></a>void Q3Socket::connected ()<tt> [signal]</tt></h3>
<p>This signal is emitted after <a href="q3socket.html#connectToHost">connectToHost</a>() has been called and a connection has been successfully established.</p>
<p>See also <a href="q3socket.html#connectToHost">connectToHost</a>() and <a href="q3socket.html#connectionClosed">connectionClosed</a>().</p>
<!-- @@@connected -->
<!-- $$$connectionClosed[overload1]$$$connectionClosed -->
<h3 class="fn"><a name="connectionClosed"></a>void Q3Socket::connectionClosed ()<tt> [signal]</tt></h3>
<p>This signal is emitted when the other end has closed the connection. The read buffers may contain buffered input data which you can read after the connection was closed.</p>
<p>See also <a href="q3socket.html#connectToHost">connectToHost</a>() and <a href="q3socket.html#close">close</a>().</p>
<!-- @@@connectionClosed -->
<!-- $$$delayedCloseFinished[overload1]$$$delayedCloseFinished -->
<h3 class="fn"><a name="delayedCloseFinished"></a>void Q3Socket::delayedCloseFinished ()<tt> [signal]</tt></h3>
<p>This signal is emitted when a delayed close is finished.</p>
<p>If you call <a href="q3socket.html#close">close</a>() and there is buffered output data to be written, <a href="q3socket.html" class="compat">Q3Socket</a> goes into the <a href="q3socket.html#State-enum">Q3Socket::Closing</a> state and returns immediately. It will then keep writing to the socket until all the data has been written. Then, the delayedCloseFinished() signal is emitted.</p>
<p>See also <a href="q3socket.html#close">close</a>().</p>
<!-- @@@delayedCloseFinished -->
<!-- $$$error[overload1]$$$errorint -->
<h3 class="fn"><a name="error"></a>void Q3Socket::error ( int <i>error</i> )<tt> [signal]</tt></h3>
<p>This signal is emitted after an error occurred. The <i>error</i> parameter is the <a href="q3socket.html#Error-enum">Error</a> value.</p>
<!-- @@@error -->
<!-- $$$flush[overload1]$$$flush -->
<h3 class="fn"><a name="flush"></a>bool Q3Socket::flush ()</h3>
<p>Implementation of the abstract virtual QIODevice::flush() function. This function always returns true.</p>
<!-- @@@flush -->
<!-- $$$getch[overload1]$$$getch -->
<h3 class="fn"><a name="getch"></a>int Q3Socket::getch ()</h3>
<p>Reads a single byte/character from the internal read buffer. Returns the byte/character read, or -1 if there is nothing to be read.</p>
<p>See also <a href="q3socket.html#bytesAvailable">bytesAvailable</a>() and <a href="q3socket.html#putch">putch</a>().</p>
<!-- @@@getch -->
<!-- $$$hostFound[overload1]$$$hostFound -->
<h3 class="fn"><a name="hostFound"></a>void Q3Socket::hostFound ()<tt> [signal]</tt></h3>
<p>This signal is emitted after <a href="q3socket.html#connectToHost">connectToHost</a>() has been called and the host lookup has succeeded.</p>
<p>See also <a href="q3socket.html#connected">connected</a>().</p>
<!-- @@@hostFound -->
<!-- $$$open[overload1]$$$openOpenMode -->
<h3 class="fn"><a name="open"></a>bool Q3Socket::open ( <a href="qiodevice.html#OpenModeFlag-enum">OpenMode</a> <i>m</i> )<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#open">QIODevice::open</a>().</p>
<p>Opens the socket using the specified <a href="qiodevice.html">QIODevice</a> file mode <i>m</i>. This function is called automatically when needed and you should not call it yourself.</p>
<p>See also <a href="q3socket.html#close">close</a>().</p>
<!-- @@@open -->
<!-- $$$open$$$openint -->
<h3 class="fn"><a name="open-2"></a>bool Q3Socket::open ( int <i>m</i> )</h3>
<p>This is an overloaded function.</p>
<!-- @@@open -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn"><a name="peerAddress"></a><a href="qhostaddress.html">QHostAddress</a> Q3Socket::peerAddress () const</h3>
<p>Returns the address of the connected peer if the socket is in Connected state; otherwise an empty <a href="qhostaddress.html">QHostAddress</a> is returned.</p>
<!-- @@@peerAddress -->
<!-- $$$peerName[overload1]$$$peerName -->
<h3 class="fn"><a name="peerName"></a><a href="qstring.html">QString</a> Q3Socket::peerName () const</h3>
<p>Returns the host name as specified to the <a href="q3socket.html#connectToHost">connectToHost</a>() function. An empty string is returned if none has been set.</p>
<!-- @@@peerName -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn"><a name="peerPort"></a><a href="qtglobal.html#Q_UINT16-typedef">Q_UINT16</a> Q3Socket::peerPort () const</h3>
<p>Returns the peer's host port number, normally as specified to the <a href="q3socket.html#connectToHost">connectToHost</a>() function. If none has been set, this function returns 0.</p>
<p>Note that Qt always uses native byte order, i.e&#x2e; 67 is 67 in Qt; there is no need to call htons().</p>
<!-- @@@peerPort -->
<!-- $$$port[overload1]$$$port -->
<h3 class="fn"><a name="port"></a><a href="qtglobal.html#Q_UINT16-typedef">Q_UINT16</a> Q3Socket::port () const</h3>
<p>Returns the host port number of this socket, in native byte order.</p>
<!-- @@@port -->
<!-- $$$putch[overload1]$$$putchint -->
<h3 class="fn"><a name="putch"></a>int Q3Socket::putch ( int <i>ch</i> )</h3>
<p>Writes the character <i>ch</i> to the output buffer.</p>
<p>Returns <i>ch</i>, or -1 if an error occurred.</p>
<p>See also <a href="q3socket.html#getch">getch</a>().</p>
<!-- @@@putch -->
<!-- $$$readBufferSize[overload1]$$$readBufferSize -->
<h3 class="fn"><a name="readBufferSize"></a><a href="qtglobal.html#Q_ULONG-typedef">Q_ULONG</a> Q3Socket::readBufferSize () const</h3>
<p>Returns the size of the read buffer.</p>
<p>See also <a href="q3socket.html#setReadBufferSize">setReadBufferSize</a>().</p>
<!-- @@@readBufferSize -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn"><a name="readData"></a><a href="qtglobal.html#qint64-typedef">qint64</a> Q3Socket::readData ( char * <i>data</i>, <a href="qtglobal.html#qint64-typedef">qint64</a> <i>maxlen</i> )<tt> [virtual protected]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#readData">QIODevice::readData</a>().</p>
<p>Reads <i>maxlen</i> bytes from the socket into <i>data</i> and returns the number of bytes read. Returns -1 if an error occurred.</p>
<!-- @@@readData -->
<!-- $$$readyRead[overload1]$$$readyRead -->
<h3 class="fn"><a name="readyRead"></a>void Q3Socket::readyRead ()<tt> [signal]</tt></h3>
<p>This signal is emitted every time there is new incoming data.</p>
<p>Bear in mind that new incoming data is only reported once; if you do not read all the data, this class buffers the data and you can read it later, but no signal is emitted unless new data arrives. A good practice is to read all data in the slot connected to this signal unless you are sure that you need to receive more data to be able to process it.</p>
<p>See also <a href="qiodevice.html#readBlock" class="compat">readBlock</a>(), <a href="qiodevice.html#readLine">readLine</a>(), and <a href="q3socket.html#bytesAvailable">bytesAvailable</a>().</p>
<!-- @@@readyRead -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeQ_ULONG -->
<h3 class="fn"><a name="setReadBufferSize"></a>void Q3Socket::setReadBufferSize ( <a href="qtglobal.html#Q_ULONG-typedef">Q_ULONG</a> <i>bufSize</i> )</h3>
<p>Sets the size of the <a href="q3socket.html" class="compat">Q3Socket</a>'s internal read buffer to <i>bufSize</i>.</p>
<p>Usually <a href="q3socket.html" class="compat">Q3Socket</a> reads all data that is available from the operating system's socket. If the buffer size is limited to a certain size, this means that the <a href="q3socket.html" class="compat">Q3Socket</a> class doesn't buffer more than this size of data.</p>
<p>If the size of the read buffer is 0, the read buffer is unlimited and all incoming data is buffered. This is the default.</p>
<p>If you read the data in the <a href="q3socket.html#readyRead">readyRead</a>() signal, you shouldn't use this option since it might slow down your program unnecessary. This option is useful if you only need to read the data at certain points in time, like in a realtime streaming application.</p>
<p>See also <a href="q3socket.html#readBufferSize">readBufferSize</a>().</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setSocket[overload1]$$$setSocketint -->
<h3 class="fn"><a name="setSocket"></a>void Q3Socket::setSocket ( int <i>socket</i> )<tt> [virtual]</tt></h3>
<p>Sets the socket to use <i>socket</i> and the <a href="q3socket.html#state">state</a>() to <tt>Connected</tt>. The socket must already be connected.</p>
<p>This allows us to use the <a href="q3socket.html" class="compat">Q3Socket</a> class as a wrapper for other socket types (e.g&#x2e; Unix Domain Sockets).</p>
<p>See also <a href="q3socket.html#socket">socket</a>().</p>
<!-- @@@setSocket -->
<!-- $$$setSocketDevice[overload1]$$$setSocketDeviceQ3SocketDevice* -->
<h3 class="fn"><a name="setSocketDevice"></a>void Q3Socket::setSocketDevice ( <a href="q3socketdevice.html">Q3SocketDevice</a> * <i>device</i> )<tt> [virtual]</tt></h3>
<p>Sets the internal socket device to <i>device</i>. Passing a <i>device</i> of 0 will cause the internal socket device to be used. Any existing connection will be disconnected before using the new <i>device</i>.</p>
<p>The new device should not be connected before being associated with a <a href="q3socket.html" class="compat">Q3Socket</a>; after setting the socket call <a href="q3socket.html#connectToHost">connectToHost</a>() to make the connection.</p>
<p>This function is useful if you need to subclass <a href="q3socketdevice.html" class="compat">Q3SocketDevice</a> and want to use the <a href="q3socket.html" class="compat">Q3Socket</a> API, for example, to implement Unix domain sockets.</p>
<p>See also <a href="q3socket.html#socketDevice">socketDevice</a>().</p>
<!-- @@@setSocketDevice -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn"><a name="size"></a><a href="qiodevice.html#Offset-typedef">Offset</a> Q3Socket::size () const<tt> [virtual]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#size">QIODevice::size</a>().</p>
<p>Returns the number of incoming bytes that can be read right now (like <a href="q3socket.html#bytesAvailable">bytesAvailable</a>()).</p>
<!-- @@@size -->
<!-- $$$socket[overload1]$$$socket -->
<h3 class="fn"><a name="socket"></a>int Q3Socket::socket () const</h3>
<p>Returns the socket number, or -1 if there is no socket at the moment.</p>
<p>See also <a href="q3socket.html#setSocket">setSocket</a>().</p>
<!-- @@@socket -->
<!-- $$$socketDevice[overload1]$$$socketDevice -->
<h3 class="fn"><a name="socketDevice"></a><a href="q3socketdevice.html">Q3SocketDevice</a> * Q3Socket::socketDevice ()</h3>
<p>Returns a pointer to the internal socket device.</p>
<p>There is normally no need to manipulate the socket device directly since this class does the necessary setup for most applications.</p>
<p>See also <a href="q3socket.html#setSocketDevice">setSocketDevice</a>().</p>
<!-- @@@socketDevice -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn"><a name="state"></a><a href="q3socket.html#State-enum">State</a> Q3Socket::state () const</h3>
<p>Returns the current state of the socket connection.</p>
<p>See also <a href="q3socket.html#State-enum">Q3Socket::State</a>.</p>
<!-- @@@state -->
<!-- $$$ungetch[overload1]$$$ungetchint -->
<h3 class="fn"><a name="ungetch"></a>int Q3Socket::ungetch ( int <i>ch</i> )</h3>
<p>This implementation of the virtual function <a href="qiodevice.html#ungetch" class="compat">QIODevice::ungetch</a>() prepends the character <i>ch</i> to the read buffer so that the next read returns this character as the first character of the output.</p>
<!-- @@@ungetch -->
<!-- $$$waitForMore[overload1]$$$waitForMoreintbool* -->
<h3 class="fn"><a name="waitForMore"></a><a href="qtglobal.html#Q_ULONG-typedef">Q_ULONG</a> Q3Socket::waitForMore ( int <i>msecs</i>, bool * <i>timeout</i> ) const</h3>
<p>Wait up to <i>msecs</i> milliseconds for more data to be available.</p>
<p>If <i>msecs</i> is -1 the call will block indefinitely.</p>
<p>Returns the number of bytes available.</p>
<p>If <i>timeout</i> is non-null and no error occurred (i.e&#x2e; it does not return -1): this function sets *<i>timeout</i> to true, if the reason for returning was that the timeout was reached; otherwise it sets *<i>timeout</i> to false. This is useful to find out if the peer closed the connection.</p>
<p><b>Warning:</b> This is a blocking call and should be avoided in event driven applications.</p>
<p>See also <a href="q3socket.html#bytesAvailable">bytesAvailable</a>().</p>
<!-- @@@waitForMore -->
<!-- $$$waitForMore$$$waitForMoreint -->
<h3 class="fn"><a name="waitForMore-2"></a><a href="qtglobal.html#Q_ULONG-typedef">Q_ULONG</a> Q3Socket::waitForMore ( int <i>msecs</i> ) const</h3>
<p>This is an overloaded function.</p>
<!-- @@@waitForMore -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn"><a name="writeData"></a><a href="qtglobal.html#qint64-typedef">qint64</a> Q3Socket::writeData ( const char * <i>data</i>, <a href="qtglobal.html#qint64-typedef">qint64</a> <i>len</i> )<tt> [virtual protected]</tt></h3>
<p>Reimplemented from <a href="qiodevice.html#writeData">QIODevice::writeData</a>().</p>
<p>Writes <i>len</i> bytes to the socket from <i>data</i> and returns the number of bytes written. Returns -1 if an error occurred.</p>
<!-- @@@writeData -->
</div>
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
