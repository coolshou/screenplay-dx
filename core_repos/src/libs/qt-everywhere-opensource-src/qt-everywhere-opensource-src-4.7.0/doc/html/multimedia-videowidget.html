<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- videowidget.qdoc -->
  <title>Qt 4.7: Video Widget Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="all-examples.html">Examples</a></li>              <li><a href="examples-multimedia.html">Multimedia Examples</a></li>              <li>Video Widget Example</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#videowidgetsurface-class-definition">VideoWidgetSurface Class Definition</a></li>
<li class="level1"><a href="#videowidgetsurface-class-implementation">VideoWidgetSurface Class Implementation</a></li>
<li class="level1"><a href="#videowidget-class-definition">VideoWidget Class Definition</a></li>
<li class="level1"><a href="#videowidget-class-implementation">VideoWidget Class Implementation</a></li>
</ul>
</div>
<h1 class="title">Video Widget Example</h1>
<span class="subtitle"></span>
<!-- $$$multimedia/videowidget-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="multimedia-videowidget-videoplayer-cpp.html">multimedia/videowidget/videoplayer.cpp</a></li>
<li><a href="multimedia-videowidget-videoplayer-h.html">multimedia/videowidget/videoplayer.h</a></li>
<li><a href="multimedia-videowidget-videowidget-cpp.html">multimedia/videowidget/videowidget.cpp</a></li>
<li><a href="multimedia-videowidget-videowidget-h.html">multimedia/videowidget/videowidget.h</a></li>
<li><a href="multimedia-videowidget-videowidgetsurface-cpp.html">multimedia/videowidget/videowidgetsurface.cpp</a></li>
<li><a href="multimedia-videowidget-videowidgetsurface-h.html">multimedia/videowidget/videowidgetsurface.h</a></li>
<li><a href="multimedia-videowidget-main-cpp.html">multimedia/videowidget/main.cpp</a></li>
<li><a href="multimedia-videowidget-videowidget-pro.html">multimedia/videowidget/videowidget.pro</a></li>
</ul>
<p>The Video Widget example shows how to implement a video widget using <a href="qtmultimedia.html">QtMultimedia</a>'s <a href="qabstractvideosurface.html">QAbstractVideoSurface</a></p>
<p class="centerAlign"><img src="images/video-videowidget.png" /></p><a name="videowidgetsurface-class-definition"></a>
<h2>VideoWidgetSurface Class Definition</h2>
<pre class="highlightedCode brush: cpp"> class VideoWidgetSurface : public QAbstractVideoSurface
 {
     Q_OBJECT
 public:
     VideoWidgetSurface(QWidget *widget, QObject *parent = 0);

     QList&lt;QVideoFrame::PixelFormat&gt; supportedPixelFormats(
             QAbstractVideoBuffer::HandleType handleType = QAbstractVideoBuffer::NoHandle) const;
     bool isFormatSupported(const QVideoSurfaceFormat &amp;format, QVideoSurfaceFormat *similar) const;

     bool start(const QVideoSurfaceFormat &amp;format);
     void stop();

     bool present(const QVideoFrame &amp;frame);

     QRect videoRect() const { return targetRect; }
     void updateVideoRect();

     void paint(QPainter *painter);

 private:
     QWidget *widget;
     QImage::Format imageFormat;
     QRect targetRect;
     QSize imageSize;
     QRect sourceRect;
     QVideoFrame currentFrame;
 };</pre>
<p>The VideoWidgetSurface class inherits <a href="qabstractvideosurface.html">QAbstractVideoSurface</a> and paints video frames on a <a href="qwidget.html">QWidget</a>. This is a separate class to VideoWidget as both <a href="qabstractvideosurface.html">QAbstractVideoSurface</a> and <a href="qwidget.html">QWidget</a> inherit <a href="qobject.html">QObject</a>.</p>
<p>In addition to the functions from <a href="qabstractvideosurface.html">QAbstractVideoSurface</a>, VideoWidgetSurface has functions for determining the video display rectangle, and painting the video.</p>
<a name="videowidgetsurface-class-implementation"></a>
<h2>VideoWidgetSurface Class Implementation</h2>
<pre class="highlightedCode brush: cpp"> QList&lt;QVideoFrame::PixelFormat&gt; VideoWidgetSurface::supportedPixelFormats(
         QAbstractVideoBuffer::HandleType handleType) const
 {
     if (handleType == QAbstractVideoBuffer::NoHandle) {
         return QList&lt;QVideoFrame::PixelFormat&gt;()
                 &lt;&lt; QVideoFrame::Format_RGB32
                 &lt;&lt; QVideoFrame::Format_ARGB32
                 &lt;&lt; QVideoFrame::Format_ARGB32_Premultiplied
                 &lt;&lt; QVideoFrame::Format_RGB565
                 &lt;&lt; QVideoFrame::Format_RGB555;
     } else {
         return QList&lt;QVideoFrame::PixelFormat&gt;();
     }
 }</pre>
<p>From the supportedPixelFormats() function we return a list of pixel formats the surface can paint. The order of the list hints at which formats are preferred by the surface. Assuming a 32-bit RGB backbuffer, we'd expect that a 32-bit RGB type with no alpha to be fastest to paint so QVideoFrame::Image_RGB32 is first in the list.</p>
<p>Since we don't support rendering using any special frame handles we don't return any pixel formats if handleType is not <a href="qabstractvideobuffer.html#HandleType-enum">QAbstractVideoBuffer::NoHandle</a>.</p>
<pre class="highlightedCode brush: cpp"> bool VideoWidgetSurface::isFormatSupported(
         const QVideoSurfaceFormat &amp;format, QVideoSurfaceFormat *similar) const
 {
     Q_UNUSED(similar);

     const QImage::Format imageFormat = QVideoFrame::imageFormatFromPixelFormat(format.pixelFormat());
     const QSize size = format.frameSize();

     return imageFormat != QImage::Format_Invalid
             &amp;&amp; !size.isEmpty()
             &amp;&amp; format.handleType() == QAbstractVideoBuffer::NoHandle;
 }</pre>
<p>In isFormatSupported() we test if the frame type of a surface format maps to a valid <a href="qimage.html">QImage</a> format, that the frame size is not empty, and the handle type is <a href="qabstractvideobuffer.html#HandleType-enum">QAbstractVideoBuffer::NoHandle</a>. Note that the <a href="qabstractvideosurface.html">QAbstractVideoSurface</a> implementation of isFormatSupported() will verify that the list of supported pixel formats returned by <tt>supportedPixelFormats(format.handleType())</tt> contains the pixel format and that the size is not empty so a reimplementation wasn't strictly necessary in this case.</p>
<pre class="highlightedCode brush: cpp"> bool VideoWidgetSurface::start(const QVideoSurfaceFormat &amp;format)
 {
     const QImage::Format imageFormat = QVideoFrame::imageFormatFromPixelFormat(format.pixelFormat());
     const QSize size = format.frameSize();

     if (imageFormat != QImage::Format_Invalid &amp;&amp; !size.isEmpty()) {
         this-&gt;imageFormat = imageFormat;
         imageSize = size;
         sourceRect = format.viewport();

         QAbstractVideoSurface::start(format);

         widget-&gt;updateGeometry();
         updateVideoRect();

         return true;
     } else {
         return false;
     }
 }</pre>
<p>To start our surface we'll extract the image format and size from the selected video format and save it for use in the paint() function. If the image format, or size are invalid then we'll set an error and return false. Otherwise we'll save the format and confirm the surface has been started, by calling <a href="qabstractvideosurface.html#start">QAbstractVideoSurface::start</a>(). Finally since the video size may have changed we'll trigger an update of the widget, and video geometry.</p>
<pre class="highlightedCode brush: cpp"> void VideoWidgetSurface::updateVideoRect()
 {
     QSize size = surfaceFormat().sizeHint();
     size.scale(widget-&gt;size().boundedTo(size), Qt::KeepAspectRatio);

     targetRect = QRect(QPoint(0, 0), size);
     targetRect.moveCenter(widget-&gt;rect().center());
 }</pre>
<p>The updateVideoRect() function calculates the region within the widget the video occupies. The <a href="qvideosurfaceformat.html#sizeHint">size hint</a> of the video format gives a suggested size for the video calculated from the <a href="qvideosurfaceformat.html#viewport">viewport</a> and <a href="qvideosurfaceformat.html#pixelAspectRatio">pixel aspect ratio</a>. If the suggested size fits within the widget then we create a new rect of that size in the center of the widget. Otherwise we shrink the size maintaining the aspect ratio so that it does fit.</p>
<pre class="highlightedCode brush: cpp"> bool VideoWidgetSurface::present(const QVideoFrame &amp;frame)
 {
     if (surfaceFormat().pixelFormat() != frame.pixelFormat()
             || surfaceFormat().frameSize() != frame.size()) {
         setError(IncorrectFormatError);
         stop();

         return false;
     } else {
         currentFrame = frame;

         widget-&gt;repaint(targetRect);

         return true;
     }
 }</pre>
<p>We can't paint from outside a paint event, so when a new frame is received in present() we save a reference to it and force an immediate repaint of the video region. We retain the saved reference to the frame after the repaint so that the widget can be repainted between frame changes if necessary.</p>
<p>If the format of the frame doesn't match the surface format we can't paint it or very likely any future frames. So we set an <a href="qabstractvideosurface.html#Error-enum">UnsupportedFormatError</a> on our surface and stop it immediately.</p>
<pre class="highlightedCode brush: cpp"> void VideoWidgetSurface::paint(QPainter *painter)
 {
     if (currentFrame.map(QAbstractVideoBuffer::ReadOnly)) {
         const QTransform oldTransform = painter-&gt;transform();

         if (surfaceFormat().scanLineDirection() == QVideoSurfaceFormat::BottomToTop) {
            painter-&gt;scale(1, -1);
            painter-&gt;translate(0, -widget-&gt;height());
         }

         QImage image(
                 currentFrame.bits(),
                 currentFrame.width(),
                 currentFrame.height(),
                 currentFrame.bytesPerLine(),
                 imageFormat);

         painter-&gt;drawImage(targetRect, image, sourceRect);

         painter-&gt;setTransform(oldTransform);

         currentFrame.unmap();
     }
 }</pre>
<p>The paint() function is called by the video widget to paint the current video frame. Before we draw the frame first we'll check the format for the scan line direction and if the scan lines are arranged from bottom to top we'll flip the painter so the frame isn't drawn upside down. Then using the image format information saved in the start() function we'll construct a new <a href="qimage.html">QImage</a> from the current video frame, and draw it to the the widget.</p>
<pre class="highlightedCode brush: cpp"> void VideoWidgetSurface::stop()
 {
     currentFrame = QVideoFrame();
     targetRect = QRect();

     QAbstractVideoSurface::stop();

     widget-&gt;update();
 }</pre>
<p>When the surface is stopped we need to release the current frame and invalidate the video region. Then we confirm the surface has been stopped by calling <a href="qabstractvideosurface.html#stop">QAbstractVideoSurface::stop</a>() which sets the started state to false and finally we update so the video widget so paints over the last frame.</p>
<a name="videowidget-class-definition"></a>
<h2>VideoWidget Class Definition</h2>
<p>The VideoWidget class uses the VideoWidgetSurface class to implement a video widget.</p>
<pre class="highlightedCode brush: cpp"> class VideoWidget : public QWidget
 {
     Q_OBJECT
 public:
     VideoWidget(QWidget *parent = 0);
     ~VideoWidget();

     QAbstractVideoSurface *videoSurface() const { return surface; }

     QSize sizeHint() const;

 protected:
     void paintEvent(QPaintEvent *event);
     void resizeEvent(QResizeEvent *event);

 private:
     VideoWidgetSurface *surface;
 };</pre>
<p>The VideoWidget <a href="qwidget.html">QWidget</a> implementation is minimal with just the sizeHint(), paintEvent(), and resizeEvent() functions in addition to the constructor, destructor and an instance of VideoWidgetSurface.</p>
<a name="videowidget-class-implementation"></a>
<h2>VideoWidget Class Implementation</h2>
<pre class="highlightedCode brush: cpp"> VideoWidget::VideoWidget(QWidget *parent)
     : QWidget(parent)
     , surface(0)
 {
     setAutoFillBackground(false);
     setAttribute(Qt::WA_NoSystemBackground, true);
     setAttribute(Qt::WA_PaintOnScreen, true);

     QPalette palette = this-&gt;palette();
     palette.setColor(QPalette::Background, Qt::black);
     setPalette(palette);

     setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding);

     surface = new VideoWidgetSurface(this);
 }</pre>
<p>In the VideoWidget constructor we set some flags to speed up re-paints a little. Setting the <a href="qt.html#WidgetAttribute-enum">Qt::WA_NoSystemBackground</a> flag and disabling automatic background fills will stop Qt from a painting a background that'll be completely obscured by the video. The <a href="qt.html#WidgetAttribute-enum">Qt::WA_PaintOnScreen</a> flag will allow us to paint to the screen instead of the back buffer where supported.</p>
<p>Next we set the background color to black, so that any borders around the video are filled in black rather the default background color.</p>
<p>Finally we construct an instance of the VideoWidgetSurface class.</p>
<pre class="highlightedCode brush: cpp"> VideoWidget::~VideoWidget()
 {
     delete surface;
 }</pre>
<p>In the destructor we simply delete the VideoWidgetSurface instance.</p>
<pre class="highlightedCode brush: cpp"> QSize VideoWidget::sizeHint() const
 {
     return surface-&gt;surfaceFormat().sizeHint();
 }</pre>
<p>We get the size hint for the widget from the video format of the surface which is calculated from viewport and pixel aspect ratio of the video format.</p>
<pre class="highlightedCode brush: cpp"> void VideoWidget::paintEvent(QPaintEvent *event)
 {
     QPainter painter(this);

     if (surface-&gt;isActive()) {
         const QRect videoRect = surface-&gt;videoRect();

         if (!videoRect.contains(event-&gt;rect())) {
             QRegion region = event-&gt;region();
             region.subtract(videoRect);

             QBrush brush = palette().background();

             foreach (const QRect &amp;rect, region.rects())
                 painter.fillRect(rect, brush);
         }

         surface-&gt;paint(&amp;painter);
     } else {
         painter.fillRect(event-&gt;rect(), palette().background());
     }
 }</pre>
<p>When the video widget receives a paint event we first check if the surface is started, if not then we simply fill the widget with the background color. If it is then we draw a border around the video region clipped by the paint region, before calling paint on the video surface to draw the current frame.</p>
<pre class="highlightedCode brush: cpp"> void VideoWidget::resizeEvent(QResizeEvent *event)
 {
     QWidget::resizeEvent(event);

     surface-&gt;updateVideoRect();
 }</pre>
<p>The resizeEvent() function is reimplemented to trigger an update of the video region when the widget is resized.</p>
</div>
<!-- @@@multimedia/videowidget -->
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
