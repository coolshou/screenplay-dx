<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- padnavigator.qdoc -->
  <title>Qt 4.7: Pad Navigator Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="all-examples.html">Examples</a></li>              <li><a href="examples-graphicsview.html">Graphics View Examples</a></li>              <li>Pad Navigator Example</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#roundrectitem-class-definition">RoundRectItem Class Definition</a></li>
<li class="level1"><a href="#flippablepad-class-definition">FlippablePad Class Definition</a></li>
<li class="level1"><a href="#splashitem-class-definition">SplashItem Class Definition</a></li>
<li class="level1"><a href="#padnavigator-class-definition">PadNavigator Class Definition</a></li>
<li class="level1"><a href="#the-main-function">The main() Function</a></li>
<li class="level1"><a href="#performance-notes">Performance Notes</a></li>
</ul>
</div>
<h1 class="title">Pad Navigator Example</h1>
<span class="subtitle"></span>
<!-- $$$graphicsview/padnavigator-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="graphicsview-padnavigator-flippablepad-cpp.html">graphicsview/padnavigator/flippablepad.cpp</a></li>
<li><a href="graphicsview-padnavigator-flippablepad-h.html">graphicsview/padnavigator/flippablepad.h</a></li>
<li><a href="graphicsview-padnavigator-form-ui.html">graphicsview/padnavigator/form.ui</a></li>
<li><a href="graphicsview-padnavigator-padnavigator-cpp.html">graphicsview/padnavigator/padnavigator.cpp</a></li>
<li><a href="graphicsview-padnavigator-padnavigator-h.html">graphicsview/padnavigator/padnavigator.h</a></li>
<li><a href="graphicsview-padnavigator-roundrectitem-cpp.html">graphicsview/padnavigator/roundrectitem.cpp</a></li>
<li><a href="graphicsview-padnavigator-roundrectitem-h.html">graphicsview/padnavigator/roundrectitem.h</a></li>
<li><a href="graphicsview-padnavigator-splashitem-cpp.html">graphicsview/padnavigator/splashitem.cpp</a></li>
<li><a href="graphicsview-padnavigator-splashitem-h.html">graphicsview/padnavigator/splashitem.h</a></li>
<li><a href="graphicsview-padnavigator-main-cpp.html">graphicsview/padnavigator/main.cpp</a></li>
<li><a href="graphicsview-padnavigator-padnavigator-pro.html">graphicsview/padnavigator/padnavigator.pro</a></li>
<li><a href="graphicsview-padnavigator-padnavigator-qrc.html">graphicsview/padnavigator/padnavigator.qrc</a></li>
</ul>
<p>Images:</p>
<ul>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/artsfftscope.png">graphicsview/padnavigator/images/artsfftscope.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/kontact_contacts.png">graphicsview/padnavigator/images/kontact_contacts.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/kontact_journal.png">graphicsview/padnavigator/images/kontact_journal.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/kontact_mail.png">graphicsview/padnavigator/images/kontact_mail.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/kontact_notes.png">graphicsview/padnavigator/images/kontact_notes.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/kopeteavailable.png">graphicsview/padnavigator/images/kopeteavailable.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/metacontact_online.png">graphicsview/padnavigator/images/metacontact_online.png</a></li>
<li><a href="images/used-in-examples/graphicsview/padnavigator/images/minitools.png">graphicsview/padnavigator/images/minitools.png</a></li>
</ul>
<p>The Pad Navigator Example shows how you can use Graphics View together with embedded widgets and Qt's <a href="qt4-6-intro.html#state-machine-framework">State Machine Framework</a> to create a simple but useful, dynamic, animated user interface.</p>
<p class="centerAlign"><img src="images/padnavigator-example.png" /></p><p>The interface consists of a flippable, rotating pad with icons that can be selected using the arrow keys on your keyboard or keypad. Pressing enter will flip the pad around and reveal its back side, which has a form embedded into a <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a>. You can interact with the form, and press the enter key to flip back to the front side of the pad at any time.</p>
<p>Graphics View provides the <a href="qgraphicsscene.html">QGraphicsScene</a> class for managing and interacting with a large number of custom-made 2D graphical items derived from the <a href="qgraphicsitem.html">QGraphicsItem</a> class, and a <a href="qgraphicsview.html">QGraphicsView</a> widget for visualizing the items, with support for zooming and rotation.</p>
<p>This example consists of a <tt>RoundRectItem</tt> class, a <tt>FlippablePad</tt> class, a <tt>PadNavigator</tt> class, a <tt>SplashItem</tt> class, and a <tt>main()</tt> function.</p>
<a name="roundrectitem-class-definition"></a>
<h2>RoundRectItem Class Definition</h2>
<p>The <tt>RoundRectItem</tt> class is used by itself to diplay the icons on the pad, and as a base class for <tt>FlippablePad</tt>, the class for the pad itself. The role of the class is to paint a round rectangle of a specified size and gradient color, and optionally to paint a pixmap icon on top. To support <tt>FlippablePad</tt> it also allows filling its contents with a plain window background color.</p>
<p>Let's start by reviewing the <tt>RoundRectItem</tt> class declaration.</p>
<pre class="highlightedCode brush: cpp"> class RoundRectItem : public QGraphicsObject
 {
     Q_OBJECT
     Q_PROPERTY(bool fill READ fill WRITE setFill)
 public:
     RoundRectItem(const QRectF &amp;bounds, const QColor &amp;color,
                   QGraphicsItem *parent = 0);

     QPixmap pixmap() const;
     void setPixmap(const QPixmap &amp;pixmap);

     QRectF boundingRect() const;
     void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

     bool fill() const;
     void setFill(bool fill);</pre>
<p><tt>RoundRectItem</tt> inherits <a href="qgraphicsobject.html">QGraphicsObject</a>, which makes it easy to control its properties using <a href="qpropertyanimation.html">QPropertyAnimation</a>. Its constructor takes a rectangle to determine its bounds, and a color.</p>
<p>Besides implementing the mandatory <a href="qgraphicsitem.html#paint">paint()</a> and <a href="qgraphicsitem.html#boundingRect">boundingRect()</a> pure virtual functions, it also provides the <tt>pixmap</tt> and <tt>fill</tt> properties.</p>
<p>The <tt>pixmap</tt> property sets an optional pixmap that is drawn on top of the round rectangle. The <tt>fill</tt> property will, when true, fill the round rectangle contents with a fixed <a href="qpalette.html#ColorRole-enum">QPalette::Window</a> background color. Otherwise the contents are filled using a gradient based on the color passed to <tt>RoundRectItem</tt>'s constructor.</p>
<pre class="highlightedCode brush: cpp"> private:
     QPixmap pix;
     bool fillRect;
     QRectF bounds;
     QLinearGradient gradient;
 };</pre>
<p>The private data members are:</p>
<ul>
<li><tt>pix</tt>: The optional pixmap that is drawn on top of the rectangle.</li>
<li><tt>fillRect</tt>: Corresponds to the <tt>fill</tt> property.</li>
<li><tt>color</tt>: The configurable gradient color fill of the rectangle.</li>
<li><tt>bounds</tt>: The bounds of the rectangle.</li>
<li><tt>gradient</tt>: A precalculated gradient used to fill the rectangle.</li>
</ul>
<p>We will now review the <tt>RoundRectItem</tt> implementation. Let's start by looking at its constructor:</p>
<pre class="highlightedCode brush: cpp"> RoundRectItem::RoundRectItem(const QRectF &amp;bounds, const QColor &amp;color,
                              QGraphicsItem *parent)
     : QGraphicsObject(parent), fillRect(false), bounds(bounds)
 {
     gradient.setStart(bounds.topLeft());
     gradient.setFinalStop(bounds.bottomRight());
     gradient.setColorAt(0, color);
     gradient.setColorAt(1, color.dark(200));
     setCacheMode(ItemCoordinateCache);
 }</pre>
<p>The constructor initializes its member variables and forwards the <tt>parent</tt> argument to <a href="qgraphicsobject.html">QGraphicsObject</a>'s constructor. It then constructs the linear gradient that is used in <a href="qgraphicsitem.html#paint">paint()</a> to draw the round rectangle's gradient background. The linear gradient's starting point is at the top-left corner of the bounds, and the end is at the bottom-left corner. The start color is identical to the color passed as an argument, and a slightly darker color is chosen for the final stop.</p>
<p>We store this gradient as a member variable to avoid having to recreate the gradient every time the item is repainted.</p>
<p>Finally we set the cache mode <a href="qgraphicsitem.html#CacheMode-enum">ItemCoordinateCache</a>. This mode causes the item's rendering to be cached into an off-screen pixmap that remains persistent as we move and transform the item. This mode is ideal for this example, and works particularily well with OpenGL and OpenGL ES.</p>
<pre class="highlightedCode brush: cpp"> QPixmap RoundRectItem::pixmap() const
 {
     return pix;
 }
 void RoundRectItem::setPixmap(const QPixmap &amp;pixmap)
 {
     pix = pixmap;
     update();
 }</pre>
<p>The <tt>pixmap</tt> property implementation simple returns the member pixmap, or sets it and then calls <a href="qgraphicsitem.html#update">update()</a>.</p>
<pre class="highlightedCode brush: cpp"> QRectF RoundRectItem::boundingRect() const
 {
     return bounds.adjusted(0, 0, 2, 2);
 }</pre>
<p>As the <a href="qgraphicsitem.html#paint">paint()</a> implementation below draws a simple drop shadow down and to the right of the item, we return a slightly adjusted rectangle from <a href="qgraphicsitem.html#boundingRect">boundingRect()</a>.</p>
<pre class="highlightedCode brush: cpp"> void RoundRectItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
                           QWidget *widget)
 {
     Q_UNUSED(option);
     Q_UNUSED(widget);
     painter-&gt;setPen(Qt::NoPen);
     painter-&gt;setBrush(QColor(0, 0, 0, 64));
     painter-&gt;drawRoundRect(bounds.translated(2, 2));</pre>
<p>The <a href="qgraphicsitem.html#paint">paint()</a> implementation starts by rendering a semi transparent black round rectangle drop shadow, two units down and to the right of the main item.</p>
<pre class="highlightedCode brush: cpp">     if (fillRect)
         painter-&gt;setBrush(QApplication::palette().brush(QPalette::Window));
     else
         painter-&gt;setBrush(gradient);
     painter-&gt;setPen(QPen(Qt::black, 1));
     painter-&gt;drawRoundRect(bounds);</pre>
<p>We then draw the &quot;foreground&quot; round rectangle itself. The fill depends on the <tt>fill</tt> property; if true, we will with a plain <a href="qpalette.html#ColorRole-enum">QPalette::Window</a> color. We get the corrent brush from <a href="qapplication.html#palette">QApplication::palette</a>(). We assign a single unit wide pen for the stroke, assign the brush, and then draw the rectangle.</p>
<pre class="highlightedCode brush: cpp">     if (!pix.isNull()) {
         painter-&gt;scale(1.95, 1.95);
         painter-&gt;drawPixmap(-pix.width() / 2, -pix.height() / 2, pix);
     }
 }</pre>
<p>If a pixmap has been assigned to the <i>pixmap</i> property, we draw this pixmap in the center of the rectangle item. The pixmaps are scaled to match the size of the icons; in arguably a better approach would have been to store the icons with the right size in the first places.</p>
<pre class="highlightedCode brush: cpp"> bool RoundRectItem::fill() const
 {
     return fillRect;
 }
 void RoundRectItem::setFill(bool fill)
 {
     fillRect = fill;
     update();
 }</pre>
<p>Finally, for completeness we include the <tt>fill</tt> property implementation. It returns the <tt>fill</tt> member variable's value, and when assigned to, it calls <a href="qgraphicsitem.html#update">update()</a>.</p>
<p>As mentioned already, <tt>RoundRectItem</tt> is the base class for <tt>FlippablePad</tt>, which is the class representing the tilting pad itself. We will proceed to reviewing <tt>FlippablePad</tt>.</p>
<a name="flippablepad-class-definition"></a>
<h2>FlippablePad Class Definition</h2>
<p><tt>FlippablePad</tt> is, in addition to its inherited <tt>RoundRectItem</tt> responsibilities, responsible for creating and managing a grid of icons.</p>
<pre class="highlightedCode brush: cpp"> class FlippablePad : public RoundRectItem
 {
 public:
     FlippablePad(const QSize &amp;size, QGraphicsItem *parent = 0);

     RoundRectItem *iconAt(int column, int row) const;

 private:
     QVector&lt;QVector&lt;RoundRectItem *&gt; &gt; iconGrid;
 };</pre>
<p>Its declaration is very simple: It inherits <tt>RoundRectItem</tt> and does not need any special polymorphic behavior. It's suitable to declare its own constructor, and a getter-function that allows <tt>PadNavigator</tt> to access the icons in the grid by (row, column).</p>
<p>The example has no &quot;real&quot; behavior or logic of any kind, and because of that, the icons do not need to provide any <i>behavior</i> or special interactions management. In a real application, however, it would be natural for the <tt>FlippablePad</tt> and its icons to handle more of the navigation logic. In this example, we have chosen to leave this to the <tt>PadNavigator</tt> class, which we will get back to below.</p>
<p>We will now review the <tt>FlippablePad</tt> implementation. This implementation starts with two helper functions: <tt>boundsFromSize()</tt> and <tt>posForLocation()</tt>:</p>
<pre class="highlightedCode brush: cpp"> static QRectF boundsFromSize(const QSize &amp;size)
 {
     return QRectF((-size.width() / 2.0) * 150, (-size.height() / 2.0) * 150,
                   size.width() * 150, size.height() * 150);
 }</pre>
<p><tt>boundsForSize()</tt> takes a <a href="qsize.html">QSize</a> argument, and returns the bounding rectangle of the flippable pad item. The <a href="qsize.html">QSize</a> determines how many rows and columns the icon grid should have. Each icon is given 150x150 units of space, and this determines the bounds.</p>
<pre class="highlightedCode brush: cpp"> static QPointF posForLocation(int column, int row, const QSize &amp;size)
 {
     return QPointF(column * 150, row * 150)
         - QPointF((size.width() - 1) * 75, (size.height() - 1) * 75);
 }</pre>
<p><tt>posForLocation()</tt> returns the position of an icon given its row and column position. Like <tt>boundsForSize()</tt>, the function assumes each icon is given 150x150 units of space, and that all icons are centered around the flippable pad item's origin (0, 0).</p>
<pre class="highlightedCode brush: cpp"> FlippablePad::FlippablePad(const QSize &amp;size, QGraphicsItem *parent)
     : RoundRectItem(boundsFromSize(size), QColor(226, 255, 92, 64), parent)
 {</pre>
<p>The <tt>FlippablePad</tt> constructor passes suitable bounds (using <tt>boundsForSize()</tt>) and specific color to <tt>RoundRectItem</tt>'s constructor.</p>
<pre class="highlightedCode brush: cpp">     int numIcons = size.width() * size.height();
     QList&lt;QPixmap&gt; pixmaps;
     QDirIterator it(&quot;:/images&quot;, QStringList() &lt;&lt; &quot;*.png&quot;);
     while (it.hasNext() &amp;&amp; pixmaps.size() &lt; numIcons)
         pixmaps &lt;&lt; it.next();</pre>
<p>It then loads pixmaps from compiled-in resources to use for its icons. <a href="qdiriterator.html">QDirIterator</a> is very useful in this context, as it allows us to fetch all resource &quot;*.png&quot; files inside the <tt>:/images</tt> directory without explicitly naming the files.</p>
<p>We also make sure not to load more pixmaps than we need.</p>
<pre class="highlightedCode brush: cpp">     const QRectF iconRect(-54, -54, 108, 108);
     const QColor iconColor(214, 240, 110, 128);
     iconGrid.resize(size.height());
     int n = 0;

     for (int y = 0; y &lt; size.height(); ++y) {
         iconGrid[y].resize(size.width());
         for (int x = 0; x &lt; size.width(); ++x) {
             RoundRectItem *rect = new RoundRectItem(iconRect, iconColor, this);
             rect-&gt;setZValue(1);
             rect-&gt;setPos(posForLocation(x, y, size));
             rect-&gt;setPixmap(pixmaps.at(n++ % pixmaps.size()));
             iconGrid[y][x] = rect;
         }
     }
 }</pre>
<p>Now that we have the pixmaps, we can create icons, position then and assign pixmaps. We start by finding a suitable size and color for the icons, and initializing a convenient grid structure for storing the icons. This <tt>iconGrid</tt> is also used later to find the icon for a specific (column, row) location.</p>
<p>For each row and column in our grid, we proceed to constructing each icon as an instance of <tt>RoundRectItem</tt>. The item is placed by using the <tt>posForLocation()</tt> helper function. To make room for the slip-behind selection item, we give each icon a <a href="qgraphicsitem.html#zValue">Z-value</a> of 1. The pixmaps are distributed to the icons in round-robin fasion.</p>
<p>Again, this approach is only suitable for example purposes. In a real-life application where each icon represents a specific action, it would be more natural to assign the pixmaps directly, or that the icons themselves provide suitable pixmaps.</p>
<pre class="highlightedCode brush: cpp"> RoundRectItem *FlippablePad::iconAt(int column, int row) const
 {
     return iconGrid[row][column];
 }</pre>
<p>Finally, the <tt>iconAt()</tt> function returns a pointer to the icon at a specific row and column. It makes a somewhat bold assumption that the input is valid, which is fair because the <tt>PadNavigator</tt> class only calls this function with correct input.</p>
<p>We will now review the <tt>SplashItem</tt> class.</p>
<a name="splashitem-class-definition"></a>
<h2>SplashItem Class Definition</h2>
<p>The <tt>SplashItem</tt> class represents the &quot;splash window&quot;, a semitransparent white overlay with text that appears immediately after the application has started, and disappears after pressing any key. The animation is controlled by <tt>PadNavigator</tt>; this class is very simple by itself.</p>
<pre class="highlightedCode brush: cpp"> class SplashItem : public QGraphicsObject
 {
     Q_OBJECT
 public:
     explicit SplashItem(QGraphicsItem *parent = 0);

     QRectF boundingRect() const;
     void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = 0);

 private:
     QString text;
 };</pre>
<p>The class declaration shows that <tt>SplashItem</tt> inherits <a href="qgraphicsobject.html">QGraphicsObject</a> to allow it to be controlled by <a href="qpropertyanimation.html">QPropertyAnimation</a>. It reimplements the mandatory <a href="qgraphicsitem.html#paint">paint()</a> and <a href="qgraphicsitem.html#boundingRect">boundingRect()</a> pure virtual functions, and keeps a <tt>text</tt> member variable which will contain the information text displayed on this splash item.</p>
<p>Let's look at its implementation.</p>
<pre class="highlightedCode brush: cpp"> SplashItem::SplashItem(QGraphicsItem *parent)
     : QGraphicsObject(parent)
 {
     text = tr(&quot;Welcome to the Pad Navigator Example. You can use the&quot;
               &quot; keyboard arrows to navigate the icons, and press enter&quot;
               &quot; to activate an item. Press any key to begin.&quot;);
     setCacheMode(DeviceCoordinateCache);
 }</pre>
<p>The constructor forwards to <a href="qgraphicsobject.html">QGraphicsObject</a> as expected, assigns a text message to the <tt>text</tt> member variable, and enables <a href="qgraphicsitem.html#CacheMode-enum">DeviceCoordinateCache</a>. This cache mode is suitable because the splash item only moves and is never transformed, and because it contains text, it's important that it has a pixel perfect visual appearance (in constrast to <a href="qgraphicsitem.html#CacheMode-enum">ItemCoordinateCache</a>, where the visual appearance is not as good).</p>
<p>We use caching to avoid having to relayout and rerender the text for each frame. An alterative approach would be to use the new <a href="qstatictext.html">QStaticText</a> class.</p>
<pre class="highlightedCode brush: cpp"> QRectF SplashItem::boundingRect() const
 {
     return QRectF(0, 0, 400, 175);
 }</pre>
<p><tt>SplashItem</tt>'s bounding rectangle is fixed at (400x175).</p>
<pre class="highlightedCode brush: cpp"> void SplashItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
                        QWidget *widget)
 {
     Q_UNUSED(option);
     Q_UNUSED(widget);
     painter-&gt;setPen(QPen(Qt::black, 2));
     painter-&gt;setBrush(QColor(245, 245, 255, 220));
     painter-&gt;setClipRect(boundingRect());
     painter-&gt;drawRoundRect(3, -100 + 3, 400 - 6, 250 - 6);

     QRectF textRect = boundingRect().adjusted(10, 10, -10, -10);
     int flags = Qt::AlignTop | Qt::AlignLeft | Qt::TextWordWrap;

     QFont font;
     font.setPixelSize(18);
     painter-&gt;setPen(Qt::black);
     painter-&gt;setFont(font);
     painter-&gt;drawText(textRect, flags, text);
 }</pre>
<p>The <a href="qgraphicsitem.html#paint">paint()</a> implementation draws a clipped round rectangle with a thick 2-unit border and a semi-transparent white background. It proceeds to finding a suitable text area by adjusting the splash item's bounding rectangle with 10 units in each side. The text is rendered inside this rectangle, with top-left alignment, and with word wrapping enabled.</p>
<p>The main class now remains. We will proceed to reviewing <tt>PadNavigator</tt>.</p>
<a name="padnavigator-class-definition"></a>
<h2>PadNavigator Class Definition</h2>
<p><tt>PadNavigator</tt> represents the main window of our Pad Navigator Example application. It creates and controls a somewhat complex state machine, and several animations. Its class declaration is very simple:</p>
<pre class="highlightedCode brush: cpp"> class PadNavigator : public QGraphicsView
 {
     Q_OBJECT
 public:
     explicit PadNavigator(const QSize &amp;size, QWidget *parent = 0);

 protected:
     void resizeEvent(QResizeEvent *event);

 private:
     Ui_Form form;
 };</pre>
<p>It inherits <a href="qgraphicsview.html">QGraphicsView</a> and reimplements only one function: <a href="qgraphicsview.html#resizeEvent">resizeEvent()</a>, to ensure the scene is scaled to fit inside the view when resizing the main window.</p>
<p>The <tt>PadNavigator</tt> constructor takes a <a href="qsize.html">QSize</a> argument that determines the number or rows and columns in the grid.</p>
<p>It also keeps a private member instance, <tt>form</tt>, which is the generated code for the pad's back side item's <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a>-embedded form.</p>
<pre class="highlightedCode brush: cpp"> PadNavigator::PadNavigator(const QSize &amp;size, QWidget *parent)
     : QGraphicsView(parent)
 {</pre>
<p><tt>PadNavigator</tt>'s constructor is a bit long. In short, its job is to create all items, including the <tt>FlippablePad</tt>, the <tt>SplashItem</tt> and the <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a> <tt>backItem</tt>, and then to set up all animations, states and transitions that control the behavior of the application.</p>
<p>It starts out simple, by forwarding to <a href="qgraphicsview.html">QGraphicsView</a>'s constructor.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Splash item</span>
     SplashItem *splash = new SplashItem;
     splash-&gt;setZValue(1);</pre>
<p>The first item to be created is <tt>SplashItem</tt>. This is going to be a top-level item in the scene, next to <tt>FlippablePad</tt>, and stacked on top of it, so we assign it a <a href="qgraphicsitem.html#zValue">Z-value</a> of 1.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Pad item</span>
     FlippablePad *pad = new FlippablePad(size);
     QGraphicsRotation *flipRotation = new QGraphicsRotation(pad);
     QGraphicsRotation *xRotation = new QGraphicsRotation(pad);
     QGraphicsRotation *yRotation = new QGraphicsRotation(pad);
     flipRotation-&gt;setAxis(Qt::YAxis);
     xRotation-&gt;setAxis(Qt::YAxis);
     yRotation-&gt;setAxis(Qt::XAxis);
     pad-&gt;setTransformations(QList&lt;QGraphicsTransform *&gt;()
                             &lt;&lt; flipRotation
                             &lt;&lt; xRotation &lt;&lt; yRotation);</pre>
<p>Now we construct the <tt>FlippablePad</tt> item, passing its column-row count to its constructor.</p>
<p>The pad is constrolled by three transformations, and we create one <a href="qgraphicsrotation.html">QGraphicsRotation</a> object for each of these.</p>
<ul>
<li><tt>flipRotation</tt>: Rotates the grid around its <a href="qt.html#Axis-enum">Qt::YAxis</a>. This rotation is animated from 0 to 180, and eventually back, when enter is pressed on the keyboard, flipping the pad around.</li>
<li><tt>xRotation</tt>: Rotates the grid around its <a href="qt.html#Axis-enum">Qt::XAxis</a>. This is used to tilt the pad vertically corresponding to which item is currently selected. This way, the selected item is always kept in front.</li>
<li><tt>yRotation</tt>: Rotates the grid around its <a href="qt.html#Axis-enum">Qt::YAxis</a>. This is used to tilt the pad horizontally corresponding to which item is selected. This way, the selected item is always kept in front.</li>
</ul>
<p>The combination of all three rotations is assigned via <a href="qgraphicsitem.html#setTransformations">QGraphicsItem::setTransformations</a>().</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Back (proxy widget) item</span>
     QGraphicsProxyWidget *backItem = new QGraphicsProxyWidget(pad);
     QWidget *widget = new QWidget;
     form.setupUi(widget);
     form.hostName-&gt;setFocus();
     backItem-&gt;setWidget(widget);
     backItem-&gt;setVisible(false);
     backItem-&gt;setFocus();
     backItem-&gt;setCacheMode(QGraphicsItem::ItemCoordinateCache);
     const QRectF r = backItem-&gt;rect();
     backItem-&gt;setTransform(QTransform()
                            .rotate(180, Qt::YAxis)
                            .translate(-r.width()/2, -r.height()/2));</pre>
<p>Now we construct the <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a>-embedded <tt>backItem</tt>. The proxy widget is created as a child of the pad. We create a new <a href="qwidget.html">QWidget</a> and populate it with the <tt>form</tt> member. To ensure the <tt>hostName</tt> line edit is the first to receive input focus when this item is shown, we call <a href="qwidget.html#setFocus">setFocus()</a> immediately. This will not give the widget focus right away; it will only prepare the item to automatically receive focus once it is shown.</p>
<p>The <a href="qwidget.html">QWidget</a> based form is embedded into the proxy widget. The proxy is hidden initially; we only want to show it when the pad is rotated at least 90 degrees, and we also rotate the proxy itself by 180 degrees. This way we give the impression that the proxy widget is &quot;behind&quot; the flipped pad, when in fact, it's actually <i>on top of it</i>.</p>
<p>We enable <a href="qgraphicsitem.html#CacheMode-enum">ItemCoordinateCache</a> to ensure the flip animation can run smoothly.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Selection item</span>
     RoundRectItem *selectionItem = new RoundRectItem(QRectF(-60, -60, 120, 120),
                                                      Qt::gray, pad);
     selectionItem-&gt;setZValue(0.5);</pre>
<p>We now create the selection item. This is simply another instance of <tt>RoundRectItem</tt> that is slightly larger than the icons on the pad. We create it as an immediate child of the <tt>FlippablePad</tt>, so the selection item is a sibling to all the icons. By giving it a <a href="qgraphicsitem.html#zValue">Z-value</a> of 0.5 we ensure it will slide beteen the pad and its icons.</p>
<p>What follows now is a series of animation initializations.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Splash animations</span>
     QPropertyAnimation *smoothSplashMove = new QPropertyAnimation(splash, &quot;y&quot;);
     QPropertyAnimation *smoothSplashOpacity = new QPropertyAnimation(splash, &quot;opacity&quot;);
     smoothSplashMove-&gt;setEasingCurve(QEasingCurve::InQuad);
     smoothSplashMove-&gt;setDuration(250);
     smoothSplashOpacity-&gt;setDuration(250);</pre>
<p>We begin with the animations that apply to the splash item. The first animation, <tt>smoothSplashMove</tt>, ensures that the &quot;y&quot; property of <tt>splash</tt> will be animated with a 250-millisecond duration <a href="qeasingcurve.html#Type-enum">InQuad</a> easing function. <tt>smoothSplashOpacity</tt> ensures the opacity of <tt>splash</tt> eases in and out in 250 milliseconds.</p>
<p>The values are assigned by <tt>PadNavigator</tt>'s state machine, which is created later.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Selection animation</span>
     QPropertyAnimation *smoothXSelection = new QPropertyAnimation(selectionItem, &quot;x&quot;);
     QPropertyAnimation *smoothYSelection = new QPropertyAnimation(selectionItem, &quot;y&quot;);
     QPropertyAnimation *smoothXRotation = new QPropertyAnimation(xRotation, &quot;angle&quot;);
     QPropertyAnimation *smoothYRotation = new QPropertyAnimation(yRotation, &quot;angle&quot;);
     smoothXSelection-&gt;setDuration(125);
     smoothYSelection-&gt;setDuration(125);
     smoothXRotation-&gt;setDuration(125);
     smoothYRotation-&gt;setDuration(125);
     smoothXSelection-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothYSelection-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothXRotation-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothYRotation-&gt;setEasingCurve(QEasingCurve::InOutQuad);</pre>
<p>These are the animations that control the selection item's movement and the <tt>xRotation</tt> and <tt>yRotation</tt> <a href="qgraphicsrotation.html">QGraphicsRotation</a> objects that tilt the pad. All animations have a duration of 125 milliseconds, and they all use the <a href="qeasingcurve.html#Type-enum">InOutQuad</a> easing function.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Flip animation setup</span>
     QPropertyAnimation *smoothFlipRotation = new QPropertyAnimation(flipRotation, &quot;angle&quot;);
     QPropertyAnimation *smoothFlipScale = new QPropertyAnimation(pad, &quot;scale&quot;);
     QPropertyAnimation *smoothFlipXRotation = new QPropertyAnimation(xRotation, &quot;angle&quot;);
     QPropertyAnimation *smoothFlipYRotation = new QPropertyAnimation(yRotation, &quot;angle&quot;);
     QParallelAnimationGroup *flipAnimation = new QParallelAnimationGroup(this);
     smoothFlipScale-&gt;setDuration(500);
     smoothFlipRotation-&gt;setDuration(500);
     smoothFlipXRotation-&gt;setDuration(500);
     smoothFlipYRotation-&gt;setDuration(500);
     smoothFlipScale-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothFlipRotation-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothFlipXRotation-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothFlipYRotation-&gt;setEasingCurve(QEasingCurve::InOutQuad);
     smoothFlipScale-&gt;setKeyValueAt(0, qVariantValue&lt;qreal&gt;(1.0));
     smoothFlipScale-&gt;setKeyValueAt(0.5, qVariantValue&lt;qreal&gt;(0.7));
     smoothFlipScale-&gt;setKeyValueAt(1, qVariantValue&lt;qreal&gt;(1.0));
     flipAnimation-&gt;addAnimation(smoothFlipRotation);
     flipAnimation-&gt;addAnimation(smoothFlipScale);
     flipAnimation-&gt;addAnimation(smoothFlipXRotation);
     flipAnimation-&gt;addAnimation(smoothFlipYRotation);</pre>
<p>We now create the animations that control the flip-effect when you press the enter key. The main goal is to rotate the pad by 180 degrees or back, but we also need to make sure the selection item's tilt rotations are reset back to 0 when the pad is flipped, and restored back to their original values when flipped back:</p>
<ul>
<li><tt>smoothFlipRotation</tt>: Animates the main 180 degree rotation of the pad.</li>
<li><tt>smoothFlipScale</tt>: Scales the pad out and then in again while the pad is rotating.</li>
<li><tt>smoothFlipXRotation</tt>: Animates the selection item's X-tilt to 0 and back.</li>
<li><tt>smoothFlipYRotation</tt>: Animates the selection item's Y-tilt to 0 and back.</li>
<li><tt>flipAnimation</tt>: A parallel animation group that ensures all the above animations are run in parallel.</li>
</ul>
<p>All animations are given a 500 millisecond duration and an <a href="qeasingcurve.html#Type-enum">InOutQuad</a> easing function.</p>
<p>It's worth taking a close look at <tt>smoothFlipScale</tt>. This animation's start and end values are both 1.0, but at animation step 0.5 the animation's value is 0.7&#x2e; This means that after 50% of the animation's duration, or 250 milliseconds, the pad will be scaled down to 0.7x of its original size, which gives a great visual effect while flipping.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Flip animation delayed property assignment</span>
     QSequentialAnimationGroup *setVariablesSequence = new QSequentialAnimationGroup;
     QPropertyAnimation *setFillAnimation = new QPropertyAnimation(pad, &quot;fill&quot;);
     QPropertyAnimation *setBackItemVisibleAnimation = new QPropertyAnimation(backItem, &quot;visible&quot;);
     QPropertyAnimation *setSelectionItemVisibleAnimation = new QPropertyAnimation(selectionItem, &quot;visible&quot;);
     setFillAnimation-&gt;setDuration(0);
     setBackItemVisibleAnimation-&gt;setDuration(0);
     setSelectionItemVisibleAnimation-&gt;setDuration(0);
     setVariablesSequence-&gt;addPause(250);
     setVariablesSequence-&gt;addAnimation(setBackItemVisibleAnimation);
     setVariablesSequence-&gt;addAnimation(setSelectionItemVisibleAnimation);
     setVariablesSequence-&gt;addAnimation(setFillAnimation);
     flipAnimation-&gt;addAnimation(setVariablesSequence);</pre>
<p>This section uses a trick to ensure that certain properties are assigned precisely when the flip animation passes 50%, or 90 degrees, rotation. In short, the pad's icons and selection item are all hidden, the pad's <tt>fill</tt> property is enabled, and <tt>backItem</tt> is shown when flipping over. When flipping back, the reverse properties are applied.</p>
<p>The way this is achieved is by running a sequential animation in parallel to the other animations. This sequence, dubbed <tt>setVariablesSequence</tt>, starts with a 250 millisecond pause, and then executes several animations with a duration of 0. Each animation will ensure that properties are set immediate at this point.</p>
<p>This approach can also be used to call functions or set any other properties at a specific time while an animation is running.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Build the state machine</span>
     QStateMachine *stateMachine = new QStateMachine(this);
     QState *splashState = new QState(stateMachine);
     QState *frontState = new QState(stateMachine);
     QHistoryState *historyState = new QHistoryState(frontState);
     QState *backState = new QState(stateMachine);</pre>
<p>We will now create the state machine. The whole <tt>PadNavigator</tt> state machinery is controlled by one single state machine that has a straight-forward state structure. The state engine itself is created as a child of the <tt>PadNavigator</tt> itself. We then create three top level states:</p>
<ul>
<li><tt>splashState</tt>: The initial state where the splash item is visible.</li>
<li><tt>frontState</tt>: The base state where the splash is gone and we can see the front side of the pad, and navigate the selection item.</li>
<li><tt>backState</tt>: The flipped state where the <tt>backItem</tt> is visible, and we can interact with the <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a>-embedded form.</li>
</ul>
<pre class="highlightedCode brush: cpp">     frontState-&gt;assignProperty(pad, &quot;fill&quot;, false);
     frontState-&gt;assignProperty(splash, &quot;opacity&quot;, 0.0);
     frontState-&gt;assignProperty(backItem, &quot;visible&quot;, false);
     frontState-&gt;assignProperty(flipRotation, &quot;angle&quot;, qVariantValue&lt;qreal&gt;(0.0));
     frontState-&gt;assignProperty(selectionItem, &quot;visible&quot;, true);
     backState-&gt;assignProperty(pad, &quot;fill&quot;, true);
     backState-&gt;assignProperty(backItem, &quot;visible&quot;, true);
     backState-&gt;assignProperty(xRotation, &quot;angle&quot;, qVariantValue&lt;qreal&gt;(0.0));
     backState-&gt;assignProperty(yRotation, &quot;angle&quot;, qVariantValue&lt;qreal&gt;(0.0));
     backState-&gt;assignProperty(flipRotation, &quot;angle&quot;, qVariantValue&lt;qreal&gt;(180.0));
     backState-&gt;assignProperty(selectionItem, &quot;visible&quot;, false);
     stateMachine-&gt;addDefaultAnimation(smoothXRotation);
     stateMachine-&gt;addDefaultAnimation(smoothYRotation);
     stateMachine-&gt;addDefaultAnimation(smoothXSelection);
     stateMachine-&gt;addDefaultAnimation(smoothYSelection);
     stateMachine-&gt;setInitialState(splashState);</pre>
<p>Each state assigns specific properties to objects on entry. Most interesting perhaps is the assignment of the value 0.0 to the pad's <tt>flipRotation</tt> angle property when in <tt>frontState</tt>, and 180.0 when in <tt>backState</tt>. At the end of this section we register default animations with the state engine; these animations will apply to their respective objects and properties for any state transition. Otherwise it's common to assign animations to specific transitions.</p>
<p>The <tt>splashState</tt> state is set as the initial state. This is required before we start the state engine. We proceed with creating some transitions.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Transitions</span>
     QEventTransition *anyKeyTransition = new QEventTransition(this, QEvent::KeyPress, splashState);
     anyKeyTransition-&gt;setTargetState(frontState);
     anyKeyTransition-&gt;addAnimation(smoothSplashMove);
     anyKeyTransition-&gt;addAnimation(smoothSplashOpacity);</pre>
<p><a href="qeventtransition.html">QEventTransition</a> defines a very flexible transition type. You can use this class to trigger a transition based on an object receiving an event of a specific type. In this case, we would like to transition from <tt>splashState</tt> into <tt>frontState</tt> if <tt>PadNavigator</tt> receives any key press event (<a href="qevent.html#Type-enum">QEvent::KeyPress</a>).</p>
<p>We register the <tt>splashItem</tt>'s animations to this transition to ensure they are used to animate the item's movement and opacity.</p>
<pre class="highlightedCode brush: cpp">     QKeyEventTransition *enterTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                    Qt::Key_Enter, backState);
     QKeyEventTransition *returnTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                     Qt::Key_Return, backState);
     QKeyEventTransition *backEnterTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                        Qt::Key_Enter, frontState);
     QKeyEventTransition *backReturnTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                         Qt::Key_Return, frontState);
     enterTransition-&gt;setTargetState(historyState);
     returnTransition-&gt;setTargetState(historyState);
     backEnterTransition-&gt;setTargetState(backState);
     backReturnTransition-&gt;setTargetState(backState);
     enterTransition-&gt;addAnimation(flipAnimation);
     returnTransition-&gt;addAnimation(flipAnimation);
     backEnterTransition-&gt;addAnimation(flipAnimation);
     backReturnTransition-&gt;addAnimation(flipAnimation);</pre>
<p>We use <a href="qkeyeventtransition.html">QKeyEventTransition</a> to capture specific key events. In this case, we detect that the user presses <a href="qt.html#Key-enum">Qt::Key_Return</a> or <a href="qt.html#Key-enum">Qt::Key_Enter</a>, and use this to trigger transitions between <tt>frontState</tt> and backState. We register <tt>flipAnimation</tt>, our complex parallel animation group, with these transitions.</p>
<p>We continue by defining the states for each of the icons in the grid.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Create substates for each icon; store in temporary grid.</span>
     int columns = size.width();
     int rows = size.height();
     QVector&lt; QVector&lt; QState * &gt; &gt; stateGrid;
     stateGrid.resize(rows);
     for (int y = 0; y &lt; rows; ++y) {
         stateGrid[y].resize(columns);
         for (int x = 0; x &lt; columns; ++x)
             stateGrid[y][x] = new QState(frontState);
     }
     frontState-&gt;setInitialState(stateGrid[0][0]);
     selectionItem-&gt;setPos(pad-&gt;iconAt(0, 0)-&gt;pos());</pre>
<p>We will use state groups to control transitions between icons. Each icon represents a <i>substate</i> of <tt>frontState</tt>. We will then define transitions between the states by detecting key presses, using <a href="qkeyeventtransition.html">QKeyEventTransition</a>.</p>
<p>We start by creating all the substates, and at the same time we create a temporary grid structure for the states to make it easier to find which states represents icons that are up, down, left and to the right each other.</p>
<p>Once the first substate is known, we set this up as the initial substate of <tt>frontState</tt>. We will use the (0, 0), or top-left, icon for the initial substate. We initialze the selection item's position to be exactly where the top-left icon is.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Enable key navigation using state transitions</span>
     for (int y = 0; y &lt; rows; ++y) {
         for (int x = 0; x &lt; columns; ++x) {
             QState *state = stateGrid[y][x];
             QKeyEventTransition *rightTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                            Qt::Key_Right, state);
             QKeyEventTransition *leftTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                           Qt::Key_Left, state);
             QKeyEventTransition *downTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                           Qt::Key_Down, state);
             QKeyEventTransition *upTransition = new QKeyEventTransition(this, QEvent::KeyPress,
                                                                         Qt::Key_Up, state);
             rightTransition-&gt;setTargetState(stateGrid[y][(x + 1) % columns]);
             leftTransition-&gt;setTargetState(stateGrid[y][((x - 1) + columns) % columns]);
             downTransition-&gt;setTargetState(stateGrid[(y + 1) % rows][x]);
             upTransition-&gt;setTargetState(stateGrid[((y - 1) + rows) % rows][x]);</pre>
<p>We can now create four transitions for each icon. Each transition ensures that we move to the state corresponding to which arrow key has been pressed. It's clear from this techinique that we could design any other specific transitions to and from each of the sub states depending on these and other keys.</p>
<pre class="highlightedCode brush: cpp">             RoundRectItem *icon = pad-&gt;iconAt(x, y);
             state-&gt;assignProperty(xRotation, &quot;angle&quot;, -icon-&gt;x() / 6.0);
             state-&gt;assignProperty(yRotation, &quot;angle&quot;, icon-&gt;y() / 6.0);
             state-&gt;assignProperty(selectionItem, &quot;x&quot;, icon-&gt;x());
             state-&gt;assignProperty(selectionItem, &quot;y&quot;, icon-&gt;y());
             frontState-&gt;assignProperty(icon, &quot;visible&quot;, true);
             backState-&gt;assignProperty(icon, &quot;visible&quot;, false);

             QPropertyAnimation *setIconVisibleAnimation = new QPropertyAnimation(icon, &quot;visible&quot;);
             setIconVisibleAnimation-&gt;setDuration(0);
             setVariablesSequence-&gt;addAnimation(setIconVisibleAnimation);
         }
     }</pre>
<p>Also, for each of the icons, we assign suitable values to the <tt>xRotation</tt> and <tt>yRotation</tt> objects' &quot;angle&quot;-properties. If you recall, these properties &quot;tilt&quot; the pad corresponding to which item is currently selected. We ensure each icon is invisible when the pad is flipped, and visible when the pad is not flipped. To ensure the visible property is assigned at the right time, we add property-controlling animations to the <tt>setVariableSequence</tt> animation defined earlier.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Scene</span>
     QGraphicsScene *scene = new QGraphicsScene(this);
     scene-&gt;setBackgroundBrush(QPixmap(&quot;:/images/blue_angle_swirl.jpg&quot;));
     scene-&gt;setItemIndexMethod(QGraphicsScene::NoIndex);
     scene-&gt;addItem(pad);
     scene-&gt;setSceneRect(scene-&gt;itemsBoundingRect());
     setScene(scene);</pre>
<p>We are now finished with all states, transitions, and animations. We now create the scene that will contain all our items. The scene gets a defined background pixmap, and we disable item indexing (as most items in this scene are animated). We add our <tt>pad</tt> item to the scene, and use its bounding rectangle to fixate the scene rectangle. This rectangle is used by the view to find a suitable size for the application window.</p>
<p>Then the scene is assigned to the view, or in our case, <tt>PadNavigator</tt> itself.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// Adjust splash item to scene contents</span>
     const QRectF sbr = splash-&gt;boundingRect();
     splash-&gt;setPos(-sbr.width() / 2, scene-&gt;sceneRect().top() - 2);
     frontState-&gt;assignProperty(splash, &quot;y&quot;, splash-&gt;y() - 100.0);
     scene-&gt;addItem(splash);</pre>
<p>Now that the scene has received its final size, we can position the splash item at the very top, find its fade-out position, and add it to the scene.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">// View</span>
     setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
     setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
     setMinimumSize(50, 50);
     setViewportUpdateMode(FullViewportUpdate);
     setCacheMode(CacheBackground);
     setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform | QPainter::TextAntialiasing);
 #ifndef QT_NO_OPENGL
     setViewport(new QGLWidget(QGLFormat(QGL::SampleBuffers)));
 #endif

     stateMachine-&gt;start();</pre>
<p>The view toggles a few necessary properties:</p>
<ul>
<li>It disables its scroll bars - this application has no use for scroll bars.</li>
<li>It assigns a minimum size. This is necessary to avoid numerical errors in our fit-in-view <tt>resizeEvent()</tt> implementation.</li>
<li>It sets <a href="qgraphicsview.html#ViewportUpdateMode-enum">FullViewportUpdate</a>, to ensure <a href="qgraphicsview.html">QGraphicsView</a> doesn't spend time figuring out precisely what needs to be redrawn. This application is very simple - if anything changes, everything is updated.</li>
<li>It enables background caching - this makes no performance difference with OpenGL, but without OpenGL it avoids unnecessary re-scaling of the background pixmap.</li>
<li>It sets render hints that increase rendering quality.</li>
<li>If OpenGL is supported, a <a href="qglwidget.html">QGLWidget</a> viewport is assigned to the view.</li>
</ul>
<p>Finally, we start the state engine.</p>
<pre class="highlightedCode brush: cpp"> void PadNavigator::resizeEvent(QResizeEvent *event)
 {
     QGraphicsView::resizeEvent(event);
     fitInView(scene()-&gt;sceneRect(), Qt::KeepAspectRatio);
 }</pre>
<p>The <a href="qgraphicsview.html#resizeEvent">resizeEvent()</a> implementation calls the base implementation, and then calls <a href="qgraphicsview.html#fitInView">QGraphicsView::fitInView</a>() to scale the scene so that it fits perfectly inside the view.</p>
<p>By resizing the main application window, you can see this effect yourself. The scene contents grow when you make the window larger, and shrink when you make it smaller, while keeping the aspect ratio intact.</p>
<a name="the-main-function"></a>
<h2>The main() Function</h2>
<pre class="highlightedCode brush: cpp"> int main(int argc, char *argv[])
 {
     QApplication app(argc, argv);
     Q_INIT_RESOURCE(padnavigator);

     PadNavigator navigator(QSize(3, 3));
     navigator.show();

     return app.exec();
 }</pre>
<p>The <tt>main</tt> function creates the <a href="qapplication.html">QApplication</a> instance, uses Q_INIT_RESOURCE to ensure our compiled-in resources aren't removed by the linker, and then creates a 3x3 <tt>PadNavigator</tt> instance and shows it.</p>
<p>Our flippable pad shows up with a suitable splash item once control returns to the event loop.</p>
<a name="performance-notes"></a>
<h2>Performance Notes</h2>
<p>The example uses OpenGL if this is available, to achieve optimal performance; otherwise perspective tranformations can be quite costly.</p>
<p>Although this example does use <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a> to demonstrate integration of Qt widget components integrated into Graphics View, using <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a> comes with a performance penalty, and is therefore not recommended for embedded development.</p>
<p>This example uses extensive item caching to avoid rerendering of static elements, at the expense of graphics memory.</p>
</div>
<!-- @@@graphicsview/padnavigator -->
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
