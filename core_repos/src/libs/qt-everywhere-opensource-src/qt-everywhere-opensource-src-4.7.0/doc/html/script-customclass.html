<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qtscriptcustomclass.qdoc -->
  <title>Qt 4.7: Custom Script Class Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="all-examples.html">Examples</a></li>              <li><a href="examples-script.html">Qt Script Examples</a></li>              <li>Custom Script Class Example</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#bytearray-class-in-use">ByteArray Class In Use</a></li>
<li class="level1"><a href="#bytearray-class-implementation">ByteArray Class Implementation</a></li>
<li class="level1"><a href="#bytearray-iterator-implementation">ByteArray Iterator Implementation</a></li>
<li class="level1"><a href="#bytearray-prototype-implementation">ByteArray Prototype Implementation</a></li>
</ul>
</div>
<h1 class="title">Custom Script Class Example</h1>
<span class="subtitle"></span>
<!-- $$$script/customclass-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="script-customclass-bytearrayclass-cpp.html">script/customclass/bytearrayclass.cpp</a></li>
<li><a href="script-customclass-bytearrayclass-h.html">script/customclass/bytearrayclass.h</a></li>
<li><a href="script-customclass-bytearrayprototype-cpp.html">script/customclass/bytearrayprototype.cpp</a></li>
<li><a href="script-customclass-bytearrayprototype-h.html">script/customclass/bytearrayprototype.h</a></li>
<li><a href="script-customclass-main-cpp.html">script/customclass/main.cpp</a></li>
<li><a href="script-customclass-customclass-pro.html">script/customclass/customclass.pro</a></li>
</ul>
<p>The Custom Script Class example shows how to use <a href="qscriptclass.html">QScriptClass</a> and <a href="qscriptclasspropertyiterator.html">QScriptClassPropertyIterator</a> to implement a custom script class.</p>
<p>The script class we are going to implement is called <tt>ByteArray</tt>. It provides a wrapper around the <a href="qbytearray.html">QByteArray</a> class in Qt, with a simplified API. Why do we need such a class? Well, neither the ECMAScript <tt>Array</tt> class or <tt>String</tt> class is appropriate to use when working with arrays of bytes. Our <tt>ByteArray</tt> class will have the right semantics; objects will use only the amount of memory that is really needed (a byte is stored as a byte, not as a floating-point number or a Unicode character) and can be passed directly to C++ slots taking <a href="qbytearray.html">QByteArray</a> arguments (no costly conversion necessary).</p>
<a name="bytearray-class-in-use"></a>
<h2>ByteArray Class In Use</h2>
<p>When the <tt>ByteArray</tt> class has been made available to the scripting environment, <tt>ByteArray</tt> objects can be constructed like so:</p>
<pre class="highlightedCode brush: cpp"> var ba = new ByteArray();    // constructs an empty ByteArray
 var ba2 = new ByteArray(10); // constructs a ByteArray of length 10 (all bytes initialized to 0)</pre>
<p><tt>ByteArray</tt> objects behave similar to normal <tt>Array</tt> objects. Every <tt>ByteArray</tt> object has a <tt>length</tt> property, that holds the length of the array. If a new value is assigned to the <tt>length</tt> property, the array is resized. If the array is enlarged, the new bytes are initialized to 0. (This is a difference from normal <tt>Array</tt> objects; <tt>ByteArray</tt> objects are always dense arrays.) Use normal array operations to read or write bytes in the array. The following code sets all the bytes of an array to a certain value:</p>
<pre class="highlightedCode brush: cpp"> for (var i = 0; i &lt; ba.length; ++i)
     ba[i] = 123;</pre>
<p>When assigning a value to an array element, the value is truncated to eight bits:</p>
<pre class="highlightedCode brush: cpp"> ba[0] = 257;
 print(ba[0]);  // 1</pre>
<p>Like normal <tt>Array</tt> objects, if the array index is greater than the current length of the array, the array is resized accordingly:</p>
<pre class="highlightedCode brush: cpp"> var ba3 = new ByteArray();
 print(ba3.length); // 0
 ba[0] = 64;
 print(ba3.length); // 1</pre>
<p>Property names that aren't valid array indexes are treated like normal object properties (again, the same is the case for normal <tt>Array</tt> objects); in other words, it's perfectly fine to do something like this:</p>
<pre class="highlightedCode brush: cpp"> ba[&quot;foo&quot;] = &quot;Hello&quot;;</pre>
<p>The above assignment won't affect the contents of the array, but will rather assign a value to the object property named &quot;foo&quot;.</p>
<p><tt>ByteArray</tt> objects have a set of methods: chop(), equals(), <a href="qtextstream.html#left">left</a>(), mid(), toBase64() and so on. These map directly onto the corresponding methods in <a href="qbytearray.html">QByteArray</a>.</p>
<pre class="highlightedCode brush: cpp"> var ba64 = ba.toBase64();
 print(ba64.toLatin1String());</pre>
<a name="bytearray-class-implementation"></a>
<h2>ByteArray Class Implementation</h2>
<p>To implement the <tt>ByteArray</tt> script class in C++, we create a subclass of <a href="qscriptclass.html">QScriptClass</a>, called ByteArrayClass, and reimplement the virtual functions from <a href="qscriptclass.html">QScriptClass</a>. We also provide a Qt Script constructor function suitable for being added to a <a href="qscriptengine.html">QScriptEngine</a>'s environment.</p>
<p>The ByteArrayClass constructor prepares the script class:</p>
<pre class="highlightedCode brush: cpp"> ByteArrayClass::ByteArrayClass(QScriptEngine *engine)
     : QObject(engine), QScriptClass(engine)
 {
     qScriptRegisterMetaType&lt;QByteArray&gt;(engine, toScriptValue, fromScriptValue);

     length = engine-&gt;toStringHandle(QLatin1String(&quot;length&quot;));

     proto = engine-&gt;newQObject(new ByteArrayPrototype(this),
                                QScriptEngine::QtOwnership,
                                QScriptEngine::SkipMethodsInEnumeration
                                | QScriptEngine::ExcludeSuperClassMethods
                                | QScriptEngine::ExcludeSuperClassProperties);
     QScriptValue global = engine-&gt;globalObject();
     proto.setPrototype(global.property(&quot;Object&quot;).property(&quot;prototype&quot;));

     ctor = engine-&gt;newFunction(construct, proto);
     ctor.setData(qScriptValueFromValue(engine, this));
 }</pre>
<p>First, the constructor registers a pair of conversion functions, so that C++ <a href="qbytearray.html">QByteArray</a> objects and Qt Script <tt>ByteArray</tt> objects can move seamlessly between the C++ side and the script side. For example, if a <tt>ByteArray</tt> object is passed to a C++ slot that takes a <a href="qbytearray.html">QByteArray</a> argument, the actual <a href="qbytearray.html">QByteArray</a> that the <tt>ByteArray</tt> object wraps will be passed correctly.</p>
<p>Second, we store a handle to the string &quot;length&quot;, so that we can quickly compare a given property name to &quot;length&quot; later on.</p>
<p>Third, we initialize the standard <tt>ByteArray</tt> prototype, to be returned by our prototype() reimplementation later on. (The implementation of the prototype is discussed later.)</p>
<p>Fourth, we initialize a constructor function for <tt>ByteArray</tt>, to be returned by the constructor() function. We set the internal data of the constructor to be a pointer to this ByteArrayClass object, so that the constructor, when it is invoked, can extract the pointer and use it to create a new <tt>ByteArray</tt> object.</p>
<pre class="highlightedCode brush: cpp"> QScriptValue ByteArrayClass::newInstance(int size)
 {
     engine()-&gt;reportAdditionalMemoryCost(size);
     return newInstance(QByteArray(size, <span class="comment">/*ch=*/</span>0));
 }
 QScriptValue ByteArrayClass::newInstance(const QByteArray &amp;ba)
 {
     QScriptValue data = engine()-&gt;newVariant(qVariantFromValue(ba));
     return engine()-&gt;newObject(this, data);
 }</pre>
<p>The newInstance() function isn't part of the <a href="qscriptclass.html">QScriptClass</a> API; its purpose is to offer a convenient way to construct a <tt>ByteArray</tt> object from an existing <a href="qbytearray.html">QByteArray</a>. We store the <a href="qbytearray.html">QByteArray</a> as the internal data of the new object, and return the new object. <a href="qscriptengine.html#newObject">QScriptEngine::newObject</a>() will call the prototype() function of our class, ensuring that the prototype of the new object will be the standard <tt>ByteArray</tt> prototype.</p>
<p><a href="qscriptengine.html#reportAdditionalMemoryCost">QScriptEngine::reportAdditionalMemoryCost</a>() is called to inform the script engine of the memory occupied by the <a href="qbytearray.html">QByteArray</a>. This gives the garbage collector a hint that it should perhaps trigger more frequently, possibly freeing up memory associated with large ByteArray objects that are no longer in use.</p>
<pre class="highlightedCode brush: cpp"> QScriptValue ByteArrayClass::construct(QScriptContext *ctx, QScriptEngine *)
 {
     ByteArrayClass *cls = qscriptvalue_cast&lt;ByteArrayClass*&gt;(ctx-&gt;callee().data());
     if (!cls)
         return QScriptValue();
     QScriptValue arg = ctx-&gt;argument(0);
     if (arg.instanceOf(ctx-&gt;callee()))
         return cls-&gt;newInstance(qscriptvalue_cast&lt;QByteArray&gt;(arg));
     int size = arg.toInt32();
     return cls-&gt;newInstance(size);
 }</pre>
<p>construct() is the native function that will act as a constructor for <tt>ByteArray</tt> in scripts. We extract the pointer to the class, then call a newInstance() overload that takes an initial size as argument, and return the new script object.</p>
<pre class="highlightedCode brush: cpp"> QScriptClass::QueryFlags ByteArrayClass::queryProperty(const QScriptValue &amp;object,
                                                        const QScriptString &amp;name,
                                                        QueryFlags flags, uint *id)
 {
     QByteArray *ba = qscriptvalue_cast&lt;QByteArray*&gt;(object.data());
     if (!ba)
         return 0;
     if (name == length) {
         return flags;
     } else {
         bool isArrayIndex;
         qint32 pos = name.toArrayIndex(&amp;isArrayIndex);
         if (!isArrayIndex)
             return 0;
         *id = pos;
         if ((flags &amp; HandlesReadAccess) &amp;&amp; (pos &gt;= ba-&gt;size()))
             flags &amp;= ~HandlesReadAccess;
         return flags;
     }
 }</pre>
<p>queryProperty() is the function that Qt Script will call whenever someone tries to access a property of a <tt>ByteArray</tt> object. We first get a pointer to the underlying <a href="qbytearray.html">QByteArray</a>. We check if the property being accessed is the special <tt>length</tt> property; if so, we return, indicating that we will handle every kind of access to this property (e.g&#x2e; both read and write). Otherwise, we attempt to convert the property name to an array index. If this fails, we return, indicating that we don't want to handle this property. Otherwise, we have a valid array index, and store it in the <tt>id</tt> argument, so that we don't have to recompute it in e.g&#x2e; property() or setProperty(). If the index is greater than or equal to the <a href="qbytearray.html">QByteArray</a>'s size, we indicate that we don't want to handle read access (but we still want to handle writes, if requested).</p>
<pre class="highlightedCode brush: cpp"> QScriptValue ByteArrayClass::property(const QScriptValue &amp;object,
                                       const QScriptString &amp;name, uint id)
 {
     QByteArray *ba = qscriptvalue_cast&lt;QByteArray*&gt;(object.data());
     if (!ba)
         return QScriptValue();
     if (name == length) {
         return ba-&gt;length();
     } else {
         qint32 pos = id;
         if ((pos &lt; 0) || (pos &gt;= ba-&gt;size()))
             return QScriptValue();
         return uint(ba-&gt;at(pos)) &amp; 255;
     }
     return QScriptValue();
 }</pre>
<p>In the property() reimplementation, we do similar checks as in queryProperty() to find out which property is being requested, and then return the value of that property.</p>
<pre class="highlightedCode brush: cpp"> void ByteArrayClass::setProperty(QScriptValue &amp;object,
                                  const QScriptString &amp;name,
                                  uint id, const QScriptValue &amp;value)
 {
     QByteArray *ba = qscriptvalue_cast&lt;QByteArray*&gt;(object.data());
     if (!ba)
         return;
     if (name == length) {
         resize(*ba, value.toInt32());
     } else {
         qint32 pos = id;
         if (pos &lt; 0)
             return;
         if (ba-&gt;size() &lt;= pos)
             resize(*ba, pos + 1);
         (*ba)[pos] = char(value.toInt32());
     }
 }</pre>
<p>The setProperty() reimplementation has a structure that is similar to property(). If the <tt>length</tt> property is being set, we resize the underlying <a href="qbytearray.html">QByteArray</a> to the given length. Otherwise, we grab the array index that was calculated in the queryProperty() function, enlarge the array if necessary, and write the given value to the array.</p>
<pre class="highlightedCode brush: cpp"> void ByteArrayClass::resize(QByteArray &amp;ba, int newSize)
 {
     int oldSize = ba.size();
     ba.resize(newSize);
     if (newSize &gt; oldSize)
         engine()-&gt;reportAdditionalMemoryCost(newSize - oldSize);
 }</pre>
<p>The resize() function is a helper function that resizes the <a href="qbytearray.html">QByteArray</a> to a new size, and, if the new size is greater than the old, reports the additional memory cost to the script engine.</p>
<pre class="highlightedCode brush: cpp"> QScriptValue::PropertyFlags ByteArrayClass::propertyFlags(
     const QScriptValue &amp;<span class="comment">/*object*/</span>, const QScriptString &amp;name, uint <span class="comment">/*id*/</span>)
 {
     if (name == length) {
         return QScriptValue::Undeletable
             | QScriptValue::SkipInEnumeration;
     }
     return QScriptValue::Undeletable;
 }</pre>
<p>The propertyFlags() reimplementation specifies that the <tt>length</tt> property can't be deleted, and that it is not enumerable. Array elements can't be deleted.</p>
<pre class="highlightedCode brush: cpp"> QScriptClassPropertyIterator *ByteArrayClass::newIterator(const QScriptValue &amp;object)
 {
     return new ByteArrayClassPropertyIterator(object);
 }</pre>
<p>We want the array elements to show up when a <tt>ByteArray</tt> object is used in for-in statements and together with <a href="qscriptvalueiterator.html">QScriptValueIterator</a>. Therefore, we reimplement the newIterator() function and have it return a new iterator for a given <tt>ByteArray</tt>.</p>
<a name="bytearray-iterator-implementation"></a>
<h2>ByteArray Iterator Implementation</h2>
<pre class="highlightedCode brush: cpp"> bool ByteArrayClassPropertyIterator::hasNext() const
 {
     QByteArray *ba = qscriptvalue_cast&lt;QByteArray*&gt;(object().data());
     return m_index &lt; ba-&gt;size();
 }

 void ByteArrayClassPropertyIterator::next()
 {
     m_last = m_index;
     ++m_index;
 }

 bool ByteArrayClassPropertyIterator::hasPrevious() const
 {
     return (m_index &gt; 0);
 }

 void ByteArrayClassPropertyIterator::previous()
 {
     --m_index;
     m_last = m_index;
 }

 void ByteArrayClassPropertyIterator::toFront()
 {
     m_index = 0;
     m_last = -1;
 }

 void ByteArrayClassPropertyIterator::toBack()
 {
     QByteArray *ba = qscriptvalue_cast&lt;QByteArray*&gt;(object().data());
     m_index = ba-&gt;size();
     m_last = -1;
 }

 QScriptString ByteArrayClassPropertyIterator::name() const
 {
     return object().engine()-&gt;toStringHandle(QString::number(m_last));
 }

 uint ByteArrayClassPropertyIterator::id() const
 {
     return m_last;
 }</pre>
<p>The <tt>ByteArrayClassPropertyIterator</tt> class is simple. It maintains an index into the underlying <a href="qbytearray.html">QByteArray</a>, and checks and updates the index in hasNext(), next() and so on.</p>
<a name="bytearray-prototype-implementation"></a>
<h2>ByteArray Prototype Implementation</h2>
<p>The prototype class, ByteArrayPrototype, implements the <tt>ByteArray</tt> functions as slots.</p>
<pre class="highlightedCode brush: cpp"> class ByteArrayPrototype : public QObject, public QScriptable
 {
 Q_OBJECT
 public:
     ByteArrayPrototype(QObject *parent = 0);
     ~ByteArrayPrototype();

 public slots:
     void chop(int n);
     bool equals(const QByteArray &amp;other);
     QByteArray left(int len) const;
     QByteArray mid(int pos, int len = -1) const;
     QScriptValue remove(int pos, int len);
     QByteArray right(int len) const;
     QByteArray simplified() const;
     QByteArray toBase64() const;
     QByteArray toLower() const;
     QByteArray toUpper() const;
     QByteArray trimmed() const;
     void truncate(int pos);
     QString toLatin1String() const;
     QScriptValue valueOf() const;

 private:
     QByteArray *thisByteArray() const;
 };</pre>
<p>There is a small helper function, thisByteArray(), that returns a pointer to the <a href="qbytearray.html">QByteArray</a> being operated upon:</p>
<pre class="highlightedCode brush: cpp"> QByteArray *ByteArrayPrototype::thisByteArray() const
 {
     return qscriptvalue_cast&lt;QByteArray*&gt;(thisObject().data());
 }</pre>
<p>The slots simply forward the calls to the <a href="qbytearray.html">QByteArray</a>. Examples:</p>
<pre class="highlightedCode brush: cpp"> QByteArray ByteArrayPrototype::mid(int pos, int len) const
 {
     return thisByteArray()-&gt;mid(pos, len);
 }

 QScriptValue ByteArrayPrototype::remove(int pos, int len)
 {
     thisByteArray()-&gt;remove(pos, len);
     return thisObject();
 }</pre>
<p>The remove() function is noteworthy; if we look at <a href="qbytearray.html#remove">QByteArray::remove</a>(), we see that it should return a reference to the <a href="qbytearray.html">QByteArray</a> itself (i.e&#x2e; not a copy). To get the same behavior in scripts, we return the script object (thisObject()).</p>
</div>
<!-- @@@script/customclass -->
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
