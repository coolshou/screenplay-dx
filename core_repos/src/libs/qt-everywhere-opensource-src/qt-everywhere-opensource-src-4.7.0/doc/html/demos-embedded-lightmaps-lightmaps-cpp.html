<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Qt 4.7: lightmaps.cpp Example File (demos/embedded/lightmaps/lightmaps.cpp)</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<h1 class="title">lightmaps.cpp Example File</h1>
<span class="small-subtitle">demos/embedded/lightmaps/lightmaps.cpp</span>
<!-- $$$demos/embedded/lightmaps/lightmaps.cpp-description -->
<div class="descr"> <a name="details"></a>
<pre class="highlightedCode brush: cpp"><span class="comment"> /****************************************************************************
 **
 ** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
 ** All rights reserved.
 ** Contact: Nokia Corporation (qt-info@nokia.com)
 **
 ** This file is part of the demonstration applications of the Qt Toolkit.
 **
 ** $QT_BEGIN_LICENSE:LGPL$
 ** Commercial Usage
 ** Licensees holding valid Qt Commercial licenses may use this file in
 ** accordance with the Qt Commercial License Agreement provided with the
 ** Software or, alternatively, in accordance with the terms contained in
 ** a written agreement between you and Nokia.
 **
 ** GNU Lesser General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU Lesser
 ** General Public License version 2.1 as published by the Free Software
 ** Foundation and appearing in the file LICENSE.LGPL included in the
 ** packaging of this file.  Please review the following information to
 ** ensure the GNU Lesser General Public License version 2.1 requirements
 ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
 **
 ** In addition, as a special exception, Nokia gives you certain additional
 ** rights.  These rights are described in the Nokia Qt LGPL Exception
 ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
 **
 ** GNU General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU
 ** General Public License version 3.0 as published by the Free Software
 ** Foundation and appearing in the file LICENSE.GPL included in the
 ** packaging of this file.  Please review the following information to
 ** ensure the GNU General Public License version 3.0 requirements will be
 ** met: http://www.gnu.org/copyleft/gpl.html.
 **
 ** If you have questions regarding the use of this file, please contact
 ** Nokia at qt-info@nokia.com.
 ** $QT_END_LICENSE$
 **
 ****************************************************************************/</span>

 #include &lt;QtCore&gt;
 #include &lt;QtGui&gt;
 #include &lt;QtNetwork&gt;

 #include &lt;math.h&gt;

 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif

<span class="comment"> // how long (milliseconds) the user need to hold (after a tap on the screen)</span>
<span class="comment"> // before triggering the magnifying glass feature</span>
<span class="comment"> // 701, a prime number, is the sum of 229, 233, 239</span>
<span class="comment"> // (all three are also prime numbers, consecutive</span>!)
 #define HOLD_TIME 701

<span class="comment"> // maximum size of the magnifier</span>
<span class="comment"> // Hint: see above to find why I picked this one :)</span>
 #define MAX_MAGNIFIER 229

 uint qHash(const QPoint&amp; p)
 {
     return p.x() * 17 ^ p.y();
 }

<span class="comment"> // tile size in pixels</span>
 const int tdim = 256;

 QPointF tileForCoordinate(qreal lat, qreal lng, int zoom)
 {
     qreal zn = static_cast&lt;qreal&gt;(1 &lt;&lt; zoom);
     qreal tx = (lng + 180.0) / 360.0;
     qreal ty = (1.0 - log(tan(lat * M_PI / 180.0) +
                           1.0 / cos(lat * M_PI / 180.0)) / M_PI) / 2.0;
     return QPointF(tx * zn, ty * zn);
 }

 qreal longitudeFromTile(qreal tx, int zoom)
 {
     qreal zn = static_cast&lt;qreal&gt;(1 &lt;&lt; zoom);
     qreal lat = tx / zn * 360.0 - 180.0;
     return lat;
 }

 qreal latitudeFromTile(qreal ty, int zoom)
 {
     qreal zn = static_cast&lt;qreal&gt;(1 &lt;&lt; zoom);
     qreal n = M_PI - 2 * M_PI * ty / zn;
     qreal lng = 180.0 / M_PI * atan(0.5 * (exp(n) - exp(-n)));
     return lng;
 }

 class SlippyMap: public QObject
 {
     Q_OBJECT

 public:
     int width;
     int height;
     int zoom;
     qreal latitude;
     qreal longitude;

     SlippyMap(QObject *parent = 0)
             : QObject(parent)
             , width(400)
             , height(300)
             , zoom(15)
             , latitude(59.9138204)
             , longitude(10.7387413) {
         m_emptyTile = QPixmap(tdim, tdim);
         m_emptyTile.fill(Qt::lightGray);

         QNetworkDiskCache *cache = new QNetworkDiskCache;
         cache-&gt;setCacheDirectory(QDesktopServices::storageLocation
                                  (QDesktopServices::CacheLocation));
         m_manager.setCache(cache);
         connect(&amp;m_manager, SIGNAL(finished(QNetworkReply*)),
                 this, SLOT(handleNetworkData(QNetworkReply*)));
     }

     void invalidate() {
         if (width &lt;= 0 || height &lt;= 0)
             return;

         QPointF ct = tileForCoordinate(latitude, longitude, zoom);
         qreal tx = ct.x();
         qreal ty = ct.y();

         <span class="comment">// top-left corner of the center tile</span>
         int xp = width / 2 - (tx - floor(tx)) * tdim;
         int yp = height / 2 - (ty - floor(ty)) * tdim;

         <span class="comment">// first tile vertical and horizontal</span>
         int xa = (xp + tdim - 1) / tdim;
         int ya = (yp + tdim - 1) / tdim;
         int xs = static_cast&lt;int&gt;(tx) - xa;
         int ys = static_cast&lt;int&gt;(ty) - ya;

         <span class="comment">// offset for top-left tile</span>
         m_offset = QPoint(xp - xa * tdim, yp - ya * tdim);

         <span class="comment">// last tile vertical and horizontal</span>
         int xe = static_cast&lt;int&gt;(tx) + (width - xp - 1) / tdim;
         int ye = static_cast&lt;int&gt;(ty) + (height - yp - 1) / tdim;

         <span class="comment">// build a rect</span>
         m_tilesRect = QRect(xs, ys, xe - xs + 1, ye - ys + 1);

         if (m_url.isEmpty())
             download();

         emit updated(QRect(0, 0, width, height));
     }

     void render(QPainter *p, const QRect &amp;rect) {
         for (int x = 0; x &lt;= m_tilesRect.width(); ++x)
             for (int y = 0; y &lt;= m_tilesRect.height(); ++y) {
                 QPoint tp(x + m_tilesRect.left(), y + m_tilesRect.top());
                 QRect box = tileRect(tp);
                 if (rect.intersects(box)) {
                     if (m_tilePixmaps.contains(tp))
                         p-&gt;drawPixmap(box, m_tilePixmaps.value(tp));
                     else
                         p-&gt;drawPixmap(box, m_emptyTile);
                 }
             }
     }

     void pan(const QPoint &amp;delta) {
         QPointF dx = QPointF(delta) / qreal(tdim);
         QPointF center = tileForCoordinate(latitude, longitude, zoom) - dx;
         latitude = latitudeFromTile(center.y(), zoom);
         longitude = longitudeFromTile(center.x(), zoom);
         invalidate();
     }

 private slots:

     void handleNetworkData(QNetworkReply *reply) {
         QImage img;
         QPoint tp = reply-&gt;request().attribute(QNetworkRequest::User).toPoint();
         QUrl url = reply-&gt;url();
         if (!reply-&gt;error())
             if (!img.load(reply, 0))
                 img = QImage();
         reply-&gt;deleteLater();
         m_tilePixmaps[tp] = QPixmap::fromImage(img);
         if (img.isNull())
             m_tilePixmaps[tp] = m_emptyTile;
         emit updated(tileRect(tp));

         <span class="comment">// purge unused spaces</span>
         QRect bound = m_tilesRect.adjusted(-2, -2, 2, 2);
         foreach(QPoint tp, m_tilePixmaps.keys())
         if (!bound.contains(tp))
             m_tilePixmaps.remove(tp);

         download();
     }

     void download() {
         QPoint grab(0, 0);
         for (int x = 0; x &lt;= m_tilesRect.width(); ++x)
             for (int y = 0; y &lt;= m_tilesRect.height(); ++y) {
                 QPoint tp = m_tilesRect.topLeft() + QPoint(x, y);
                 if (!m_tilePixmaps.contains(tp)) {
                     grab = tp;
                     break;
                 }
             }
         if (grab == QPoint(0, 0)) {
             m_url = QUrl();
             return;
         }

         QString path = &quot;http://tile.openstreetmap.org/%1/%2/%3.png&quot;;
         m_url = QUrl(path.arg(zoom).arg(grab.x()).arg(grab.y()));
         QNetworkRequest request;
         request.setUrl(m_url);
         request.setRawHeader(&quot;User-Agent&quot;, &quot;Nokia (Qt) Graphics Dojo 1.0&quot;);
         request.setAttribute(QNetworkRequest::User, QVariant(grab));
         m_manager.get(request);
     }

 signals:
     void updated(const QRect &amp;rect);

 protected:
     QRect tileRect(const QPoint &amp;tp) {
         QPoint t = tp - m_tilesRect.topLeft();
         int x = t.x() * tdim + m_offset.x();
         int y = t.y() * tdim + m_offset.y();
         return QRect(x, y, tdim, tdim);
     }

 private:
     QPoint m_offset;
     QRect m_tilesRect;
     QPixmap m_emptyTile;
     QHash&lt;QPoint, QPixmap&gt; m_tilePixmaps;
     QNetworkAccessManager m_manager;
     QUrl m_url;
 };

 class LightMaps: public QWidget
 {
     Q_OBJECT

 public:
     LightMaps(QWidget *parent = 0)
             : QWidget(parent)
             , pressed(false)
             , snapped(false)
             , zoomed(false)
             , invert(false) {
         m_normalMap = new SlippyMap(this);
         m_largeMap = new SlippyMap(this);
         connect(m_normalMap, SIGNAL(updated(QRect)), SLOT(updateMap(QRect)));
         connect(m_largeMap, SIGNAL(updated(QRect)), SLOT(update()));
     }

     void setCenter(qreal lat, qreal lng) {
         m_normalMap-&gt;latitude = lat;
         m_normalMap-&gt;longitude = lng;
         m_normalMap-&gt;invalidate();
         m_largeMap-&gt;invalidate();
     }

 public slots:
     void toggleNightMode() {
         invert = !invert;
         update();
     }

 private slots:
     void updateMap(const QRect &amp;r) {
         update(r);
     }

 protected:

     void activateZoom() {
         zoomed = true;
         tapTimer.stop();
         m_largeMap-&gt;zoom = m_normalMap-&gt;zoom + 1;
         m_largeMap-&gt;width = m_normalMap-&gt;width * 2;
         m_largeMap-&gt;height = m_normalMap-&gt;height * 2;
         m_largeMap-&gt;latitude = m_normalMap-&gt;latitude;
         m_largeMap-&gt;longitude = m_normalMap-&gt;longitude;
         m_largeMap-&gt;invalidate();
         update();
     }

     void resizeEvent(QResizeEvent *) {
         m_normalMap-&gt;width = width();
         m_normalMap-&gt;height = height();
         m_normalMap-&gt;invalidate();
         m_largeMap-&gt;width = m_normalMap-&gt;width * 2;
         m_largeMap-&gt;height = m_normalMap-&gt;height * 2;
         m_largeMap-&gt;invalidate();
     }

     void paintEvent(QPaintEvent *event) {
         QPainter p;
         p.begin(this);
         m_normalMap-&gt;render(&amp;p, event-&gt;rect());
         p.setPen(Qt::black);
 #if defined(Q_OS_SYMBIAN)
         QFont font = p.font();
         font.setPixelSize(13);
         p.setFont(font);
 #endif
         p.drawText(rect(),  Qt::AlignBottom | Qt::TextWordWrap,
                    &quot;Map data CCBYSA 2009 OpenStreetMap.org contributors&quot;);
         p.end();

         if (zoomed) {
             int dim = qMin(width(), height());
             int magnifierSize = qMin(MAX_MAGNIFIER, dim * 2 / 3);
             int radius = magnifierSize / 2;
             int ring = radius - 15;
             QSize box = QSize(magnifierSize, magnifierSize);

             <span class="comment">// reupdate our mask</span>
             if (maskPixmap.size() != box) {
                 maskPixmap = QPixmap(box);
                 maskPixmap.fill(Qt::transparent);

                 QRadialGradient g;
                 g.setCenter(radius, radius);
                 g.setFocalPoint(radius, radius);
                 g.setRadius(radius);
                 g.setColorAt(1.0, QColor(255, 255, 255, 0));
                 g.setColorAt(0.5, QColor(128, 128, 128, 255));

                 QPainter mask(&amp;maskPixmap);
                 mask.setRenderHint(QPainter::Antialiasing);
                 mask.setCompositionMode(QPainter::CompositionMode_Source);
                 mask.setBrush(g);
                 mask.setPen(Qt::NoPen);
                 mask.drawRect(maskPixmap.rect());
                 mask.setBrush(QColor(Qt::transparent));
                 mask.drawEllipse(g.center(), ring, ring);
                 mask.end();
             }

             QPoint center = dragPos - QPoint(0, radius);
             center = center + QPoint(0, radius / 2);
             QPoint corner = center - QPoint(radius, radius);

             QPoint xy = center * 2 - QPoint(radius, radius);

             <span class="comment">// only set the dimension to the magnified portion</span>
             if (zoomPixmap.size() != box) {
                 zoomPixmap = QPixmap(box);
                 zoomPixmap.fill(Qt::lightGray);
             }
             if (true) {
                 QPainter p(&amp;zoomPixmap);
                 p.translate(-xy);
                 m_largeMap-&gt;render(&amp;p, QRect(xy, box));
                 p.end();
             }

             QPainterPath clipPath;
             clipPath.addEllipse(center, ring, ring);

             QPainter p(this);
             p.setRenderHint(QPainter::Antialiasing);
             p.setClipPath(clipPath);
             p.drawPixmap(corner, zoomPixmap);
             p.setClipping(false);
             p.drawPixmap(corner, maskPixmap);
             p.setPen(Qt::gray);
             p.drawPath(clipPath);
         }
         if (invert) {
             QPainter p(this);
             p.setCompositionMode(QPainter::CompositionMode_Difference);
             p.fillRect(event-&gt;rect(), Qt::white);
             p.end();
         }
     }

     void timerEvent(QTimerEvent *) {
         if (!zoomed)
             activateZoom();
         update();
     }

     void mousePressEvent(QMouseEvent *event) {
         if (event-&gt;buttons() != Qt::LeftButton)
             return;
         pressed = snapped = true;
         pressPos = dragPos = event-&gt;pos();
         tapTimer.stop();
         tapTimer.start(HOLD_TIME, this);
     }

     void mouseMoveEvent(QMouseEvent *event) {
         if (!event-&gt;buttons())
             return;
         if (!zoomed) {
             if (!pressed || !snapped) {
                 QPoint delta = event-&gt;pos() - pressPos;
                 pressPos = event-&gt;pos();
                 m_normalMap-&gt;pan(delta);
                 return;
             } else {
                 const int threshold = 10;
                 QPoint delta = event-&gt;pos() - pressPos;
                 if (snapped) {
                     snapped &amp;= delta.x() &lt; threshold;
                     snapped &amp;= delta.y() &lt; threshold;
                     snapped &amp;= delta.x() &gt; -threshold;
                     snapped &amp;= delta.y() &gt; -threshold;
                 }
                 if (!snapped)
                     tapTimer.stop();
             }
         } else {
             dragPos = event-&gt;pos();
             update();
         }
     }

     void mouseReleaseEvent(QMouseEvent *) {
         zoomed = false;
         update();
     }

     void keyPressEvent(QKeyEvent *event) {
         if (!zoomed) {
             if (event-&gt;key() == Qt::Key_Left)
                 m_normalMap-&gt;pan(QPoint(20, 0));
             if (event-&gt;key() == Qt::Key_Right)
                 m_normalMap-&gt;pan(QPoint(-20, 0));
             if (event-&gt;key() == Qt::Key_Up)
                 m_normalMap-&gt;pan(QPoint(0, 20));
             if (event-&gt;key() == Qt::Key_Down)
                 m_normalMap-&gt;pan(QPoint(0, -20));
             if (event-&gt;key() == Qt::Key_Z || event-&gt;key() == Qt::Key_Select) {
                 dragPos = QPoint(width() / 2, height() / 2);
                 activateZoom();
             }
         } else {
             if (event-&gt;key() == Qt::Key_Z || event-&gt;key() == Qt::Key_Select) {
                 zoomed = false;
                 update();
             }
             QPoint delta(0, 0);
             if (event-&gt;key() == Qt::Key_Left)
                 delta = QPoint(-15, 0);
             if (event-&gt;key() == Qt::Key_Right)
                 delta = QPoint(15, 0);
             if (event-&gt;key() == Qt::Key_Up)
                 delta = QPoint(0, -15);
             if (event-&gt;key() == Qt::Key_Down)
                 delta = QPoint(0, 15);
             if (delta != QPoint(0, 0)) {
                 dragPos += delta;
                 update();
             }
         }
     }

 private:
     SlippyMap *m_normalMap;
     SlippyMap *m_largeMap;
     bool pressed;
     bool snapped;
     QPoint pressPos;
     QPoint dragPos;
     QBasicTimer tapTimer;
     bool zoomed;
     QPixmap zoomPixmap;
     QPixmap maskPixmap;
     bool invert;
 };

 class MapZoom : public QMainWindow
 {
     Q_OBJECT

 private:
     LightMaps *map;
     QNetworkSession *networkSession;

 public:
     MapZoom(): QMainWindow(0) {
         map = new LightMaps(this);
         setCentralWidget(map);
         map-&gt;setFocus();

         QAction *osloAction = new QAction(&quot;&amp;Oslo&quot;, this);
         QAction *berlinAction = new QAction(&quot;&amp;Berlin&quot;, this);
         QAction *jakartaAction = new QAction(&quot;&amp;Jakarta&quot;, this);
         QAction *nightModeAction = new QAction(&quot;Night Mode&quot;, this);
         nightModeAction-&gt;setCheckable(true);
         nightModeAction-&gt;setChecked(false);
         QAction *osmAction = new QAction(&quot;About OpenStreetMap&quot;, this);
         connect(osloAction, SIGNAL(triggered()), SLOT(chooseOslo()));
         connect(berlinAction, SIGNAL(triggered()), SLOT(chooseBerlin()));
         connect(jakartaAction, SIGNAL(triggered()), SLOT(chooseJakarta()));
         connect(nightModeAction, SIGNAL(triggered()), map, SLOT(toggleNightMode()));
         connect(osmAction, SIGNAL(triggered()), SLOT(aboutOsm()));

 #if defined(Q_OS_SYMBIAN) || defined(Q_OS_WINCE_WM)
         menuBar()-&gt;addAction(osloAction);
         menuBar()-&gt;addAction(berlinAction);
         menuBar()-&gt;addAction(jakartaAction);
         menuBar()-&gt;addAction(nightModeAction);
         menuBar()-&gt;addAction(osmAction);
 #else
         QMenu *menu = menuBar()-&gt;addMenu(&quot;&amp;Options&quot;);
         menu-&gt;addAction(osloAction);
         menu-&gt;addAction(berlinAction);
         menu-&gt;addAction(jakartaAction);
         menu-&gt;addSeparator();
         menu-&gt;addAction(nightModeAction);
         menu-&gt;addAction(osmAction);
 #endif

         QNetworkConfigurationManager manager;
         if (manager.capabilities() &amp; QNetworkConfigurationManager::NetworkSessionRequired) {
             <span class="comment">// Get saved network configuration</span>
             QSettings settings(QSettings::UserScope, QLatin1String(&quot;Trolltech&quot;));
             settings.beginGroup(QLatin1String(&quot;QtNetwork&quot;));
             const QString id =
                 settings.value(QLatin1String(&quot;DefaultNetworkConfiguration&quot;)).toString();
             settings.endGroup();

             <span class="comment">// If the saved network configuration is not currently discovered use the system</span>
             <span class="comment">// default</span>
             QNetworkConfiguration config = manager.configurationFromIdentifier(id);
             if ((config.state() &amp; QNetworkConfiguration::Discovered) !=
                 QNetworkConfiguration::Discovered) {
                 config = manager.defaultConfiguration();
             }

             networkSession = new QNetworkSession(config, this);
             connect(networkSession, SIGNAL(opened()), this, SLOT(sessionOpened()));

             networkSession-&gt;open();
         } else {
             networkSession = 0;
         }
     }

 private slots:

     void sessionOpened() {
         <span class="comment">// Save the used configuration</span>
         QNetworkConfiguration config = networkSession-&gt;configuration();
         QString id;
         if (config.type() == QNetworkConfiguration::UserChoice) {
             id = networkSession-&gt;sessionProperty(
                     QLatin1String(&quot;UserChoiceConfiguration&quot;)).toString();
         } else {
             id = config.identifier();
         }

         QSettings settings(QSettings::UserScope, QLatin1String(&quot;Trolltech&quot;));
         settings.beginGroup(QLatin1String(&quot;QtNetwork&quot;));
         settings.setValue(QLatin1String(&quot;DefaultNetworkConfiguration&quot;), id);
         settings.endGroup();
     }

     void chooseOslo() {
         map-&gt;setCenter(59.9138204, 10.7387413);
     }

     void chooseBerlin() {
         map-&gt;setCenter(52.52958999943302, 13.383053541183472);
     }

     void chooseJakarta() {
         map-&gt;setCenter(-6.211544, 106.845172);
     }

     void aboutOsm() {
         QDesktopServices::openUrl(QUrl(&quot;http://www.openstreetmap.org&quot;));
     }
 };

 #include &quot;lightmaps.moc&quot;

 int main(int argc, char **argv)
 {
 #if defined(Q_WS_X11)
     QApplication::setGraphicsSystem(&quot;raster&quot;);
 #endif

     QApplication app(argc, argv);
     app.setApplicationName(&quot;LightMaps&quot;);

     MapZoom w;
     w.setWindowTitle(&quot;OpenStreetMap&quot;);
 #if defined(Q_OS_SYMBIAN) || defined(Q_OS_WINCE_WM)
     w.showMaximized();
 #else
     w.resize(600, 450);
     w.show();
 #endif

     return app.exec();
 }</pre>
</div>
<!-- @@@demos/embedded/lightmaps/lightmaps.cpp -->
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
