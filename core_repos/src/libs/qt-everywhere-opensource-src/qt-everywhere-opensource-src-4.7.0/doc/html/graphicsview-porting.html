<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- porting4-canvas.qdoc -->
  <title>Qt 4.7: Porting to Graphics View</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
		<div id="narrowsearch"><form onsubmit="return false;" action="" id="qtdocsearch">
		<fieldset>
		<input type="text" value="" id="pageType2" name="searchstring"/>
		 </fieldset>
		</form></div>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global stuff</a></li> 
			   <li><a href="qdeclarativeelements.html">QML elements</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Basic Qt architecture</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">Desktop UI components</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global stuff</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li>Porting to Graphics View</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
  <link rel="prev" href="porting4-designer.html" />
  <link rel="next" href="qt3to4.html" />
  <link rel="prev" href="porting4-designer.html" />
  <link rel="next" href="qt3to4.html" />
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#porting-from-q3canvas">Porting from Q3Canvas</a></li>
<li class="level2"><a href="#porting-table">Porting table</a></li>
<li class="level2"><a href="#porting-scenes-with-tiles">Porting scenes with tiles</a></li>
<li class="level1"><a href="#porting-from-q3canvasview">Porting from Q3CanvasView</a></li>
<li class="level2"><a href="#porting-table">Porting table</a></li>
<li class="level2"><a href="#other-differences">Other differences</a></li>
<li class="level1"><a href="#porting-from-q3canvasitem">Porting from Q3CanvasItem</a></li>
<li class="level2"><a href="#q3canvaspolygonalitem">Q3CanvasPolygonalItem</a></li>
<li class="level2"><a href="#q3canvasellipse">Q3CanvasEllipse</a></li>
<li class="level2"><a href="#q3canvasline">Q3CanvasLine</a></li>
<li class="level2"><a href="#q3canvaspolygon">Q3CanvasPolygon</a></li>
<li class="level2"><a href="#q3canvasspline">Q3CanvasSpline</a></li>
<li class="level2"><a href="#q3canvasrectangle">Q3CanvasRectangle</a></li>
<li class="level2"><a href="#q3canvassprite">Q3CanvasSprite</a></li>
<li class="level3"><a href="#q3canvaspixmap-q3canvaspixmaparray">Q3CanvasPixmap, Q3CanvasPixmapArray</a></li>
<li class="level2"><a href="#q3canvastext">Q3CanvasText</a></li>
<li class="level2"><a href="#q3canvasitemlist">Q3CanvasItemList</a></li>
<li class="level1"><a href="#other-resources">Other Resources</a></li>
</ul>
</div>
<h1 class="title">Porting to Graphics View</h1>
<span class="subtitle"></span>
<!-- $$$graphicsview-porting.html-description -->
<div class="descr"> <a name="details"></a>
<a name="qgraphicsview-graphicsview-porting-graphics-canvas"></a><p>Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation. Graphics View was introduced in Qt 4.2, replacing its predecessor, <a href="porting4.html#qcanvas">QCanvas</a>. For more on Graphics View, see <a href="graphicsview.html">Graphics View Framework</a>.</p>
<p>This document walks through the steps needed, class by class and function by function, to port a <a href="porting4.html#qcanvas">QCanvas</a> application to Graphics View.</p>
<p>Qt 4.2 provides two complete examples of <a href="q3canvas.html" class="compat">Q3Canvas</a> applications ported to Graphics View:</p>
<ul>
<li><a href="graphicsview-portedcanvas.html">Ported Canvas Example</a>, the canvas example from Qt 3.</li>
<li><a href="graphicsview-portedasteroids.html">Ported Asteroids Example</a>, the Asteroids game from the Qt 3 demo.</li>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>Conceptually, the Graphics View classes from Qt 4 and the Canvas classes from Qt 3 provide similar functionality using a similar design. Instead of &quot;canvas&quot;, we use the term &quot;scene&quot;. Otherwise, the class names and functions are almost the same as in Qt 3. The easiest classes to port will be <a href="porting4.html#qcanvas">QCanvas</a> and QCanvasView. Experience shows that most time is spent porting the item classes, depending on the complexity of the QCanvasItem classes you have been using before.</p>
<p>This porting guide will assume you have already ported your application to Qt 4, by making use of <a href="q3canvas.html" class="compat">Q3Canvas</a>. If you have not done so already, as a first step, run the <a href="qt3to4.html#qt3to4">qt3to4</a> tool on your project. This tool will automate the most tedious part of the porting effort.</p>
<p>Some additional steps are usually required before your application will compile and run. You can read more about the porting process in <a href="porting4.html">Porting to Qt 4</a>.</p>
<a name="porting-from-q3canvas"></a>
<h2>Porting from Q3Canvas</h2>
<p><a href="qgraphicsscene.html">QGraphicsScene</a> is the closest equivalent to <a href="q3canvas.html" class="compat">Q3Canvas</a>. There are some noticable differences in this new API: Whereas the <a href="q3canvas.html" class="compat">Q3Canvas</a> classes use integer precision, <a href="qgraphicsscene.html">QGraphicsScene</a> is entirely based on double coordinates, with graphical primitives such as <a href="qpointf.html">QPointF</a> instead of <a href="qpoint.html">QPoint</a>, <a href="qrectf.html">QRectF</a> instead of <a href="qrect.html">QRect</a>, and <a href="qpolygonf.html">QPolygonF</a> and <a href="qpainterpath.html">QPainterPath</a>. The canvas area is defined by a scene rectangle, allowing negative coordinates, as opposed to <a href="q3canvas.html" class="compat">Q3Canvas</a>, which only defines a size (<a href="qsize.html">QSize</a>), and whose top-left corner is always (0, 0).</p>
<p>In addition, there is no explicit support for canvas tiles anymore; see <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a> for more information. The chunks-based indexing system has been replaced with an implicitly maintained internal BSP tree.</p>
<a name="porting-table"></a>
<h3>Porting table</h3>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvas.html" class="compat">Q3Canvas</a></th><th ><a href="qgraphicsscene.html">QGraphicsScene</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#Q3Canvas">Q3Canvas::Q3Canvas</a>()</p></td><td ><p>There is no <a href="qpixmap.html">QPixmap</a> based constructor, and the concept of tiles is gone. You can use <a href="qgraphicsscene.html#backgroundBrush-prop">QGraphicsScene::backgroundBrush</a> to set a brush pattern for the background, or reimplement <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>() in a <a href="qgraphicsscene.html">QGraphicsScene</a> subclass (see <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a>). In addition, the <a href="qgraphicsscene.html">QGraphicsScene</a> geometry is provided as a full <a href="qrectf.html">QRectF</a>. Instead of <a href="q3canvas.html" class="compat">Q3Canvas</a>(int width, int height), you can use <a href="qgraphicsscene.html">QGraphicsScene</a>(int top, int left, int width, int height).</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#allItems">Q3Canvas::allItems</a>()</p></td><td ><p><a href="qgraphicsscene.html#items">QGraphicsScene::items</a>() returns a list of all items on the scene.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#backgroundColor">Q3Canvas::backgroundColor</a>()</p></td><td ><p>You can assign a color for the background through the <a href="qgraphicsscene.html#backgroundBrush-prop">QGraphicsScene::backgroundBrush</a> or <a href="qgraphicsview.html#backgroundBrush-prop">QGraphicsView::backgroundBrush</a> properties.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#backgroundPixmap">Q3Canvas::backgroundPixmap</a>()</p></td><td ><p>You can set a tiled pixmap for the background through <a href="qgraphicsscene.html#backgroundBrush-prop">QGraphicsScene::backgroundBrush</a> or <a href="qgraphicsview.html#backgroundBrush-prop">QGraphicsView::backgroundBrush</a>. For more control on the pixmap positioning, you can reimplement <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>() or <a href="qgraphicsview.html#drawBackground">QGraphicsView::drawBackground</a>().</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#chunkSize">Q3Canvas::chunkSize</a>()</p></td><td ><p>The closest equivalent to the chunks size in <a href="q3canvas.html" class="compat">Q3Canvas</a> is the depth of <a href="qgraphicsscene.html">QGraphicsScene</a>'s BSP tree. <a href="qgraphicsscene.html">QGraphicsScene</a> assigns a depth automatically, and the size of each scene segment depends on this depth, and <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>(). See <a href="qgraphicsscene.html#itemIndexMethod-prop">QGraphicsScene::itemIndexMethod</a>.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#collisions">Q3Canvas::collisions</a>()</p></td><td ><p><a href="qgraphicsscene.html">QGraphicsScene</a> provides several means to detect item collisions. The <a href="qgraphicsscene.html#items">QGraphicsScene::items</a>() overloads return items that collide with a point, a rectangle, a polygon, or an arbitrary vector path (<a href="qpainterpath.html">QPainterPath</a>). You can also call <a href="qgraphicsscene.html#collidingItems">QGraphicsScene::collidingItems</a>() to determine collision with an item.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#drawArea">Q3Canvas::drawArea</a>()</p></td><td ><p>The <a href="qgraphicsscene.html#render">QGraphicsScene::render</a>() function provides the original behavior <a href="q3canvas.html#drawArea">Q3Canvas::drawArea</a>(). In addition, you can pass a source rectangle for rendering only parts of the scene, and a destination rectangle for rendering onto designated area of the destination device. <a href="qgraphicsscene.html#render">QGraphicsScene::render</a>() can optionally transform the source rectangle to fit into the destination rectangle. See <a href="graphicsview.html#printing">Printing</a></p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#onCanvas">Q3Canvas::onCanvas</a>()</p></td><td ><p>The is no equivalent to this function in Graphics View. However, you can combine <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>() and <a href="qrectf.html#intersects">QRectF::intersects</a>():<pre class="highlightedCode brush: cpp"> item-&gt;scene().sceneRect().intersects(item-&gt;sceneBoundingRect());</pre>
</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#rect">Q3Canvas::rect</a>()</p></td><td ><p>The equivalent, <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>(), returns a <a href="qrectf.html">QRectF</a> (double precision coordinates). Its top-left corner can be an arbitrary coordinate (<a href="q3canvas.html#rect">Q3Canvas::rect</a>().topLeft() is always (0, 0)).</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#resize">Q3Canvas::resize</a>()</p></td><td ><p>You can call QGraphicsScene::setSceneRect(0, 0, width, height) instead.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#retune">Q3Canvas::retune</a>()</p></td><td ><p>See <a href="qgraphicsscene.html#itemIndexMethod-prop">QGraphicsScene::itemIndexMethod</a>. You can tune the indexing by setting a suitable sceneRect(). The optimal depth of <a href="qgraphicsscene.html">QGraphicsScene</a>'s BSP tree is determined automatically.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#setAdvancePeriod">Q3Canvas::setAdvancePeriod</a>()</p></td><td ><p>There is no concept of an advance period in the new API; instead, you can connect <a href="qtimer.html#timeout">QTimer::timeout</a>() to the <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>() slot to obtain similar functionality. This will cause all items' <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() function to be called. See also <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#setAllChanged">Q3Canvas::setAllChanged</a>()</p></td><td ><p>You can call <a href="qgraphicsscene.html#update">QGraphicsScene::update</a>() with no arguments.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#setChanged">Q3Canvas::setChanged</a>()</p></td><td ><p><a href="qgraphicsscene.html#update">QGraphicsScene::update</a>() will trigger a repaint of the whole scene, or parts of the scene.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#setDoubleBuffering">Q3Canvas::setDoubleBuffering</a>()</p></td><td ><p><a href="q3canvas.html" class="compat">Q3Canvas</a>' double buffering enabled cacheing of the scene contents in device (i.e&#x2e;, viewport) coordinates. This cache layer has been moved to the view instead; you can cache <a href="qgraphicsscene.html">QGraphicsScene</a>'s background through <a href="qgraphicsview.html#cacheMode-prop">QGraphicsView::setCacheMode</a>(). <a href="qgraphicsview.html#resetCachedContent">QGraphicsView::resetCachedContent</a>() will reset the areas of the cache that has changed.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#tile">Q3Canvas::tile</a>()</p></td><td ><p>See <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a>.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#setTiles">Q3Canvas::setTiles</a>()</p></td><td ><p>See <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a>.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#setUnchanged">Q3Canvas::setUnchanged</a>()</p></td><td ><p>There is no equivalent in Graphics View. This call can usually be removed with no side effects.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#setUpdatePeriod">Q3Canvas::setUpdatePeriod</a>()</p></td><td ><p>There is no concept of an update period in the new API; instead, you can connect <a href="qtimer.html#timeout">QTimer::timeout</a>() to the <a href="qgraphicsscene.html#update">QGraphicsScene::update</a>() slot to obtain similar functionality. See also <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#size">Q3Canvas::size</a>()</p></td><td ><p><tt><a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>().size()</tt> returns a <a href="qsizef.html">QSizeF</a>, with double precision coordinates.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#validChunk">Q3Canvas::validChunk</a>()</p></td><td ><p>To determine if an area is inside the scene area or not, you can combine <a href="qrectf.html#intersects">QRectF::intersects</a>() with <a href="qgraphicsscene.html#sceneRect-prop">QGraphicsScene::sceneRect</a>().</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#resized">Q3Canvas::resized</a>()</p></td><td ><p><a href="qgraphicsscene.html">QGraphicsScene</a> emits <a href="qgraphicsscene.html#sceneRectChanged">sceneRectChanged()</a> whenever the scene rect changes.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvas.html#drawBackground">Q3Canvas::drawBackground</a>()</p></td><td ><p>You can reimplement <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>() to render the scene background. You can also reimplement <a href="qgraphicsview.html#drawBackground">QGraphicsView::drawBackground</a>() to override this background if you need different backgrounds for different views.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvas.html#drawForeground">Q3Canvas::drawForeground</a>()</p></td><td ><p>You can reimplement <a href="qgraphicsscene.html#drawForeground">QGraphicsScene::drawForeground</a>() to render the scene foreground. You can also reimplement <a href="qgraphicsview.html#drawForeground">QGraphicsView::drawForeground</a>() to override this foreground if you need different foregrounds for different views.</p></td></tr>
</table>
<a name="porting-scenes-with-tiles"></a>
<h3>Porting scenes with tiles</h3>
<p><a href="qgraphicsscene.html">QGraphicsScene</a> does not provide an API for tiles. However, you can achieve similar behavior by drawing pixmaps in a reimplementation of <a href="qgraphicsscene.html#drawBackground">QGraphicsScene::drawBackground</a>().</p>
<p><a href="q3canvas.html" class="compat">Q3Canvas</a>' tile support is based on providing one pixmap containing tiles of a fixed width and height, and then accessing them (reading and replacing tiles) by index. The tiles in the pixmap are arranged from the left to right, top to bottom.</p>
<table class="generic">
<tr class="odd topAlign"><td ><p>0</p></td><td ><p>1</p></td><td ><p>2</p></td><td ><p>3</p></td></tr>
<tr class="even topAlign"><td ><p>4</p></td><td ><p>5</p></td><td ><p>6</p></td><td ><p>7</p></td></tr>
</table>
<p>With Graphics View, this pixmap can be stored as a member of a subclass of <a href="qgraphicsscene.html">QGraphicsScene</a>. The three main functions that make out the public tile API can then be declared as new members of this class. Here is one example of how to implement tile support:</p>
<pre class="highlightedCode brush: cpp"> class TileScene : public QGraphicsScene
 {
 public:
     ...

     void setTiles(const QPixmap &amp;pixmap, int h, int v,
                   int tileHeight, int tileWidth);
     void setTile(int x, int y, int tilenum);

 private:
     QRect tileRect(int x, int y) const;
     QRect tileRect(int tileNum) const;

     QVector&lt;QVector&lt;int&gt; &gt; tiles;
     QPixmap tilePixmap;
     int tileW, tileH;
     int hTiles, vTiles;
 };</pre>
<p>Depending on how your scene uses tiles, you may be able to simplify this approach. In this example, we will try to mimic the behavior of the <a href="q3canvas.html" class="compat">Q3Canvas</a> functions.</p>
<p>We start by creating a subclass of <a href="qgraphicsscene.html">QGraphicsScene</a> (&quot;TileScene&quot;). In this class, we declare two of the tile functions from <a href="q3canvas.html" class="compat">Q3Canvas</a>, and we then add two helper function that returns the rectangle for a certain tile in our tile pixmap. We will use a two-dimensional vector of ints to keep track of what tiles should be used at what parts of the scene.</p>
<pre class="highlightedCode brush: cpp"> void TileScene::setTiles(const QPixmap &amp;pixmap, int h, int v,
                          int tileHeight, int tileWidth)
 {
     tilePixmap = pixmap;
     tileW = tileWidth;
     tileH = tileHeight;
     hTiles = h;
     vTiles = v;

     tiles.resize(v);
     for (int y = 0; y &lt; v; ++y)
         tiles[y].resize(h);
 }</pre>
<p>In setTiles(), we store the pixmap and tile properties as members of the class. Then we resize the tiles vector to match the width and height of our tile grid.</p>
<pre class="highlightedCode brush: cpp"> void TileScene::setTile(int x, int y, int tilenum)
 {
     tiles[y][x] = tilenum;
     update(tileRect(x, y));
 }</pre>
<p>The setTile() function updates the tiles index, and then updates the corresponding rect in the scene by calling tileRect().</p>
<pre class="highlightedCode brush: cpp"> QRect TileScene::tileRect(int x, int y) const
 {
     return QRect(x * tileW, y * tileH, tileW, tileH);
 }</pre>
<p>The first tileRect() function returns a <a href="qrect.html">QRect</a> for the tile at position (x, y).</p>
<pre class="highlightedCode brush: cpp"> QRect TileScene::tileRect(int tileNum) const
 {
     int numHTiles = tilePixmap.width() / tileW;
     int numVTiles = tilePixmap.height() / tileH;
     return tileRect(tileNum % numHTiles, tileNum / numHTiles);
 }</pre>
<p>The second tileRect() function returns a <a href="qrect.html">QRect</a> for a tile number. With these functions in place, we can implement the drawBackground() function.</p>
<pre class="highlightedCode brush: cpp"> void drawBackground(QPainter *painter, const QRectF &amp;exposed)
 {
     for (int y = 0; y &lt; vTiles; ++y) {
         for (int x = 0; x &lt; hTiles; ++x) {
             QRect destRect = tileRect(x, y);
             if (exposed.intersects(destRect)) {
                 painter-&gt;drawPixmap(destRect, tilePixmap,
                                     tileRect(tiles[y][x]));
             }
         }
     }
 }</pre>
<p>In drawBackground(), we redraw all tiles that have been exposed by intersecting each tile rect with the exposed background area.</p>
<a name="porting-from-q3canvasview"></a>
<h2>Porting from Q3CanvasView</h2>
<p>The closest equivalent to <a href="q3canvasview.html" class="compat">Q3CanvasView</a> in Graphics View is called <a href="qgraphicsview.html">QGraphicsView</a>. In most cases, this is the easiest class to port. In addition to providing all of <a href="q3canvasview.html" class="compat">Q3CanvasView</a>'s functionality, <a href="qgraphicsview.html">QGraphicsView</a> includes some useful new features. You can read more about this in <a href="qgraphicsview.html">QGraphicsView</a>'s documentation.</p>
<a name="porting-table"></a>
<h3>Porting table</h3>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvasview.html" class="compat">Q3CanvasView</a></th><th ><a href="qgraphicsview.html">QGraphicsView</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvasview.html#Q3CanvasView">Q3CanvasView::Q3CanvasView</a>()</p></td><td ><p><a href="qgraphicsview.html">QGraphicsView</a> provides the same constructors as <a href="q3canvasview.html" class="compat">Q3CanvasView</a>, but without the name and flags arguments. You can set the name by calling <a href="qobject.html#objectName-prop">setObjectName()</a>, and the flags by calling <a href="qwidget.html#windowFlags-prop">setWindowFlags()</a>.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasview.html#canvas">Q3CanvasView::canvas</a>()</p></td><td ><p><a href="qgraphicsview.html#scene">QGraphicsView::scene</a>() returns the scene that is currently associated with the view. <a href="qgraphicsscene.html">QGraphicsScene</a> also provides the opposite function, <a href="qgraphicsscene.html#views">QGraphicsScene::views</a>(), which returns a list of views observing the scene.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasview.html#inverseWorldMatrix">Q3CanvasView::inverseWorldMatrix</a>()</p></td><td ><p>You can call <a href="qgraphicsview.html#matrix">QGraphicsView::matrix</a>() and <a href="qmatrix.html#inverted">QMatrix::inverted</a>(). <a href="qgraphicsview.html#mapToScene">QGraphicsView::mapToScene</a>() and <a href="qgraphicsview.html#mapFromScene">QGraphicsView::mapFromScene</a>() allow transforming of viewport shapes to scene shapes, and vice versa.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasview.html#setCanvas">Q3CanvasView::setCanvas</a>()</p></td><td ><p><a href="qgraphicsview.html#setScene">QGraphicsView::setScene</a>().</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasview.html#setWorldMatrix">Q3CanvasView::setWorldMatrix</a>()</p></td><td ><p><a href="qgraphicsview.html#setMatrix">QGraphicsView::setMatrix</a>(), <a href="qgraphicsview.html#rotate">QGraphicsView::rotate</a>(), <a href="qgraphicsview.html#scale">QGraphicsView::scale</a>(), <a href="qgraphicsview.html#shear">QGraphicsView::shear</a>() and <a href="qgraphicsview.html#translate">QGraphicsView::translate</a>().</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasview.html#worldMatrix">Q3CanvasView::worldMatrix</a>()</p></td><td ><p><a href="qgraphicsview.html#matrix">QGraphicsView::matrix</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasview.html#drawContents">Q3CanvasView::drawContents</a>()</p></td><td ><p>The <a href="qgraphicsview.html#drawBackground">QGraphicsView::drawBackground</a>() function draws the background, <a href="qgraphicsview.html#drawItems" class="obsolete">QGraphicsView::drawItems</a>() draws the items, and <a href="qgraphicsview.html#drawForeground">QGraphicsView::drawForeground</a>() draws the foreground of the scene in scene coordinates. You can also reimplement these functions in <a href="qgraphicsscene.html">QGraphicsScene</a>.</p></td></tr>
</table>
<a name="other-differences"></a>
<h3>Other differences</h3>
<p><a href="qgraphicsview.html">QGraphicsView</a> can cache the visible contents of the scene, similar to how <a href="q3canvas.html#setDoubleBuffering">Q3Canvas::setDoubleBuffering</a>() could cache the entire scene contents. You can call <a href="qgraphicsview.html#cacheMode-prop">QGraphicsView::setCacheMode</a>() to configure cacheing, and <a href="qgraphicsview.html#resetCachedContent">QGraphicsView::resetCachedContent</a>() invalidates the cache.</p>
<p>For improved navigation support, you can set a resize or transformation anchor through <a href="qgraphicsview.html#resizeAnchor-prop">QGraphicsView::resizeAnchor</a> and <a href="qgraphicsview.html#transformationAnchor-prop">QGraphicsView::transformationAnchor</a>. This allows you to easily rotate and zoom the view while keeping the center fixed, or zooming towards the position under the mouse cursor. In addition, if you set the <a href="qgraphicsview.html#dragMode-prop">QGraphicsView::dragMode</a> of the view, <a href="qgraphicsview.html">QGraphicsView</a> will provide rubber band selection or click-and-pull navigation using the <a href="qt.html#CursorShape-enum">OpenHandCursor</a> and <a href="qt.html#CursorShape-enum">ClosedHandCursor</a> cursors.</p>
<a name="porting-from-q3canvasitem"></a>
<h2>Porting from Q3CanvasItem</h2>
<p>The closest equivalent to <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> in Graphics View is called <a href="qgraphicsitem.html">QGraphicsItem</a>. Deriving from this class is very common, and because of that, porting from <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> often involves more work than <a href="q3canvas.html" class="compat">Q3Canvas</a> and <a href="q3canvasview.html" class="compat">Q3CanvasView</a>.</p>
<p><a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> has become easier to use, easier to subclass, and more powerful with <a href="qgraphicsitem.html">QGraphicsItem</a>. The key difference from <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> lies in event propagation and item groups, but you will also find several convenient new features, such as support for tooltips, cursors, item transformation and drag and drop. You can read all about <a href="qgraphicsitem.html">QGraphicsItem</a> in its own class documentation.</p>
<p>This section starts with a table that shows how to port each function from <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a> to <a href="qgraphicsitem.html">QGraphicsItem</a>. Immediately after that, each of <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>'s standard subclasses have a section of their own.</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvasitem.html" class="compat">Q3CanvasItem</a></th><th ><a href="qgraphicsitem.html">QGraphicsItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#advance">Q3CanvasItem::advance</a>()</p></td><td ><p><a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() is provided for compatibility. <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>() calls <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>() for all items. See also <a href="qtimeline.html">QTimeLine</a> and <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#animated">Q3CanvasItem::animated</a>()</p></td><td ><p>No equivalent; all items are advanced by <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>().</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#boundingRectAdvanced">Q3CanvasItem::boundingRectAdvanced</a>()</p></td><td ><p>No equivalent. You can translate <a href="qgraphicsitem.html#boundingRect">QGraphicsItem::boundingRect</a>() instead (see <a href="qrectf.html#translate">QRectF::translate</a>()).</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#canvas">Q3CanvasItem::canvas</a>()</p></td><td ><p><a href="qgraphicsitem.html#scene">QGraphicsItem::scene</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#collidesWith">Q3CanvasItem::collidesWith</a>()</p></td><td ><p><a href="qgraphicsitem.html#collidesWithItem">QGraphicsItem::collidesWithItem</a>() and <a href="qgraphicsitem.html#collidesWithPath">QGraphicsItem::collidesWithPath</a>().</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#collisions">Q3CanvasItem::collisions</a>()</p></td><td ><p><a href="qgraphicsitem.html#collidingItems">QGraphicsItem::collidingItems</a>() returns a list of all items that collide with an item. You can specify whether you want fast, rough estimate collision between bounding rectangles, or the slower, more accurate shapes.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#draw">Q3CanvasItem::draw</a>()</p></td><td ><p><a href="qgraphicsitem.html#paint">QGraphicsItem::paint</a>(). See also <a href="qstyleoptiongraphicsitem.html">QStyleOptionGraphicsItem</a>, <a href="qgraphicsscene.html#drawItems" class="obsolete">QGraphicsScene::drawItems</a>() and <a href="qgraphicsview.html#drawItems" class="obsolete">QGraphicsView::drawItems</a>().</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#hide">Q3CanvasItem::hide</a>()</p></td><td ><p><a href="qgraphicsitem.html#hide">QGraphicsItem::hide</a>() or <a href="qgraphicsitem.html#setVisible">QGraphicsItem::setVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#isActive">Q3CanvasItem::isActive</a>()</p></td><td ><p>No equivalent. To achieve similar behavior, you can add this property in a custom subclass of <a href="qgraphicsitem.html">QGraphicsItem</a>.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#isVisible">Q3CanvasItem::isVisible</a>()</p></td><td ><p><a href="qgraphicsitem.html#isVisible">QGraphicsItem::isVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#move">Q3CanvasItem::move</a>()</p></td><td ><p>You can call <a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>() to change the position of the item.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#rtti">Q3CanvasItem::rtti</a>()</p></td><td ><p><a href="qgraphicsitem.html#type">QGraphicsItem::type</a>() and <a href="qgraphicsitem.html#qgraphicsitem_cast">qgraphicsitem_cast</a>().</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#setActive">Q3CanvasItem::setActive</a>()</p></td><td ><p>No equivalent.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#setAnimated">Q3CanvasItem::setAnimated</a>()</p></td><td ><p>No equivalent; all items are by default &quot;animated&quot; (i.e&#x2e;, <a href="qgraphicsscene.html#advance">QGraphicsScene::advance</a>() advances all items on the scene).</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#setCanvas">Q3CanvasItem::setCanvas</a>()</p></td><td ><p>You can call <a href="qgraphicsscene.html#addItem">QGraphicsScene::addItem</a>(), or pass a pointer to the canvas to <a href="qgraphicsitem.html">QGraphicsItem</a>'s constructor.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#setVelocity">Q3CanvasItem::setVelocity</a>()</p></td><td ><p>No equivalent. You can add x and y velocity as member data of your class, and call QGraphicsItem::moveBy(x, y) from inside <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>(). See also <a href="qtimeline.html">QTimeLine</a> and <a href="qgraphicsitemanimation.html">QGraphicsItemAnimation</a>.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#setVisible">Q3CanvasItem::setVisible</a>()</p></td><td ><p><a href="qgraphicsitem.html#setVisible">QGraphicsItem::setVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#setX">Q3CanvasItem::setX</a>()</p></td><td ><p><a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#setY">Q3CanvasItem::setY</a>()</p></td><td ><p><a href="qgraphicsitem.html#setPos">QGraphicsItem::setPos</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#setXVelocity">Q3CanvasItem::setXVelocity</a>()</p></td><td ><p>No equivalent.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#setYVelocity">Q3CanvasItem::setYVelocity</a>()</p></td><td ><p>No equivalent.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#setZ">Q3CanvasItem::setZ</a>()</p></td><td ><p><a href="qgraphicsitem.html#setZValue">QGraphicsItem::setZValue</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#show">Q3CanvasItem::show</a>()</p></td><td ><p><a href="qgraphicsitem.html#show">QGraphicsItem::show</a>() or <a href="qgraphicsitem.html#setVisible">QGraphicsItem::setVisible</a>(). <a href="qgraphicsitem.html">QGraphicsItem</a>s are <i>visible</i> by default; <a href="q3canvasitem.html" class="compat">Q3CanvasItem</a>s, however, are not.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasitem.html#xVelocity">Q3CanvasItem::xVelocity</a>()</p></td><td ><p>No equivalent.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasitem.html#yVelocity">Q3CanvasItem::yVelocity</a>()</p></td><td ><p>No equivalent.</p></td></tr>
</table>
<p>Note that some virtual functions that have passed on to <a href="qgraphicsitem.html">QGraphicsItem</a> have lost their virtuality. An example is <a href="q3canvasitem.html#moveBy">Q3CanvasItem::moveBy</a>(), which was often used to track movement of items. In this case, the virtual <a href="qgraphicsitem.html#itemChange">QGraphicsItem::itemChange</a>() has taken over as a substitute.</p>
<a name="q3canvaspolygonalitem"></a>
<h3>Q3CanvasPolygonalItem</h3>
<p>The closest equivalent to <a href="q3canvaspolygonalitem.html" class="compat">Q3CanvasPolygonalItem</a> in Graphics View is called <a href="qabstractgraphicsshapeitem.html">QAbstractGraphicsShapeItem</a>. Unlike <a href="q3canvaspolygonalitem.html" class="compat">Q3CanvasPolygonalItem</a>, it does not define area points (<a href="q3canvaspolygonalitem.html#areaPoints">Q3CanvasPolygonalItem::areaPoints</a>()); instead, each item's geometry is stored as a member of the subclasses.</p>
<p>The <a href="q3canvaspolygonalitem.html#drawShape">Q3CanvasPolygonalItem::drawShape</a>() function is no longer available; instead, you can set the brush and pen from inside <a href="qgraphicsitem.html#paint">QGraphicsItem::paint</a>().</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvaspolygonalitem.html" class="compat">Q3CanvasPolygonalItem</a></th><th ><a href="qabstractgraphicsshapeitem.html">QAbstractGraphicsShapeItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvaspolygonalitem.html#areaPoints">Q3CanvasPolygonalItem::areaPoints</a>()</p></td><td ><p>No equivalent; each item's geometry is stored in the respective subclass.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvaspolygonalitem.html#areaPointsAdvanced">Q3CanvasPolygonalItem::areaPointsAdvanced</a>()</p></td><td ><p>No equivalent; you can use <a href="qpolygonf.html#translate">QPolygonF::translate</a>() or <a href="qpainterpath.html#translate">QPainterPath::translate</a>() instead.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvaspolygonalitem.html#drawShape">Q3CanvasPolygonalItem::drawShape</a>()</p></td><td ><p><a href="qgraphicsitem.html#paint">QGraphicsItem::paint</a>(). You can set the pen and brush from inside this function.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvaspolygonalitem.html#invalidate">Q3CanvasPolygonalItem::invalidate</a>()</p></td><td ><p>Call <a href="qgraphicsitem.html#prepareGeometryChange">QGraphicsItem::prepareGeometryChange</a>() before changing the item's geometry.</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvaspolygonalitem.html#isValid">Q3CanvasPolygonalItem::isValid</a>()</p></td><td ><p>No equivalent; items' geometry is always in a valid state.</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvaspolygonalitem.html#winding">Q3CanvasPolygonalItem::winding</a>()</p></td><td ><p>This function is only useful for polygon items and path items; see <a href="qgraphicspolygonitem.html#fillRule">QGraphicsPolygonItem::fillRule</a>(), and <a href="qpainterpath.html#fillRule">QPainterPath::fillRule</a>() for <a href="qgraphicspathitem.html">QGraphicsPathItem</a>.</p></td></tr>
</table>
<a name="q3canvasellipse"></a>
<h3>Q3CanvasEllipse</h3>
<p>The closest equivalent to <a href="q3canvasellipse.html" class="compat">Q3CanvasEllipse</a> in Graphics View is called <a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a>. The most noticable difference to <a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a> is that the ellipse is not longer drawn centered around its position; rather, it is drawn using a bounding <a href="qrectf.html">QRectF</a>, just like <a href="qpainter.html#drawEllipse">QPainter::drawEllipse</a>().</p>
<p>For compatibility, you may want to shift the ellipse up and to the left to keep the ellipse centered. Example:</p>
<pre class="highlightedCode brush: cpp">     // Before
     Q3CanvasEllipse ellipse(10, 10);

     // After
     QGraphicsEllipseItem ellipse(-5, -5, 10, 10);</pre>
<p>Note: <a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a> uses <a href="qabstractgraphicsshapeitem.html#pen">QAbstractGraphicsShapeItem::pen</a>() for outlines, whereas <a href="q3canvasellipse.html" class="compat">Q3CanvasEllipse</a> did not use <a href="q3canvaspolygonalitem.html#pen">Q3CanvasPolygonalItem::pen</a>().</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvasellipse.html" class="compat">Q3CanvasEllipse</a></th><th ><a href="qgraphicsellipseitem.html">QGraphicsEllipseItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvasellipse.html#angleLength">Q3CanvasEllipse::angleLength</a>()</p></td><td ><p><a href="qgraphicsellipseitem.html#spanAngle">QGraphicsEllipseItem::spanAngle</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasellipse.html#angleStart">Q3CanvasEllipse::angleStart</a>()</p></td><td ><p><a href="qgraphicsellipseitem.html#startAngle">QGraphicsEllipseItem::startAngle</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasellipse.html#setAngles">Q3CanvasEllipse::setAngles</a>()</p></td><td ><p><a href="qgraphicsellipseitem.html#setStartAngle">QGraphicsEllipseItem::setStartAngle</a>() and <a href="qgraphicsellipseitem.html#setSpanAngle">QGraphicsEllipseItem::setSpanAngle</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasellipse.html#setSize">Q3CanvasEllipse::setSize</a>()</p></td><td ><p><a href="qgraphicsellipseitem.html#setRect">QGraphicsEllipseItem::setRect</a>()</p></td></tr>
</table>
<a name="q3canvasline"></a>
<h3>Q3CanvasLine</h3>
<p>The closest equivalent to <a href="q3canvasline.html" class="compat">Q3CanvasLine</a> in Graphics View is called <a href="qgraphicslineitem.html">QGraphicsLineItem</a>.</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvasline.html" class="compat">Q3CanvasLine</a></th><th ><a href="qgraphicslineitem.html">QGraphicsLineItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvasline.html#endPoint">Q3CanvasLine::endPoint</a>()</p></td><td ><p><a href="qgraphicslineitem.html#line">QGraphicsLineItem::line</a>() and <a href="qlinef.html#p2">QLineF::p2</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasline.html#setPoints">Q3CanvasLine::setPoints</a>()</p></td><td ><p><a href="qgraphicslineitem.html#setLine">QGraphicsLineItem::setLine</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasline.html#startPoint">Q3CanvasLine::startPoint</a>()</p></td><td ><p><a href="qgraphicslineitem.html#line">QGraphicsLineItem::line</a>() and <a href="qlinef.html#p1">QLineF::p1</a>()</p></td></tr>
</table>
<a name="q3canvaspolygon"></a>
<h3>Q3CanvasPolygon</h3>
<p>The closest equivalent to <a href="q3canvaspolygon.html" class="compat">Q3CanvasPolygon</a> in Graphics View is called <a href="qgraphicspolygonitem.html">QGraphicsPolygonItem</a>.</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvaspolygon.html" class="compat">Q3CanvasPolygon</a></th><th ><a href="qgraphicspolygonitem.html">QGraphicsPolygonItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvaspolygon.html#areaPoints">Q3CanvasPolygon::areaPoints</a>()</p></td><td ><p><a href="qgraphicspolygonitem.html#polygon">QGraphicsPolygonItem::polygon</a>() and <a href="qgraphicsitem.html#mapToParent">QGraphicsItem::mapToParent</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvaspolygon.html#points">Q3CanvasPolygon::points</a>()</p></td><td ><p><a href="qgraphicspolygonitem.html#polygon">QGraphicsPolygonItem::polygon</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvaspolygon.html#setPoints">Q3CanvasPolygon::setPoints</a>()</p></td><td ><p><a href="qgraphicspolygonitem.html#setPolygon">QGraphicsPolygonItem::setPolygon</a>()</p></td></tr>
</table>
<a name="q3canvasspline"></a>
<h3>Q3CanvasSpline</h3>
<p>The closest equivalent to <a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a> in Graphics View is called <a href="qgraphicspathitem.html">QGraphicsPathItem</a>. This item can be used to describe any type of path supported by <a href="qpainter.html">QPainter</a>.</p>
<p><a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a> takes its control points as a <a href="q3pointarray.html" class="compat">Q3PointArray</a>, but <a href="qpainterpath.html">QPainterPath</a> operates on a sequence of calls to <a href="qpainterpath.html#moveTo">QPainterPath::moveTo</a>() and <a href="qpainterpath.html#cubicTo">QPainterPath::cubicTo</a>(). Here is how you can convert a bezier curve <a href="q3pointarray.html" class="compat">Q3PointArray</a> to a <a href="qpainterpath.html">QPainterPath</a>:</p>
<pre class="highlightedCode brush: cpp"> static QPainterPath fromControlPoints(const Q3PointArray &amp;pa)
 {
     QPainterPath path;
     path.moveTo(pa[0]);
     for (int i = 1; i &lt; pa.size(); i += 3)
         path.cubicTo(pa[i], pa[(i + 1) % pa.size()], pa[(i + 2) % pa.size()]);
     return path;
 }</pre>
<p>Note: <a href="qgraphicspathitem.html">QGraphicsPathItem</a> uses <a href="qabstractgraphicsshapeitem.html#pen">QAbstractGraphicsShapeItem::pen</a>() for outlines, whereas <a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a> did not use <a href="q3canvaspolygonalitem.html#pen">Q3CanvasPolygonalItem::pen</a>().</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvasspline.html" class="compat">Q3CanvasSpline</a></th><th ><a href="qgraphicspathitem.html">QGraphicsPathItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvasspline.html#closed">Q3CanvasSpline::closed</a>()</p></td><td ><p>No equivalent. You can call QPainterPath::closeSubPath() to close a subpath explicitly.</p></td></tr>
</table>
<a name="q3canvasrectangle"></a>
<h3>Q3CanvasRectangle</h3>
<p>The closest equivalent to <a href="q3canvasrectangle.html" class="compat">Q3CanvasRectangle</a> in Graphics View is called <a href="qgraphicsrectitem.html">QGraphicsRectItem</a>.</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvasrectangle.html" class="compat">Q3CanvasRectangle</a></th><th ><a href="qgraphicsrectitem.html">QGraphicsRectItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvasrectangle.html#height">Q3CanvasRectangle::height</a>()</p></td><td ><p><a href="qgraphicsrectitem.html#rect">QGraphicsRectItem::rect</a>() and <a href="qrectf.html#height">QRectF::height</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasrectangle.html#setSize">Q3CanvasRectangle::setSize</a>()</p></td><td ><p><a href="qgraphicsrectitem.html#setRect">QGraphicsRectItem::setRect</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasrectangle.html#size">Q3CanvasRectangle::size</a>()</p></td><td ><p><a href="qgraphicsrectitem.html#rect">QGraphicsRectItem::rect</a>() and <a href="qrectf.html#size">QRectF::size</a>()</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvasrectangle.html#width">Q3CanvasRectangle::width</a>()</p></td><td ><p><a href="qgraphicsrectitem.html#rect">QGraphicsRectItem::rect</a>() and <a href="qrectf.html#width">QRectF::width</a>()</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvasrectangle.html#chunks">Q3CanvasRectangle::chunks</a>()</p></td><td ><p>No equivalent.</p></td></tr>
</table>
<a name="q3canvassprite"></a>
<h3>Q3CanvasSprite</h3>
<p><a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a> is the item class that differs the most from its <a href="q3canvas.html" class="compat">Q3Canvas</a> predecessor. The closest resemblance of <a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a> in Graphics View is <a href="qgraphicspixmapitem.html">QGraphicsPixmapItem</a>.</p>
<p><a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a> supports animated pixmaps; <a href="qgraphicspixmapitem.html">QGraphicsPixmapItem</a>, however, is a simple single-frame pixmap item. If all you need is a pixmap item, porting is straight-forward. If you do need the animation support, extra work is required; there is no direct porting approach.</p>
<p>For the <a href="graphicsview-portedasteroids.html">Ported Asteroids Example</a>, a subclass of <a href="qgraphicspixmapitem.html">QGraphicsPixmapItem</a> is used to replace <a href="q3canvassprite.html" class="compat">Q3CanvasSprite</a>, storing a list of pixmaps and a frame counter. The animation is advanced in <a href="qgraphicsitem.html#advance">QGraphicsItem::advance</a>().</p>
<a name="q3canvaspixmap-q3canvaspixmaparray"></a>
<h4>Q3CanvasPixmap, Q3CanvasPixmapArray</h4>
<p>These classes have been removed from the API. You can use <a href="qpixmap.html">QPixmap</a> instead of <a href="q3canvaspixmap.html" class="compat">Q3CanvasPixmap</a>, and <a href="qlist.html">QList</a> instead of <a href="q3canvaspixmaparray.html" class="compat">Q3CanvasPixmapArray</a>.</p>
<p><a href="q3canvaspixmaparray.html" class="compat">Q3CanvasPixmapArray</a> included convenience for loading a sequence of pixmaps or masks using a path with a wildcard (see <a href="q3canvaspixmaparray.html#readPixmaps">Q3CanvasPixmapArray::readPixmaps</a>() and <a href="q3canvaspixmaparray.html#readCollisionMasks">Q3CanvasPixmapArray::readCollisionMasks</a>()). To achieve similar functionality using Graphics View, you can load the images by using <a href="qdir.html">QDir</a>:</p>
<pre class="highlightedCode brush: cpp"> wildcardPath.replace(&quot;%1&quot;, &quot;*&quot;);
 QFileInfo fi(wildcardPath);

 QList&lt;QPixmap&gt; frames;
 foreach (QString entry, QDir(fi.path(), fi.fileName()).entryList())
     frames &lt;&lt; QPixmap(fi.path() + &quot;/&quot; + entry);</pre>
<a name="q3canvastext"></a>
<h3>Q3CanvasText</h3>
<p><a href="q3canvastext.html" class="compat">Q3CanvasText</a> has been split into two classes in Graphics View: <a href="qgraphicssimpletextitem.html">QGraphicsSimpleTextItem</a> and <a href="qgraphicstextitem.html">QGraphicsTextItem</a>. For porting, <a href="qgraphicssimpletextitem.html">QGraphicsSimpleTextItem</a> should be adequate. <a href="qgraphicstextitem.html">QGraphicsTextItem</a> provides advanced document structuring features similar to that of <a href="qtextedit.html">QTextEdit</a>, and it also allows interaction (e.g&#x2e;, editing and selection).</p>
<table class="generic">
<thead><tr class="qt-style topAlign"><th ><a href="q3canvastext.html" class="compat">Q3CanvasText</a></th><th ><a href="qgraphicssimpletextitem.html">QGraphicsSimpleTextItem</a></th></tr></thead>
<tr class="odd topAlign"><td ><p><a href="q3canvastext.html#color">Q3CanvasText::color</a>()</p></td><td ><p><a href="qabstractgraphicsshapeitem.html#pen">QGraphicsSimpleTextItem::pen</a>().</p></td></tr>
<tr class="even topAlign"><td ><p><a href="q3canvastext.html#setColor">Q3CanvasText::setColor</a>()</p></td><td ><p><a href="qabstractgraphicsshapeitem.html#setPen">QGraphicsSimpleTextItem::setPen</a>().</p></td></tr>
<tr class="odd topAlign"><td ><p><a href="q3canvastext.html#textFlags">Q3CanvasText::textFlags</a>()</p></td><td ><p>Use <a href="qgraphicstextitem.html">QGraphicsTextItem</a> instead.</p></td></tr>
</table>
<a name="q3canvasitemlist"></a>
<h3>Q3CanvasItemList</h3>
<p>Use <a href="qlist.html">QList</a> instead.</p>
<a name="other-resources"></a>
<h2>Other Resources</h2>
<p>The <a href="http://qt.nokia.com/qq/qq21-portingcanvas.html">Porting to Qt 4.2's Graphics View</a> article in Qt Quarterly 21 covered the process of porting the Qt 3 canvas example to Qt 4. The result of this is the <a href="graphicsview-portedcanvas.html">Ported Canvas</a> example.</p>
</div>
<!-- @@@graphicsview-porting.html -->
<p>
[Previous: <a href="porting4-designer.html">Porting UI Files to Qt 4</a>]
[Next: <a href="qt3to4.html">qt3to4 - The Qt 3 to 4 Porting Tool</a>]
</p>
        <!-- /div -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback. <div class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</div></p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
  <!--/div -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-4457116-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
